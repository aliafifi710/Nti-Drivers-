
RTOS_Task1_LedIntro.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000026f0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  00800060  000026f0  00002784  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002f9  0080006e  0080006e  00002792  2**0
                  ALLOC
  3 .stab         00004338  00000000  00000000  00002794  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000293a  00000000  00000000  00006acc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 e8 07 	jmp	0xfd0	; 0xfd0 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 ef       	ldi	r30, 0xF0	; 240
      68:	f6 e2       	ldi	r31, 0x26	; 38
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ae 36       	cpi	r26, 0x6E	; 110
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	ae e6       	ldi	r26, 0x6E	; 110
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a7 36       	cpi	r26, 0x67	; 103
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 49 00 	call	0x92	; 0x92 <main>
      8a:	0c 94 76 13 	jmp	0x26ec	; 0x26ec <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <main>:
      92:	af 92       	push	r10
      94:	bf 92       	push	r11
      96:	cf 92       	push	r12
      98:	df 92       	push	r13
      9a:	ef 92       	push	r14
      9c:	ff 92       	push	r15
      9e:	0f 93       	push	r16
      a0:	df 93       	push	r29
      a2:	cf 93       	push	r28
      a4:	cd b7       	in	r28, 0x3d	; 61
      a6:	de b7       	in	r29, 0x3e	; 62
      a8:	a7 e3       	ldi	r26, 0x37	; 55
      aa:	b0 e0       	ldi	r27, 0x00	; 0
      ac:	e7 e3       	ldi	r30, 0x37	; 55
      ae:	f0 e0       	ldi	r31, 0x00	; 0
      b0:	80 81       	ld	r24, Z
      b2:	81 60       	ori	r24, 0x01	; 1
      b4:	8c 93       	st	X, r24
      b6:	20 e6       	ldi	r18, 0x60	; 96
      b8:	30 e0       	ldi	r19, 0x00	; 0
      ba:	8c e7       	ldi	r24, 0x7C	; 124
      bc:	90 e0       	ldi	r25, 0x00	; 0
      be:	ee e6       	ldi	r30, 0x6E	; 110
      c0:	f0 e0       	ldi	r31, 0x00	; 0
      c2:	b9 01       	movw	r22, r18
      c4:	45 e5       	ldi	r20, 0x55	; 85
      c6:	50 e0       	ldi	r21, 0x00	; 0
      c8:	20 e0       	ldi	r18, 0x00	; 0
      ca:	30 e0       	ldi	r19, 0x00	; 0
      cc:	02 e0       	ldi	r16, 0x02	; 2
      ce:	7f 01       	movw	r14, r30
      d0:	cc 24       	eor	r12, r12
      d2:	dd 24       	eor	r13, r13
      d4:	aa 24       	eor	r10, r10
      d6:	bb 24       	eor	r11, r11
      d8:	0e 94 6c 0c 	call	0x18d8	; 0x18d8 <xTaskGenericCreate>
      dc:	0e 94 65 0e 	call	0x1cca	; 0x1cca <vTaskStartScheduler>
      e0:	80 e0       	ldi	r24, 0x00	; 0
      e2:	90 e0       	ldi	r25, 0x00	; 0
      e4:	cf 91       	pop	r28
      e6:	df 91       	pop	r29
      e8:	0f 91       	pop	r16
      ea:	ff 90       	pop	r15
      ec:	ef 90       	pop	r14
      ee:	df 90       	pop	r13
      f0:	cf 90       	pop	r12
      f2:	bf 90       	pop	r11
      f4:	af 90       	pop	r10
      f6:	08 95       	ret

000000f8 <LedIntro_code>:
	return 0;
}

/*Task1 Code */
 void LedIntro_code(void*pvParamter)
{
      f8:	df 93       	push	r29
      fa:	cf 93       	push	r28
      fc:	00 d0       	rcall	.+0      	; 0xfe <LedIntro_code+0x6>
      fe:	cd b7       	in	r28, 0x3d	; 61
     100:	de b7       	in	r29, 0x3e	; 62
     102:	9a 83       	std	Y+2, r25	; 0x02
     104:	89 83       	std	Y+1, r24	; 0x01
	for (;;)
	{

		/*Toggle Led */
		PORTB |= 0x01;
     106:	a8 e3       	ldi	r26, 0x38	; 56
     108:	b0 e0       	ldi	r27, 0x00	; 0
     10a:	e8 e3       	ldi	r30, 0x38	; 56
     10c:	f0 e0       	ldi	r31, 0x00	; 0
     10e:	80 81       	ld	r24, Z
     110:	81 60       	ori	r24, 0x01	; 1
     112:	8c 93       	st	X, r24

		/*Send Task in Blocked Queue for 2000 Ticks */
		vTaskDelay(2000);
     114:	80 ed       	ldi	r24, 0xD0	; 208
     116:	97 e0       	ldi	r25, 0x07	; 7
     118:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <vTaskDelay>

		/*Toggle Led */
		PORTB &= 0xFE;
     11c:	a8 e3       	ldi	r26, 0x38	; 56
     11e:	b0 e0       	ldi	r27, 0x00	; 0
     120:	e8 e3       	ldi	r30, 0x38	; 56
     122:	f0 e0       	ldi	r31, 0x00	; 0
     124:	80 81       	ld	r24, Z
     126:	8e 7f       	andi	r24, 0xFE	; 254
     128:	8c 93       	st	X, r24

		vTaskDelay(2000);
     12a:	80 ed       	ldi	r24, 0xD0	; 208
     12c:	97 e0       	ldi	r25, 0x07	; 7
     12e:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <vTaskDelay>
     132:	e9 cf       	rjmp	.-46     	; 0x106 <LedIntro_code+0xe>

00000134 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     134:	df 93       	push	r29
     136:	cf 93       	push	r28
     138:	cd b7       	in	r28, 0x3d	; 61
     13a:	de b7       	in	r29, 0x3e	; 62
     13c:	27 97       	sbiw	r28, 0x07	; 7
     13e:	0f b6       	in	r0, 0x3f	; 63
     140:	f8 94       	cli
     142:	de bf       	out	0x3e, r29	; 62
     144:	0f be       	out	0x3f, r0	; 63
     146:	cd bf       	out	0x3d, r28	; 61
     148:	9d 83       	std	Y+5, r25	; 0x05
     14a:	8c 83       	std	Y+4, r24	; 0x04
     14c:	6e 83       	std	Y+6, r22	; 0x06
     14e:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     150:	8a e1       	ldi	r24, 0x1A	; 26
     152:	90 e0       	ldi	r25, 0x00	; 0
     154:	0e 94 72 03 	call	0x6e4	; 0x6e4 <pvPortMalloc>
     158:	9a 83       	std	Y+2, r25	; 0x02
     15a:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     15c:	89 81       	ldd	r24, Y+1	; 0x01
     15e:	9a 81       	ldd	r25, Y+2	; 0x02
     160:	00 97       	sbiw	r24, 0x00	; 0
     162:	09 f4       	brne	.+2      	; 0x166 <xCoRoutineCreate+0x32>
     164:	6f c0       	rjmp	.+222    	; 0x244 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     166:	80 91 70 00 	lds	r24, 0x0070
     16a:	90 91 71 00 	lds	r25, 0x0071
     16e:	00 97       	sbiw	r24, 0x00	; 0
     170:	41 f4       	brne	.+16     	; 0x182 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     172:	89 81       	ldd	r24, Y+1	; 0x01
     174:	9a 81       	ldd	r25, Y+2	; 0x02
     176:	90 93 71 00 	sts	0x0071, r25
     17a:	80 93 70 00 	sts	0x0070, r24
			prvInitialiseCoRoutineLists();
     17e:	0e 94 01 03 	call	0x602	; 0x602 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     182:	8e 81       	ldd	r24, Y+6	; 0x06
     184:	82 30       	cpi	r24, 0x02	; 2
     186:	10 f0       	brcs	.+4      	; 0x18c <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     188:	81 e0       	ldi	r24, 0x01	; 1
     18a:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     18c:	e9 81       	ldd	r30, Y+1	; 0x01
     18e:	fa 81       	ldd	r31, Y+2	; 0x02
     190:	11 8e       	std	Z+25, r1	; 0x19
     192:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     194:	e9 81       	ldd	r30, Y+1	; 0x01
     196:	fa 81       	ldd	r31, Y+2	; 0x02
     198:	8e 81       	ldd	r24, Y+6	; 0x06
     19a:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     19c:	e9 81       	ldd	r30, Y+1	; 0x01
     19e:	fa 81       	ldd	r31, Y+2	; 0x02
     1a0:	8f 81       	ldd	r24, Y+7	; 0x07
     1a2:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     1a4:	e9 81       	ldd	r30, Y+1	; 0x01
     1a6:	fa 81       	ldd	r31, Y+2	; 0x02
     1a8:	8c 81       	ldd	r24, Y+4	; 0x04
     1aa:	9d 81       	ldd	r25, Y+5	; 0x05
     1ac:	91 83       	std	Z+1, r25	; 0x01
     1ae:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     1b0:	89 81       	ldd	r24, Y+1	; 0x01
     1b2:	9a 81       	ldd	r25, Y+2	; 0x02
     1b4:	02 96       	adiw	r24, 0x02	; 2
     1b6:	0e 94 08 04 	call	0x810	; 0x810 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     1ba:	89 81       	ldd	r24, Y+1	; 0x01
     1bc:	9a 81       	ldd	r25, Y+2	; 0x02
     1be:	0c 96       	adiw	r24, 0x0c	; 12
     1c0:	0e 94 08 04 	call	0x810	; 0x810 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     1c4:	e9 81       	ldd	r30, Y+1	; 0x01
     1c6:	fa 81       	ldd	r31, Y+2	; 0x02
     1c8:	89 81       	ldd	r24, Y+1	; 0x01
     1ca:	9a 81       	ldd	r25, Y+2	; 0x02
     1cc:	91 87       	std	Z+9, r25	; 0x09
     1ce:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     1d0:	e9 81       	ldd	r30, Y+1	; 0x01
     1d2:	fa 81       	ldd	r31, Y+2	; 0x02
     1d4:	89 81       	ldd	r24, Y+1	; 0x01
     1d6:	9a 81       	ldd	r25, Y+2	; 0x02
     1d8:	93 8b       	std	Z+19, r25	; 0x13
     1da:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     1dc:	8e 81       	ldd	r24, Y+6	; 0x06
     1de:	28 2f       	mov	r18, r24
     1e0:	30 e0       	ldi	r19, 0x00	; 0
     1e2:	85 e0       	ldi	r24, 0x05	; 5
     1e4:	90 e0       	ldi	r25, 0x00	; 0
     1e6:	82 1b       	sub	r24, r18
     1e8:	93 0b       	sbc	r25, r19
     1ea:	e9 81       	ldd	r30, Y+1	; 0x01
     1ec:	fa 81       	ldd	r31, Y+2	; 0x02
     1ee:	95 87       	std	Z+13, r25	; 0x0d
     1f0:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     1f2:	e9 81       	ldd	r30, Y+1	; 0x01
     1f4:	fa 81       	ldd	r31, Y+2	; 0x02
     1f6:	96 89       	ldd	r25, Z+22	; 0x16
     1f8:	80 91 72 00 	lds	r24, 0x0072
     1fc:	89 17       	cp	r24, r25
     1fe:	28 f4       	brcc	.+10     	; 0x20a <xCoRoutineCreate+0xd6>
     200:	e9 81       	ldd	r30, Y+1	; 0x01
     202:	fa 81       	ldd	r31, Y+2	; 0x02
     204:	86 89       	ldd	r24, Z+22	; 0x16
     206:	80 93 72 00 	sts	0x0072, r24
     20a:	e9 81       	ldd	r30, Y+1	; 0x01
     20c:	fa 81       	ldd	r31, Y+2	; 0x02
     20e:	86 89       	ldd	r24, Z+22	; 0x16
     210:	28 2f       	mov	r18, r24
     212:	30 e0       	ldi	r19, 0x00	; 0
     214:	c9 01       	movw	r24, r18
     216:	88 0f       	add	r24, r24
     218:	99 1f       	adc	r25, r25
     21a:	88 0f       	add	r24, r24
     21c:	99 1f       	adc	r25, r25
     21e:	88 0f       	add	r24, r24
     220:	99 1f       	adc	r25, r25
     222:	82 0f       	add	r24, r18
     224:	93 1f       	adc	r25, r19
     226:	ac 01       	movw	r20, r24
     228:	47 58       	subi	r20, 0x87	; 135
     22a:	5f 4f       	sbci	r21, 0xFF	; 255
     22c:	89 81       	ldd	r24, Y+1	; 0x01
     22e:	9a 81       	ldd	r25, Y+2	; 0x02
     230:	9c 01       	movw	r18, r24
     232:	2e 5f       	subi	r18, 0xFE	; 254
     234:	3f 4f       	sbci	r19, 0xFF	; 255
     236:	ca 01       	movw	r24, r20
     238:	b9 01       	movw	r22, r18
     23a:	0e 94 18 04 	call	0x830	; 0x830 <vListInsertEnd>

		xReturn = pdPASS;
     23e:	81 e0       	ldi	r24, 0x01	; 1
     240:	8b 83       	std	Y+3, r24	; 0x03
     242:	02 c0       	rjmp	.+4      	; 0x248 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     244:	8f ef       	ldi	r24, 0xFF	; 255
     246:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     248:	8b 81       	ldd	r24, Y+3	; 0x03
}
     24a:	27 96       	adiw	r28, 0x07	; 7
     24c:	0f b6       	in	r0, 0x3f	; 63
     24e:	f8 94       	cli
     250:	de bf       	out	0x3e, r29	; 62
     252:	0f be       	out	0x3f, r0	; 63
     254:	cd bf       	out	0x3d, r28	; 61
     256:	cf 91       	pop	r28
     258:	df 91       	pop	r29
     25a:	08 95       	ret

0000025c <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     25c:	df 93       	push	r29
     25e:	cf 93       	push	r28
     260:	00 d0       	rcall	.+0      	; 0x262 <vCoRoutineAddToDelayedList+0x6>
     262:	00 d0       	rcall	.+0      	; 0x264 <vCoRoutineAddToDelayedList+0x8>
     264:	00 d0       	rcall	.+0      	; 0x266 <vCoRoutineAddToDelayedList+0xa>
     266:	cd b7       	in	r28, 0x3d	; 61
     268:	de b7       	in	r29, 0x3e	; 62
     26a:	9c 83       	std	Y+4, r25	; 0x04
     26c:	8b 83       	std	Y+3, r24	; 0x03
     26e:	7e 83       	std	Y+6, r23	; 0x06
     270:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     272:	20 91 73 00 	lds	r18, 0x0073
     276:	30 91 74 00 	lds	r19, 0x0074
     27a:	8b 81       	ldd	r24, Y+3	; 0x03
     27c:	9c 81       	ldd	r25, Y+4	; 0x04
     27e:	82 0f       	add	r24, r18
     280:	93 1f       	adc	r25, r19
     282:	9a 83       	std	Y+2, r25	; 0x02
     284:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     286:	80 91 70 00 	lds	r24, 0x0070
     28a:	90 91 71 00 	lds	r25, 0x0071
     28e:	02 96       	adiw	r24, 0x02	; 2
     290:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     294:	e0 91 70 00 	lds	r30, 0x0070
     298:	f0 91 71 00 	lds	r31, 0x0071
     29c:	89 81       	ldd	r24, Y+1	; 0x01
     29e:	9a 81       	ldd	r25, Y+2	; 0x02
     2a0:	93 83       	std	Z+3, r25	; 0x03
     2a2:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     2a4:	20 91 73 00 	lds	r18, 0x0073
     2a8:	30 91 74 00 	lds	r19, 0x0074
     2ac:	89 81       	ldd	r24, Y+1	; 0x01
     2ae:	9a 81       	ldd	r25, Y+2	; 0x02
     2b0:	82 17       	cp	r24, r18
     2b2:	93 07       	cpc	r25, r19
     2b4:	70 f4       	brcc	.+28     	; 0x2d2 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     2b6:	80 91 9f 00 	lds	r24, 0x009F
     2ba:	90 91 a0 00 	lds	r25, 0x00A0
     2be:	20 91 70 00 	lds	r18, 0x0070
     2c2:	30 91 71 00 	lds	r19, 0x0071
     2c6:	2e 5f       	subi	r18, 0xFE	; 254
     2c8:	3f 4f       	sbci	r19, 0xFF	; 255
     2ca:	b9 01       	movw	r22, r18
     2cc:	0e 94 64 04 	call	0x8c8	; 0x8c8 <vListInsert>
     2d0:	0d c0       	rjmp	.+26     	; 0x2ec <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     2d2:	80 91 9d 00 	lds	r24, 0x009D
     2d6:	90 91 9e 00 	lds	r25, 0x009E
     2da:	20 91 70 00 	lds	r18, 0x0070
     2de:	30 91 71 00 	lds	r19, 0x0071
     2e2:	2e 5f       	subi	r18, 0xFE	; 254
     2e4:	3f 4f       	sbci	r19, 0xFF	; 255
     2e6:	b9 01       	movw	r22, r18
     2e8:	0e 94 64 04 	call	0x8c8	; 0x8c8 <vListInsert>
	}

	if( pxEventList )
     2ec:	8d 81       	ldd	r24, Y+5	; 0x05
     2ee:	9e 81       	ldd	r25, Y+6	; 0x06
     2f0:	00 97       	sbiw	r24, 0x00	; 0
     2f2:	61 f0       	breq	.+24     	; 0x30c <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     2f4:	80 91 70 00 	lds	r24, 0x0070
     2f8:	90 91 71 00 	lds	r25, 0x0071
     2fc:	9c 01       	movw	r18, r24
     2fe:	24 5f       	subi	r18, 0xF4	; 244
     300:	3f 4f       	sbci	r19, 0xFF	; 255
     302:	8d 81       	ldd	r24, Y+5	; 0x05
     304:	9e 81       	ldd	r25, Y+6	; 0x06
     306:	b9 01       	movw	r22, r18
     308:	0e 94 64 04 	call	0x8c8	; 0x8c8 <vListInsert>
	}
}
     30c:	26 96       	adiw	r28, 0x06	; 6
     30e:	0f b6       	in	r0, 0x3f	; 63
     310:	f8 94       	cli
     312:	de bf       	out	0x3e, r29	; 62
     314:	0f be       	out	0x3f, r0	; 63
     316:	cd bf       	out	0x3d, r28	; 61
     318:	cf 91       	pop	r28
     31a:	df 91       	pop	r29
     31c:	08 95       	ret

0000031e <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     31e:	df 93       	push	r29
     320:	cf 93       	push	r28
     322:	00 d0       	rcall	.+0      	; 0x324 <prvCheckPendingReadyList+0x6>
     324:	cd b7       	in	r28, 0x3d	; 61
     326:	de b7       	in	r29, 0x3e	; 62
     328:	3a c0       	rjmp	.+116    	; 0x39e <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     32a:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     32c:	e0 91 a6 00 	lds	r30, 0x00A6
     330:	f0 91 a7 00 	lds	r31, 0x00A7
     334:	86 81       	ldd	r24, Z+6	; 0x06
     336:	97 81       	ldd	r25, Z+7	; 0x07
     338:	9a 83       	std	Y+2, r25	; 0x02
     33a:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     33c:	89 81       	ldd	r24, Y+1	; 0x01
     33e:	9a 81       	ldd	r25, Y+2	; 0x02
     340:	0c 96       	adiw	r24, 0x0c	; 12
     342:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     346:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     348:	89 81       	ldd	r24, Y+1	; 0x01
     34a:	9a 81       	ldd	r25, Y+2	; 0x02
     34c:	02 96       	adiw	r24, 0x02	; 2
     34e:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     352:	e9 81       	ldd	r30, Y+1	; 0x01
     354:	fa 81       	ldd	r31, Y+2	; 0x02
     356:	96 89       	ldd	r25, Z+22	; 0x16
     358:	80 91 72 00 	lds	r24, 0x0072
     35c:	89 17       	cp	r24, r25
     35e:	28 f4       	brcc	.+10     	; 0x36a <prvCheckPendingReadyList+0x4c>
     360:	e9 81       	ldd	r30, Y+1	; 0x01
     362:	fa 81       	ldd	r31, Y+2	; 0x02
     364:	86 89       	ldd	r24, Z+22	; 0x16
     366:	80 93 72 00 	sts	0x0072, r24
     36a:	e9 81       	ldd	r30, Y+1	; 0x01
     36c:	fa 81       	ldd	r31, Y+2	; 0x02
     36e:	86 89       	ldd	r24, Z+22	; 0x16
     370:	28 2f       	mov	r18, r24
     372:	30 e0       	ldi	r19, 0x00	; 0
     374:	c9 01       	movw	r24, r18
     376:	88 0f       	add	r24, r24
     378:	99 1f       	adc	r25, r25
     37a:	88 0f       	add	r24, r24
     37c:	99 1f       	adc	r25, r25
     37e:	88 0f       	add	r24, r24
     380:	99 1f       	adc	r25, r25
     382:	82 0f       	add	r24, r18
     384:	93 1f       	adc	r25, r19
     386:	ac 01       	movw	r20, r24
     388:	47 58       	subi	r20, 0x87	; 135
     38a:	5f 4f       	sbci	r21, 0xFF	; 255
     38c:	89 81       	ldd	r24, Y+1	; 0x01
     38e:	9a 81       	ldd	r25, Y+2	; 0x02
     390:	9c 01       	movw	r18, r24
     392:	2e 5f       	subi	r18, 0xFE	; 254
     394:	3f 4f       	sbci	r19, 0xFF	; 255
     396:	ca 01       	movw	r24, r20
     398:	b9 01       	movw	r22, r18
     39a:	0e 94 18 04 	call	0x830	; 0x830 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     39e:	80 91 a1 00 	lds	r24, 0x00A1
     3a2:	88 23       	and	r24, r24
     3a4:	09 f0       	breq	.+2      	; 0x3a8 <prvCheckPendingReadyList+0x8a>
     3a6:	c1 cf       	rjmp	.-126    	; 0x32a <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     3a8:	0f 90       	pop	r0
     3aa:	0f 90       	pop	r0
     3ac:	cf 91       	pop	r28
     3ae:	df 91       	pop	r29
     3b0:	08 95       	ret

000003b2 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     3b2:	df 93       	push	r29
     3b4:	cf 93       	push	r28
     3b6:	00 d0       	rcall	.+0      	; 0x3b8 <prvCheckDelayedList+0x6>
     3b8:	00 d0       	rcall	.+0      	; 0x3ba <prvCheckDelayedList+0x8>
     3ba:	cd b7       	in	r28, 0x3d	; 61
     3bc:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     3be:	0e 94 3e 0f 	call	0x1e7c	; 0x1e7c <xTaskGetTickCount>
     3c2:	20 91 75 00 	lds	r18, 0x0075
     3c6:	30 91 76 00 	lds	r19, 0x0076
     3ca:	82 1b       	sub	r24, r18
     3cc:	93 0b       	sbc	r25, r19
     3ce:	90 93 78 00 	sts	0x0078, r25
     3d2:	80 93 77 00 	sts	0x0077, r24
     3d6:	85 c0       	rjmp	.+266    	; 0x4e2 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     3d8:	80 91 73 00 	lds	r24, 0x0073
     3dc:	90 91 74 00 	lds	r25, 0x0074
     3e0:	01 96       	adiw	r24, 0x01	; 1
     3e2:	90 93 74 00 	sts	0x0074, r25
     3e6:	80 93 73 00 	sts	0x0073, r24
		xPassedTicks--;
     3ea:	80 91 77 00 	lds	r24, 0x0077
     3ee:	90 91 78 00 	lds	r25, 0x0078
     3f2:	01 97       	sbiw	r24, 0x01	; 1
     3f4:	90 93 78 00 	sts	0x0078, r25
     3f8:	80 93 77 00 	sts	0x0077, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     3fc:	80 91 73 00 	lds	r24, 0x0073
     400:	90 91 74 00 	lds	r25, 0x0074
     404:	00 97       	sbiw	r24, 0x00	; 0
     406:	09 f0       	breq	.+2      	; 0x40a <prvCheckDelayedList+0x58>
     408:	64 c0       	rjmp	.+200    	; 0x4d2 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     40a:	80 91 9d 00 	lds	r24, 0x009D
     40e:	90 91 9e 00 	lds	r25, 0x009E
     412:	9a 83       	std	Y+2, r25	; 0x02
     414:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     416:	80 91 9f 00 	lds	r24, 0x009F
     41a:	90 91 a0 00 	lds	r25, 0x00A0
     41e:	90 93 9e 00 	sts	0x009E, r25
     422:	80 93 9d 00 	sts	0x009D, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     426:	89 81       	ldd	r24, Y+1	; 0x01
     428:	9a 81       	ldd	r25, Y+2	; 0x02
     42a:	90 93 a0 00 	sts	0x00A0, r25
     42e:	80 93 9f 00 	sts	0x009F, r24
     432:	4f c0       	rjmp	.+158    	; 0x4d2 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     434:	e0 91 9d 00 	lds	r30, 0x009D
     438:	f0 91 9e 00 	lds	r31, 0x009E
     43c:	05 80       	ldd	r0, Z+5	; 0x05
     43e:	f6 81       	ldd	r31, Z+6	; 0x06
     440:	e0 2d       	mov	r30, r0
     442:	86 81       	ldd	r24, Z+6	; 0x06
     444:	97 81       	ldd	r25, Z+7	; 0x07
     446:	9c 83       	std	Y+4, r25	; 0x04
     448:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     44a:	eb 81       	ldd	r30, Y+3	; 0x03
     44c:	fc 81       	ldd	r31, Y+4	; 0x04
     44e:	22 81       	ldd	r18, Z+2	; 0x02
     450:	33 81       	ldd	r19, Z+3	; 0x03
     452:	80 91 73 00 	lds	r24, 0x0073
     456:	90 91 74 00 	lds	r25, 0x0074
     45a:	82 17       	cp	r24, r18
     45c:	93 07       	cpc	r25, r19
     45e:	08 f4       	brcc	.+2      	; 0x462 <prvCheckDelayedList+0xb0>
     460:	40 c0       	rjmp	.+128    	; 0x4e2 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     462:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     464:	8b 81       	ldd	r24, Y+3	; 0x03
     466:	9c 81       	ldd	r25, Y+4	; 0x04
     468:	02 96       	adiw	r24, 0x02	; 2
     46a:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     46e:	eb 81       	ldd	r30, Y+3	; 0x03
     470:	fc 81       	ldd	r31, Y+4	; 0x04
     472:	84 89       	ldd	r24, Z+20	; 0x14
     474:	95 89       	ldd	r25, Z+21	; 0x15
     476:	00 97       	sbiw	r24, 0x00	; 0
     478:	29 f0       	breq	.+10     	; 0x484 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     47a:	8b 81       	ldd	r24, Y+3	; 0x03
     47c:	9c 81       	ldd	r25, Y+4	; 0x04
     47e:	0c 96       	adiw	r24, 0x0c	; 12
     480:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     484:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     486:	eb 81       	ldd	r30, Y+3	; 0x03
     488:	fc 81       	ldd	r31, Y+4	; 0x04
     48a:	96 89       	ldd	r25, Z+22	; 0x16
     48c:	80 91 72 00 	lds	r24, 0x0072
     490:	89 17       	cp	r24, r25
     492:	28 f4       	brcc	.+10     	; 0x49e <prvCheckDelayedList+0xec>
     494:	eb 81       	ldd	r30, Y+3	; 0x03
     496:	fc 81       	ldd	r31, Y+4	; 0x04
     498:	86 89       	ldd	r24, Z+22	; 0x16
     49a:	80 93 72 00 	sts	0x0072, r24
     49e:	eb 81       	ldd	r30, Y+3	; 0x03
     4a0:	fc 81       	ldd	r31, Y+4	; 0x04
     4a2:	86 89       	ldd	r24, Z+22	; 0x16
     4a4:	28 2f       	mov	r18, r24
     4a6:	30 e0       	ldi	r19, 0x00	; 0
     4a8:	c9 01       	movw	r24, r18
     4aa:	88 0f       	add	r24, r24
     4ac:	99 1f       	adc	r25, r25
     4ae:	88 0f       	add	r24, r24
     4b0:	99 1f       	adc	r25, r25
     4b2:	88 0f       	add	r24, r24
     4b4:	99 1f       	adc	r25, r25
     4b6:	82 0f       	add	r24, r18
     4b8:	93 1f       	adc	r25, r19
     4ba:	ac 01       	movw	r20, r24
     4bc:	47 58       	subi	r20, 0x87	; 135
     4be:	5f 4f       	sbci	r21, 0xFF	; 255
     4c0:	8b 81       	ldd	r24, Y+3	; 0x03
     4c2:	9c 81       	ldd	r25, Y+4	; 0x04
     4c4:	9c 01       	movw	r18, r24
     4c6:	2e 5f       	subi	r18, 0xFE	; 254
     4c8:	3f 4f       	sbci	r19, 0xFF	; 255
     4ca:	ca 01       	movw	r24, r20
     4cc:	b9 01       	movw	r22, r18
     4ce:	0e 94 18 04 	call	0x830	; 0x830 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     4d2:	e0 91 9d 00 	lds	r30, 0x009D
     4d6:	f0 91 9e 00 	lds	r31, 0x009E
     4da:	80 81       	ld	r24, Z
     4dc:	88 23       	and	r24, r24
     4de:	09 f0       	breq	.+2      	; 0x4e2 <prvCheckDelayedList+0x130>
     4e0:	a9 cf       	rjmp	.-174    	; 0x434 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     4e2:	80 91 77 00 	lds	r24, 0x0077
     4e6:	90 91 78 00 	lds	r25, 0x0078
     4ea:	00 97       	sbiw	r24, 0x00	; 0
     4ec:	09 f0       	breq	.+2      	; 0x4f0 <prvCheckDelayedList+0x13e>
     4ee:	74 cf       	rjmp	.-280    	; 0x3d8 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     4f0:	80 91 73 00 	lds	r24, 0x0073
     4f4:	90 91 74 00 	lds	r25, 0x0074
     4f8:	90 93 76 00 	sts	0x0076, r25
     4fc:	80 93 75 00 	sts	0x0075, r24
}
     500:	0f 90       	pop	r0
     502:	0f 90       	pop	r0
     504:	0f 90       	pop	r0
     506:	0f 90       	pop	r0
     508:	cf 91       	pop	r28
     50a:	df 91       	pop	r29
     50c:	08 95       	ret

0000050e <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     50e:	df 93       	push	r29
     510:	cf 93       	push	r28
     512:	00 d0       	rcall	.+0      	; 0x514 <vCoRoutineSchedule+0x6>
     514:	cd b7       	in	r28, 0x3d	; 61
     516:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     518:	0e 94 8f 01 	call	0x31e	; 0x31e <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     51c:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <prvCheckDelayedList>
     520:	0a c0       	rjmp	.+20     	; 0x536 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     522:	80 91 72 00 	lds	r24, 0x0072
     526:	88 23       	and	r24, r24
     528:	09 f4       	brne	.+2      	; 0x52c <vCoRoutineSchedule+0x1e>
     52a:	66 c0       	rjmp	.+204    	; 0x5f8 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     52c:	80 91 72 00 	lds	r24, 0x0072
     530:	81 50       	subi	r24, 0x01	; 1
     532:	80 93 72 00 	sts	0x0072, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     536:	80 91 72 00 	lds	r24, 0x0072
     53a:	28 2f       	mov	r18, r24
     53c:	30 e0       	ldi	r19, 0x00	; 0
     53e:	c9 01       	movw	r24, r18
     540:	88 0f       	add	r24, r24
     542:	99 1f       	adc	r25, r25
     544:	88 0f       	add	r24, r24
     546:	99 1f       	adc	r25, r25
     548:	88 0f       	add	r24, r24
     54a:	99 1f       	adc	r25, r25
     54c:	82 0f       	add	r24, r18
     54e:	93 1f       	adc	r25, r19
     550:	fc 01       	movw	r30, r24
     552:	e7 58       	subi	r30, 0x87	; 135
     554:	ff 4f       	sbci	r31, 0xFF	; 255
     556:	80 81       	ld	r24, Z
     558:	88 23       	and	r24, r24
     55a:	19 f3       	breq	.-58     	; 0x522 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     55c:	80 91 72 00 	lds	r24, 0x0072
     560:	28 2f       	mov	r18, r24
     562:	30 e0       	ldi	r19, 0x00	; 0
     564:	c9 01       	movw	r24, r18
     566:	88 0f       	add	r24, r24
     568:	99 1f       	adc	r25, r25
     56a:	88 0f       	add	r24, r24
     56c:	99 1f       	adc	r25, r25
     56e:	88 0f       	add	r24, r24
     570:	99 1f       	adc	r25, r25
     572:	82 0f       	add	r24, r18
     574:	93 1f       	adc	r25, r19
     576:	87 58       	subi	r24, 0x87	; 135
     578:	9f 4f       	sbci	r25, 0xFF	; 255
     57a:	9a 83       	std	Y+2, r25	; 0x02
     57c:	89 83       	std	Y+1, r24	; 0x01
     57e:	e9 81       	ldd	r30, Y+1	; 0x01
     580:	fa 81       	ldd	r31, Y+2	; 0x02
     582:	01 80       	ldd	r0, Z+1	; 0x01
     584:	f2 81       	ldd	r31, Z+2	; 0x02
     586:	e0 2d       	mov	r30, r0
     588:	82 81       	ldd	r24, Z+2	; 0x02
     58a:	93 81       	ldd	r25, Z+3	; 0x03
     58c:	e9 81       	ldd	r30, Y+1	; 0x01
     58e:	fa 81       	ldd	r31, Y+2	; 0x02
     590:	92 83       	std	Z+2, r25	; 0x02
     592:	81 83       	std	Z+1, r24	; 0x01
     594:	e9 81       	ldd	r30, Y+1	; 0x01
     596:	fa 81       	ldd	r31, Y+2	; 0x02
     598:	21 81       	ldd	r18, Z+1	; 0x01
     59a:	32 81       	ldd	r19, Z+2	; 0x02
     59c:	89 81       	ldd	r24, Y+1	; 0x01
     59e:	9a 81       	ldd	r25, Y+2	; 0x02
     5a0:	03 96       	adiw	r24, 0x03	; 3
     5a2:	28 17       	cp	r18, r24
     5a4:	39 07       	cpc	r19, r25
     5a6:	59 f4       	brne	.+22     	; 0x5be <vCoRoutineSchedule+0xb0>
     5a8:	e9 81       	ldd	r30, Y+1	; 0x01
     5aa:	fa 81       	ldd	r31, Y+2	; 0x02
     5ac:	01 80       	ldd	r0, Z+1	; 0x01
     5ae:	f2 81       	ldd	r31, Z+2	; 0x02
     5b0:	e0 2d       	mov	r30, r0
     5b2:	82 81       	ldd	r24, Z+2	; 0x02
     5b4:	93 81       	ldd	r25, Z+3	; 0x03
     5b6:	e9 81       	ldd	r30, Y+1	; 0x01
     5b8:	fa 81       	ldd	r31, Y+2	; 0x02
     5ba:	92 83       	std	Z+2, r25	; 0x02
     5bc:	81 83       	std	Z+1, r24	; 0x01
     5be:	e9 81       	ldd	r30, Y+1	; 0x01
     5c0:	fa 81       	ldd	r31, Y+2	; 0x02
     5c2:	01 80       	ldd	r0, Z+1	; 0x01
     5c4:	f2 81       	ldd	r31, Z+2	; 0x02
     5c6:	e0 2d       	mov	r30, r0
     5c8:	86 81       	ldd	r24, Z+6	; 0x06
     5ca:	97 81       	ldd	r25, Z+7	; 0x07
     5cc:	90 93 71 00 	sts	0x0071, r25
     5d0:	80 93 70 00 	sts	0x0070, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     5d4:	e0 91 70 00 	lds	r30, 0x0070
     5d8:	f0 91 71 00 	lds	r31, 0x0071
     5dc:	40 81       	ld	r20, Z
     5de:	51 81       	ldd	r21, Z+1	; 0x01
     5e0:	80 91 70 00 	lds	r24, 0x0070
     5e4:	90 91 71 00 	lds	r25, 0x0071
     5e8:	e0 91 70 00 	lds	r30, 0x0070
     5ec:	f0 91 71 00 	lds	r31, 0x0071
     5f0:	27 89       	ldd	r18, Z+23	; 0x17
     5f2:	62 2f       	mov	r22, r18
     5f4:	fa 01       	movw	r30, r20
     5f6:	09 95       	icall

	return;
}
     5f8:	0f 90       	pop	r0
     5fa:	0f 90       	pop	r0
     5fc:	cf 91       	pop	r28
     5fe:	df 91       	pop	r29
     600:	08 95       	ret

00000602 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     602:	df 93       	push	r29
     604:	cf 93       	push	r28
     606:	0f 92       	push	r0
     608:	cd b7       	in	r28, 0x3d	; 61
     60a:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     60c:	19 82       	std	Y+1, r1	; 0x01
     60e:	13 c0       	rjmp	.+38     	; 0x636 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     610:	89 81       	ldd	r24, Y+1	; 0x01
     612:	28 2f       	mov	r18, r24
     614:	30 e0       	ldi	r19, 0x00	; 0
     616:	c9 01       	movw	r24, r18
     618:	88 0f       	add	r24, r24
     61a:	99 1f       	adc	r25, r25
     61c:	88 0f       	add	r24, r24
     61e:	99 1f       	adc	r25, r25
     620:	88 0f       	add	r24, r24
     622:	99 1f       	adc	r25, r25
     624:	82 0f       	add	r24, r18
     626:	93 1f       	adc	r25, r19
     628:	87 58       	subi	r24, 0x87	; 135
     62a:	9f 4f       	sbci	r25, 0xFF	; 255
     62c:	0e 94 de 03 	call	0x7bc	; 0x7bc <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     630:	89 81       	ldd	r24, Y+1	; 0x01
     632:	8f 5f       	subi	r24, 0xFF	; 255
     634:	89 83       	std	Y+1, r24	; 0x01
     636:	89 81       	ldd	r24, Y+1	; 0x01
     638:	82 30       	cpi	r24, 0x02	; 2
     63a:	50 f3       	brcs	.-44     	; 0x610 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     63c:	8b e8       	ldi	r24, 0x8B	; 139
     63e:	90 e0       	ldi	r25, 0x00	; 0
     640:	0e 94 de 03 	call	0x7bc	; 0x7bc <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     644:	84 e9       	ldi	r24, 0x94	; 148
     646:	90 e0       	ldi	r25, 0x00	; 0
     648:	0e 94 de 03 	call	0x7bc	; 0x7bc <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     64c:	81 ea       	ldi	r24, 0xA1	; 161
     64e:	90 e0       	ldi	r25, 0x00	; 0
     650:	0e 94 de 03 	call	0x7bc	; 0x7bc <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     654:	8b e8       	ldi	r24, 0x8B	; 139
     656:	90 e0       	ldi	r25, 0x00	; 0
     658:	90 93 9e 00 	sts	0x009E, r25
     65c:	80 93 9d 00 	sts	0x009D, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     660:	84 e9       	ldi	r24, 0x94	; 148
     662:	90 e0       	ldi	r25, 0x00	; 0
     664:	90 93 a0 00 	sts	0x00A0, r25
     668:	80 93 9f 00 	sts	0x009F, r24
}
     66c:	0f 90       	pop	r0
     66e:	cf 91       	pop	r28
     670:	df 91       	pop	r29
     672:	08 95       	ret

00000674 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     674:	df 93       	push	r29
     676:	cf 93       	push	r28
     678:	00 d0       	rcall	.+0      	; 0x67a <xCoRoutineRemoveFromEventList+0x6>
     67a:	00 d0       	rcall	.+0      	; 0x67c <xCoRoutineRemoveFromEventList+0x8>
     67c:	0f 92       	push	r0
     67e:	cd b7       	in	r28, 0x3d	; 61
     680:	de b7       	in	r29, 0x3e	; 62
     682:	9d 83       	std	Y+5, r25	; 0x05
     684:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     686:	ec 81       	ldd	r30, Y+4	; 0x04
     688:	fd 81       	ldd	r31, Y+5	; 0x05
     68a:	05 80       	ldd	r0, Z+5	; 0x05
     68c:	f6 81       	ldd	r31, Z+6	; 0x06
     68e:	e0 2d       	mov	r30, r0
     690:	86 81       	ldd	r24, Z+6	; 0x06
     692:	97 81       	ldd	r25, Z+7	; 0x07
     694:	9b 83       	std	Y+3, r25	; 0x03
     696:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     698:	8a 81       	ldd	r24, Y+2	; 0x02
     69a:	9b 81       	ldd	r25, Y+3	; 0x03
     69c:	0c 96       	adiw	r24, 0x0c	; 12
     69e:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     6a2:	8a 81       	ldd	r24, Y+2	; 0x02
     6a4:	9b 81       	ldd	r25, Y+3	; 0x03
     6a6:	9c 01       	movw	r18, r24
     6a8:	24 5f       	subi	r18, 0xF4	; 244
     6aa:	3f 4f       	sbci	r19, 0xFF	; 255
     6ac:	81 ea       	ldi	r24, 0xA1	; 161
     6ae:	90 e0       	ldi	r25, 0x00	; 0
     6b0:	b9 01       	movw	r22, r18
     6b2:	0e 94 18 04 	call	0x830	; 0x830 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     6b6:	ea 81       	ldd	r30, Y+2	; 0x02
     6b8:	fb 81       	ldd	r31, Y+3	; 0x03
     6ba:	96 89       	ldd	r25, Z+22	; 0x16
     6bc:	e0 91 70 00 	lds	r30, 0x0070
     6c0:	f0 91 71 00 	lds	r31, 0x0071
     6c4:	86 89       	ldd	r24, Z+22	; 0x16
     6c6:	98 17       	cp	r25, r24
     6c8:	18 f0       	brcs	.+6      	; 0x6d0 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
     6ca:	81 e0       	ldi	r24, 0x01	; 1
     6cc:	89 83       	std	Y+1, r24	; 0x01
     6ce:	01 c0       	rjmp	.+2      	; 0x6d2 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
     6d0:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
     6d2:	89 81       	ldd	r24, Y+1	; 0x01
}
     6d4:	0f 90       	pop	r0
     6d6:	0f 90       	pop	r0
     6d8:	0f 90       	pop	r0
     6da:	0f 90       	pop	r0
     6dc:	0f 90       	pop	r0
     6de:	cf 91       	pop	r28
     6e0:	df 91       	pop	r29
     6e2:	08 95       	ret

000006e4 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     6e4:	df 93       	push	r29
     6e6:	cf 93       	push	r28
     6e8:	00 d0       	rcall	.+0      	; 0x6ea <pvPortMalloc+0x6>
     6ea:	00 d0       	rcall	.+0      	; 0x6ec <pvPortMalloc+0x8>
     6ec:	cd b7       	in	r28, 0x3d	; 61
     6ee:	de b7       	in	r29, 0x3e	; 62
     6f0:	9c 83       	std	Y+4, r25	; 0x04
     6f2:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
     6f4:	1a 82       	std	Y+2, r1	; 0x02
     6f6:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     6f8:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     6fc:	80 91 aa 00 	lds	r24, 0x00AA
     700:	90 91 ab 00 	lds	r25, 0x00AB
     704:	2b 81       	ldd	r18, Y+3	; 0x03
     706:	3c 81       	ldd	r19, Y+4	; 0x04
     708:	82 0f       	add	r24, r18
     70a:	93 1f       	adc	r25, r19
     70c:	22 e0       	ldi	r18, 0x02	; 2
     70e:	88 35       	cpi	r24, 0x58	; 88
     710:	92 07       	cpc	r25, r18
     712:	18 f5       	brcc	.+70     	; 0x75a <pvPortMalloc+0x76>
     714:	20 91 aa 00 	lds	r18, 0x00AA
     718:	30 91 ab 00 	lds	r19, 0x00AB
     71c:	8b 81       	ldd	r24, Y+3	; 0x03
     71e:	9c 81       	ldd	r25, Y+4	; 0x04
     720:	28 0f       	add	r18, r24
     722:	39 1f       	adc	r19, r25
     724:	80 91 aa 00 	lds	r24, 0x00AA
     728:	90 91 ab 00 	lds	r25, 0x00AB
     72c:	82 17       	cp	r24, r18
     72e:	93 07       	cpc	r25, r19
     730:	a0 f4       	brcc	.+40     	; 0x75a <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     732:	80 91 aa 00 	lds	r24, 0x00AA
     736:	90 91 ab 00 	lds	r25, 0x00AB
     73a:	84 55       	subi	r24, 0x54	; 84
     73c:	9f 4f       	sbci	r25, 0xFF	; 255
     73e:	9a 83       	std	Y+2, r25	; 0x02
     740:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
     742:	20 91 aa 00 	lds	r18, 0x00AA
     746:	30 91 ab 00 	lds	r19, 0x00AB
     74a:	8b 81       	ldd	r24, Y+3	; 0x03
     74c:	9c 81       	ldd	r25, Y+4	; 0x04
     74e:	82 0f       	add	r24, r18
     750:	93 1f       	adc	r25, r19
     752:	90 93 ab 00 	sts	0x00AB, r25
     756:	80 93 aa 00 	sts	0x00AA, r24
		}	
	}
	xTaskResumeAll();
     75a:	0e 94 b4 0e 	call	0x1d68	; 0x1d68 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
     75e:	89 81       	ldd	r24, Y+1	; 0x01
     760:	9a 81       	ldd	r25, Y+2	; 0x02
}
     762:	0f 90       	pop	r0
     764:	0f 90       	pop	r0
     766:	0f 90       	pop	r0
     768:	0f 90       	pop	r0
     76a:	cf 91       	pop	r28
     76c:	df 91       	pop	r29
     76e:	08 95       	ret

00000770 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     770:	df 93       	push	r29
     772:	cf 93       	push	r28
     774:	00 d0       	rcall	.+0      	; 0x776 <vPortFree+0x6>
     776:	cd b7       	in	r28, 0x3d	; 61
     778:	de b7       	in	r29, 0x3e	; 62
     77a:	9a 83       	std	Y+2, r25	; 0x02
     77c:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     77e:	0f 90       	pop	r0
     780:	0f 90       	pop	r0
     782:	cf 91       	pop	r28
     784:	df 91       	pop	r29
     786:	08 95       	ret

00000788 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     788:	df 93       	push	r29
     78a:	cf 93       	push	r28
     78c:	cd b7       	in	r28, 0x3d	; 61
     78e:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     790:	10 92 ab 00 	sts	0x00AB, r1
     794:	10 92 aa 00 	sts	0x00AA, r1
}
     798:	cf 91       	pop	r28
     79a:	df 91       	pop	r29
     79c:	08 95       	ret

0000079e <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     79e:	df 93       	push	r29
     7a0:	cf 93       	push	r28
     7a2:	cd b7       	in	r28, 0x3d	; 61
     7a4:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     7a6:	20 91 aa 00 	lds	r18, 0x00AA
     7aa:	30 91 ab 00 	lds	r19, 0x00AB
     7ae:	88 e5       	ldi	r24, 0x58	; 88
     7b0:	92 e0       	ldi	r25, 0x02	; 2
     7b2:	82 1b       	sub	r24, r18
     7b4:	93 0b       	sbc	r25, r19
}
     7b6:	cf 91       	pop	r28
     7b8:	df 91       	pop	r29
     7ba:	08 95       	ret

000007bc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     7bc:	df 93       	push	r29
     7be:	cf 93       	push	r28
     7c0:	00 d0       	rcall	.+0      	; 0x7c2 <vListInitialise+0x6>
     7c2:	cd b7       	in	r28, 0x3d	; 61
     7c4:	de b7       	in	r29, 0x3e	; 62
     7c6:	9a 83       	std	Y+2, r25	; 0x02
     7c8:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     7ca:	89 81       	ldd	r24, Y+1	; 0x01
     7cc:	9a 81       	ldd	r25, Y+2	; 0x02
     7ce:	03 96       	adiw	r24, 0x03	; 3
     7d0:	e9 81       	ldd	r30, Y+1	; 0x01
     7d2:	fa 81       	ldd	r31, Y+2	; 0x02
     7d4:	92 83       	std	Z+2, r25	; 0x02
     7d6:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     7d8:	e9 81       	ldd	r30, Y+1	; 0x01
     7da:	fa 81       	ldd	r31, Y+2	; 0x02
     7dc:	8f ef       	ldi	r24, 0xFF	; 255
     7de:	9f ef       	ldi	r25, 0xFF	; 255
     7e0:	94 83       	std	Z+4, r25	; 0x04
     7e2:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     7e4:	89 81       	ldd	r24, Y+1	; 0x01
     7e6:	9a 81       	ldd	r25, Y+2	; 0x02
     7e8:	03 96       	adiw	r24, 0x03	; 3
     7ea:	e9 81       	ldd	r30, Y+1	; 0x01
     7ec:	fa 81       	ldd	r31, Y+2	; 0x02
     7ee:	96 83       	std	Z+6, r25	; 0x06
     7f0:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     7f2:	89 81       	ldd	r24, Y+1	; 0x01
     7f4:	9a 81       	ldd	r25, Y+2	; 0x02
     7f6:	03 96       	adiw	r24, 0x03	; 3
     7f8:	e9 81       	ldd	r30, Y+1	; 0x01
     7fa:	fa 81       	ldd	r31, Y+2	; 0x02
     7fc:	90 87       	std	Z+8, r25	; 0x08
     7fe:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     800:	e9 81       	ldd	r30, Y+1	; 0x01
     802:	fa 81       	ldd	r31, Y+2	; 0x02
     804:	10 82       	st	Z, r1
}
     806:	0f 90       	pop	r0
     808:	0f 90       	pop	r0
     80a:	cf 91       	pop	r28
     80c:	df 91       	pop	r29
     80e:	08 95       	ret

00000810 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
     810:	df 93       	push	r29
     812:	cf 93       	push	r28
     814:	00 d0       	rcall	.+0      	; 0x816 <vListInitialiseItem+0x6>
     816:	cd b7       	in	r28, 0x3d	; 61
     818:	de b7       	in	r29, 0x3e	; 62
     81a:	9a 83       	std	Y+2, r25	; 0x02
     81c:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     81e:	e9 81       	ldd	r30, Y+1	; 0x01
     820:	fa 81       	ldd	r31, Y+2	; 0x02
     822:	11 86       	std	Z+9, r1	; 0x09
     824:	10 86       	std	Z+8, r1	; 0x08
}
     826:	0f 90       	pop	r0
     828:	0f 90       	pop	r0
     82a:	cf 91       	pop	r28
     82c:	df 91       	pop	r29
     82e:	08 95       	ret

00000830 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     830:	df 93       	push	r29
     832:	cf 93       	push	r28
     834:	00 d0       	rcall	.+0      	; 0x836 <vListInsertEnd+0x6>
     836:	00 d0       	rcall	.+0      	; 0x838 <vListInsertEnd+0x8>
     838:	00 d0       	rcall	.+0      	; 0x83a <vListInsertEnd+0xa>
     83a:	cd b7       	in	r28, 0x3d	; 61
     83c:	de b7       	in	r29, 0x3e	; 62
     83e:	9c 83       	std	Y+4, r25	; 0x04
     840:	8b 83       	std	Y+3, r24	; 0x03
     842:	7e 83       	std	Y+6, r23	; 0x06
     844:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     846:	eb 81       	ldd	r30, Y+3	; 0x03
     848:	fc 81       	ldd	r31, Y+4	; 0x04
     84a:	81 81       	ldd	r24, Z+1	; 0x01
     84c:	92 81       	ldd	r25, Z+2	; 0x02
     84e:	9a 83       	std	Y+2, r25	; 0x02
     850:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
     852:	e9 81       	ldd	r30, Y+1	; 0x01
     854:	fa 81       	ldd	r31, Y+2	; 0x02
     856:	82 81       	ldd	r24, Z+2	; 0x02
     858:	93 81       	ldd	r25, Z+3	; 0x03
     85a:	ed 81       	ldd	r30, Y+5	; 0x05
     85c:	fe 81       	ldd	r31, Y+6	; 0x06
     85e:	93 83       	std	Z+3, r25	; 0x03
     860:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     862:	eb 81       	ldd	r30, Y+3	; 0x03
     864:	fc 81       	ldd	r31, Y+4	; 0x04
     866:	81 81       	ldd	r24, Z+1	; 0x01
     868:	92 81       	ldd	r25, Z+2	; 0x02
     86a:	ed 81       	ldd	r30, Y+5	; 0x05
     86c:	fe 81       	ldd	r31, Y+6	; 0x06
     86e:	95 83       	std	Z+5, r25	; 0x05
     870:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     872:	e9 81       	ldd	r30, Y+1	; 0x01
     874:	fa 81       	ldd	r31, Y+2	; 0x02
     876:	02 80       	ldd	r0, Z+2	; 0x02
     878:	f3 81       	ldd	r31, Z+3	; 0x03
     87a:	e0 2d       	mov	r30, r0
     87c:	8d 81       	ldd	r24, Y+5	; 0x05
     87e:	9e 81       	ldd	r25, Y+6	; 0x06
     880:	95 83       	std	Z+5, r25	; 0x05
     882:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     884:	8d 81       	ldd	r24, Y+5	; 0x05
     886:	9e 81       	ldd	r25, Y+6	; 0x06
     888:	e9 81       	ldd	r30, Y+1	; 0x01
     88a:	fa 81       	ldd	r31, Y+2	; 0x02
     88c:	93 83       	std	Z+3, r25	; 0x03
     88e:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     890:	8d 81       	ldd	r24, Y+5	; 0x05
     892:	9e 81       	ldd	r25, Y+6	; 0x06
     894:	eb 81       	ldd	r30, Y+3	; 0x03
     896:	fc 81       	ldd	r31, Y+4	; 0x04
     898:	92 83       	std	Z+2, r25	; 0x02
     89a:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     89c:	ed 81       	ldd	r30, Y+5	; 0x05
     89e:	fe 81       	ldd	r31, Y+6	; 0x06
     8a0:	8b 81       	ldd	r24, Y+3	; 0x03
     8a2:	9c 81       	ldd	r25, Y+4	; 0x04
     8a4:	91 87       	std	Z+9, r25	; 0x09
     8a6:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     8a8:	eb 81       	ldd	r30, Y+3	; 0x03
     8aa:	fc 81       	ldd	r31, Y+4	; 0x04
     8ac:	80 81       	ld	r24, Z
     8ae:	8f 5f       	subi	r24, 0xFF	; 255
     8b0:	eb 81       	ldd	r30, Y+3	; 0x03
     8b2:	fc 81       	ldd	r31, Y+4	; 0x04
     8b4:	80 83       	st	Z, r24
}
     8b6:	26 96       	adiw	r28, 0x06	; 6
     8b8:	0f b6       	in	r0, 0x3f	; 63
     8ba:	f8 94       	cli
     8bc:	de bf       	out	0x3e, r29	; 62
     8be:	0f be       	out	0x3f, r0	; 63
     8c0:	cd bf       	out	0x3d, r28	; 61
     8c2:	cf 91       	pop	r28
     8c4:	df 91       	pop	r29
     8c6:	08 95       	ret

000008c8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     8c8:	df 93       	push	r29
     8ca:	cf 93       	push	r28
     8cc:	cd b7       	in	r28, 0x3d	; 61
     8ce:	de b7       	in	r29, 0x3e	; 62
     8d0:	28 97       	sbiw	r28, 0x08	; 8
     8d2:	0f b6       	in	r0, 0x3f	; 63
     8d4:	f8 94       	cli
     8d6:	de bf       	out	0x3e, r29	; 62
     8d8:	0f be       	out	0x3f, r0	; 63
     8da:	cd bf       	out	0x3d, r28	; 61
     8dc:	9e 83       	std	Y+6, r25	; 0x06
     8de:	8d 83       	std	Y+5, r24	; 0x05
     8e0:	78 87       	std	Y+8, r23	; 0x08
     8e2:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     8e4:	ef 81       	ldd	r30, Y+7	; 0x07
     8e6:	f8 85       	ldd	r31, Y+8	; 0x08
     8e8:	80 81       	ld	r24, Z
     8ea:	91 81       	ldd	r25, Z+1	; 0x01
     8ec:	9a 83       	std	Y+2, r25	; 0x02
     8ee:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     8f0:	89 81       	ldd	r24, Y+1	; 0x01
     8f2:	9a 81       	ldd	r25, Y+2	; 0x02
     8f4:	2f ef       	ldi	r18, 0xFF	; 255
     8f6:	8f 3f       	cpi	r24, 0xFF	; 255
     8f8:	92 07       	cpc	r25, r18
     8fa:	39 f4       	brne	.+14     	; 0x90a <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     8fc:	ed 81       	ldd	r30, Y+5	; 0x05
     8fe:	fe 81       	ldd	r31, Y+6	; 0x06
     900:	87 81       	ldd	r24, Z+7	; 0x07
     902:	90 85       	ldd	r25, Z+8	; 0x08
     904:	9c 83       	std	Y+4, r25	; 0x04
     906:	8b 83       	std	Y+3, r24	; 0x03
     908:	18 c0       	rjmp	.+48     	; 0x93a <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     90a:	8d 81       	ldd	r24, Y+5	; 0x05
     90c:	9e 81       	ldd	r25, Y+6	; 0x06
     90e:	03 96       	adiw	r24, 0x03	; 3
     910:	9c 83       	std	Y+4, r25	; 0x04
     912:	8b 83       	std	Y+3, r24	; 0x03
     914:	06 c0       	rjmp	.+12     	; 0x922 <vListInsert+0x5a>
     916:	eb 81       	ldd	r30, Y+3	; 0x03
     918:	fc 81       	ldd	r31, Y+4	; 0x04
     91a:	82 81       	ldd	r24, Z+2	; 0x02
     91c:	93 81       	ldd	r25, Z+3	; 0x03
     91e:	9c 83       	std	Y+4, r25	; 0x04
     920:	8b 83       	std	Y+3, r24	; 0x03
     922:	eb 81       	ldd	r30, Y+3	; 0x03
     924:	fc 81       	ldd	r31, Y+4	; 0x04
     926:	02 80       	ldd	r0, Z+2	; 0x02
     928:	f3 81       	ldd	r31, Z+3	; 0x03
     92a:	e0 2d       	mov	r30, r0
     92c:	20 81       	ld	r18, Z
     92e:	31 81       	ldd	r19, Z+1	; 0x01
     930:	89 81       	ldd	r24, Y+1	; 0x01
     932:	9a 81       	ldd	r25, Y+2	; 0x02
     934:	82 17       	cp	r24, r18
     936:	93 07       	cpc	r25, r19
     938:	70 f7       	brcc	.-36     	; 0x916 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     93a:	eb 81       	ldd	r30, Y+3	; 0x03
     93c:	fc 81       	ldd	r31, Y+4	; 0x04
     93e:	82 81       	ldd	r24, Z+2	; 0x02
     940:	93 81       	ldd	r25, Z+3	; 0x03
     942:	ef 81       	ldd	r30, Y+7	; 0x07
     944:	f8 85       	ldd	r31, Y+8	; 0x08
     946:	93 83       	std	Z+3, r25	; 0x03
     948:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     94a:	ef 81       	ldd	r30, Y+7	; 0x07
     94c:	f8 85       	ldd	r31, Y+8	; 0x08
     94e:	02 80       	ldd	r0, Z+2	; 0x02
     950:	f3 81       	ldd	r31, Z+3	; 0x03
     952:	e0 2d       	mov	r30, r0
     954:	8f 81       	ldd	r24, Y+7	; 0x07
     956:	98 85       	ldd	r25, Y+8	; 0x08
     958:	95 83       	std	Z+5, r25	; 0x05
     95a:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     95c:	ef 81       	ldd	r30, Y+7	; 0x07
     95e:	f8 85       	ldd	r31, Y+8	; 0x08
     960:	8b 81       	ldd	r24, Y+3	; 0x03
     962:	9c 81       	ldd	r25, Y+4	; 0x04
     964:	95 83       	std	Z+5, r25	; 0x05
     966:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     968:	8f 81       	ldd	r24, Y+7	; 0x07
     96a:	98 85       	ldd	r25, Y+8	; 0x08
     96c:	eb 81       	ldd	r30, Y+3	; 0x03
     96e:	fc 81       	ldd	r31, Y+4	; 0x04
     970:	93 83       	std	Z+3, r25	; 0x03
     972:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     974:	ef 81       	ldd	r30, Y+7	; 0x07
     976:	f8 85       	ldd	r31, Y+8	; 0x08
     978:	8d 81       	ldd	r24, Y+5	; 0x05
     97a:	9e 81       	ldd	r25, Y+6	; 0x06
     97c:	91 87       	std	Z+9, r25	; 0x09
     97e:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     980:	ed 81       	ldd	r30, Y+5	; 0x05
     982:	fe 81       	ldd	r31, Y+6	; 0x06
     984:	80 81       	ld	r24, Z
     986:	8f 5f       	subi	r24, 0xFF	; 255
     988:	ed 81       	ldd	r30, Y+5	; 0x05
     98a:	fe 81       	ldd	r31, Y+6	; 0x06
     98c:	80 83       	st	Z, r24
}
     98e:	28 96       	adiw	r28, 0x08	; 8
     990:	0f b6       	in	r0, 0x3f	; 63
     992:	f8 94       	cli
     994:	de bf       	out	0x3e, r29	; 62
     996:	0f be       	out	0x3f, r0	; 63
     998:	cd bf       	out	0x3d, r28	; 61
     99a:	cf 91       	pop	r28
     99c:	df 91       	pop	r29
     99e:	08 95       	ret

000009a0 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     9a0:	df 93       	push	r29
     9a2:	cf 93       	push	r28
     9a4:	00 d0       	rcall	.+0      	; 0x9a6 <vListRemove+0x6>
     9a6:	00 d0       	rcall	.+0      	; 0x9a8 <vListRemove+0x8>
     9a8:	cd b7       	in	r28, 0x3d	; 61
     9aa:	de b7       	in	r29, 0x3e	; 62
     9ac:	9c 83       	std	Y+4, r25	; 0x04
     9ae:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     9b0:	eb 81       	ldd	r30, Y+3	; 0x03
     9b2:	fc 81       	ldd	r31, Y+4	; 0x04
     9b4:	a2 81       	ldd	r26, Z+2	; 0x02
     9b6:	b3 81       	ldd	r27, Z+3	; 0x03
     9b8:	eb 81       	ldd	r30, Y+3	; 0x03
     9ba:	fc 81       	ldd	r31, Y+4	; 0x04
     9bc:	84 81       	ldd	r24, Z+4	; 0x04
     9be:	95 81       	ldd	r25, Z+5	; 0x05
     9c0:	15 96       	adiw	r26, 0x05	; 5
     9c2:	9c 93       	st	X, r25
     9c4:	8e 93       	st	-X, r24
     9c6:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     9c8:	eb 81       	ldd	r30, Y+3	; 0x03
     9ca:	fc 81       	ldd	r31, Y+4	; 0x04
     9cc:	a4 81       	ldd	r26, Z+4	; 0x04
     9ce:	b5 81       	ldd	r27, Z+5	; 0x05
     9d0:	eb 81       	ldd	r30, Y+3	; 0x03
     9d2:	fc 81       	ldd	r31, Y+4	; 0x04
     9d4:	82 81       	ldd	r24, Z+2	; 0x02
     9d6:	93 81       	ldd	r25, Z+3	; 0x03
     9d8:	13 96       	adiw	r26, 0x03	; 3
     9da:	9c 93       	st	X, r25
     9dc:	8e 93       	st	-X, r24
     9de:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     9e0:	eb 81       	ldd	r30, Y+3	; 0x03
     9e2:	fc 81       	ldd	r31, Y+4	; 0x04
     9e4:	80 85       	ldd	r24, Z+8	; 0x08
     9e6:	91 85       	ldd	r25, Z+9	; 0x09
     9e8:	9a 83       	std	Y+2, r25	; 0x02
     9ea:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     9ec:	e9 81       	ldd	r30, Y+1	; 0x01
     9ee:	fa 81       	ldd	r31, Y+2	; 0x02
     9f0:	21 81       	ldd	r18, Z+1	; 0x01
     9f2:	32 81       	ldd	r19, Z+2	; 0x02
     9f4:	8b 81       	ldd	r24, Y+3	; 0x03
     9f6:	9c 81       	ldd	r25, Y+4	; 0x04
     9f8:	28 17       	cp	r18, r24
     9fa:	39 07       	cpc	r19, r25
     9fc:	41 f4       	brne	.+16     	; 0xa0e <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     9fe:	eb 81       	ldd	r30, Y+3	; 0x03
     a00:	fc 81       	ldd	r31, Y+4	; 0x04
     a02:	84 81       	ldd	r24, Z+4	; 0x04
     a04:	95 81       	ldd	r25, Z+5	; 0x05
     a06:	e9 81       	ldd	r30, Y+1	; 0x01
     a08:	fa 81       	ldd	r31, Y+2	; 0x02
     a0a:	92 83       	std	Z+2, r25	; 0x02
     a0c:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
     a0e:	eb 81       	ldd	r30, Y+3	; 0x03
     a10:	fc 81       	ldd	r31, Y+4	; 0x04
     a12:	11 86       	std	Z+9, r1	; 0x09
     a14:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     a16:	e9 81       	ldd	r30, Y+1	; 0x01
     a18:	fa 81       	ldd	r31, Y+2	; 0x02
     a1a:	80 81       	ld	r24, Z
     a1c:	81 50       	subi	r24, 0x01	; 1
     a1e:	e9 81       	ldd	r30, Y+1	; 0x01
     a20:	fa 81       	ldd	r31, Y+2	; 0x02
     a22:	80 83       	st	Z, r24
}
     a24:	0f 90       	pop	r0
     a26:	0f 90       	pop	r0
     a28:	0f 90       	pop	r0
     a2a:	0f 90       	pop	r0
     a2c:	cf 91       	pop	r28
     a2e:	df 91       	pop	r29
     a30:	08 95       	ret

00000a32 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
     a32:	df 93       	push	r29
     a34:	cf 93       	push	r28
     a36:	cd b7       	in	r28, 0x3d	; 61
     a38:	de b7       	in	r29, 0x3e	; 62
     a3a:	28 97       	sbiw	r28, 0x08	; 8
     a3c:	0f b6       	in	r0, 0x3f	; 63
     a3e:	f8 94       	cli
     a40:	de bf       	out	0x3e, r29	; 62
     a42:	0f be       	out	0x3f, r0	; 63
     a44:	cd bf       	out	0x3d, r28	; 61
     a46:	9c 83       	std	Y+4, r25	; 0x04
     a48:	8b 83       	std	Y+3, r24	; 0x03
     a4a:	7e 83       	std	Y+6, r23	; 0x06
     a4c:	6d 83       	std	Y+5, r22	; 0x05
     a4e:	58 87       	std	Y+8, r21	; 0x08
     a50:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     a52:	eb 81       	ldd	r30, Y+3	; 0x03
     a54:	fc 81       	ldd	r31, Y+4	; 0x04
     a56:	81 e1       	ldi	r24, 0x11	; 17
     a58:	80 83       	st	Z, r24
	pxTopOfStack--;
     a5a:	8b 81       	ldd	r24, Y+3	; 0x03
     a5c:	9c 81       	ldd	r25, Y+4	; 0x04
     a5e:	01 97       	sbiw	r24, 0x01	; 1
     a60:	9c 83       	std	Y+4, r25	; 0x04
     a62:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     a64:	eb 81       	ldd	r30, Y+3	; 0x03
     a66:	fc 81       	ldd	r31, Y+4	; 0x04
     a68:	82 e2       	ldi	r24, 0x22	; 34
     a6a:	80 83       	st	Z, r24
	pxTopOfStack--;
     a6c:	8b 81       	ldd	r24, Y+3	; 0x03
     a6e:	9c 81       	ldd	r25, Y+4	; 0x04
     a70:	01 97       	sbiw	r24, 0x01	; 1
     a72:	9c 83       	std	Y+4, r25	; 0x04
     a74:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     a76:	eb 81       	ldd	r30, Y+3	; 0x03
     a78:	fc 81       	ldd	r31, Y+4	; 0x04
     a7a:	83 e3       	ldi	r24, 0x33	; 51
     a7c:	80 83       	st	Z, r24
	pxTopOfStack--;
     a7e:	8b 81       	ldd	r24, Y+3	; 0x03
     a80:	9c 81       	ldd	r25, Y+4	; 0x04
     a82:	01 97       	sbiw	r24, 0x01	; 1
     a84:	9c 83       	std	Y+4, r25	; 0x04
     a86:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
     a88:	8d 81       	ldd	r24, Y+5	; 0x05
     a8a:	9e 81       	ldd	r25, Y+6	; 0x06
     a8c:	9a 83       	std	Y+2, r25	; 0x02
     a8e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     a90:	89 81       	ldd	r24, Y+1	; 0x01
     a92:	eb 81       	ldd	r30, Y+3	; 0x03
     a94:	fc 81       	ldd	r31, Y+4	; 0x04
     a96:	80 83       	st	Z, r24
	pxTopOfStack--;
     a98:	8b 81       	ldd	r24, Y+3	; 0x03
     a9a:	9c 81       	ldd	r25, Y+4	; 0x04
     a9c:	01 97       	sbiw	r24, 0x01	; 1
     a9e:	9c 83       	std	Y+4, r25	; 0x04
     aa0:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     aa2:	89 81       	ldd	r24, Y+1	; 0x01
     aa4:	9a 81       	ldd	r25, Y+2	; 0x02
     aa6:	89 2f       	mov	r24, r25
     aa8:	99 27       	eor	r25, r25
     aaa:	9a 83       	std	Y+2, r25	; 0x02
     aac:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     aae:	89 81       	ldd	r24, Y+1	; 0x01
     ab0:	eb 81       	ldd	r30, Y+3	; 0x03
     ab2:	fc 81       	ldd	r31, Y+4	; 0x04
     ab4:	80 83       	st	Z, r24
	pxTopOfStack--;
     ab6:	8b 81       	ldd	r24, Y+3	; 0x03
     ab8:	9c 81       	ldd	r25, Y+4	; 0x04
     aba:	01 97       	sbiw	r24, 0x01	; 1
     abc:	9c 83       	std	Y+4, r25	; 0x04
     abe:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     ac0:	eb 81       	ldd	r30, Y+3	; 0x03
     ac2:	fc 81       	ldd	r31, Y+4	; 0x04
     ac4:	10 82       	st	Z, r1
	pxTopOfStack--;
     ac6:	8b 81       	ldd	r24, Y+3	; 0x03
     ac8:	9c 81       	ldd	r25, Y+4	; 0x04
     aca:	01 97       	sbiw	r24, 0x01	; 1
     acc:	9c 83       	std	Y+4, r25	; 0x04
     ace:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     ad0:	eb 81       	ldd	r30, Y+3	; 0x03
     ad2:	fc 81       	ldd	r31, Y+4	; 0x04
     ad4:	80 e8       	ldi	r24, 0x80	; 128
     ad6:	80 83       	st	Z, r24
	pxTopOfStack--;
     ad8:	8b 81       	ldd	r24, Y+3	; 0x03
     ada:	9c 81       	ldd	r25, Y+4	; 0x04
     adc:	01 97       	sbiw	r24, 0x01	; 1
     ade:	9c 83       	std	Y+4, r25	; 0x04
     ae0:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     ae2:	eb 81       	ldd	r30, Y+3	; 0x03
     ae4:	fc 81       	ldd	r31, Y+4	; 0x04
     ae6:	10 82       	st	Z, r1
	pxTopOfStack--;
     ae8:	8b 81       	ldd	r24, Y+3	; 0x03
     aea:	9c 81       	ldd	r25, Y+4	; 0x04
     aec:	01 97       	sbiw	r24, 0x01	; 1
     aee:	9c 83       	std	Y+4, r25	; 0x04
     af0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     af2:	eb 81       	ldd	r30, Y+3	; 0x03
     af4:	fc 81       	ldd	r31, Y+4	; 0x04
     af6:	82 e0       	ldi	r24, 0x02	; 2
     af8:	80 83       	st	Z, r24
	pxTopOfStack--;
     afa:	8b 81       	ldd	r24, Y+3	; 0x03
     afc:	9c 81       	ldd	r25, Y+4	; 0x04
     afe:	01 97       	sbiw	r24, 0x01	; 1
     b00:	9c 83       	std	Y+4, r25	; 0x04
     b02:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     b04:	eb 81       	ldd	r30, Y+3	; 0x03
     b06:	fc 81       	ldd	r31, Y+4	; 0x04
     b08:	83 e0       	ldi	r24, 0x03	; 3
     b0a:	80 83       	st	Z, r24
	pxTopOfStack--;
     b0c:	8b 81       	ldd	r24, Y+3	; 0x03
     b0e:	9c 81       	ldd	r25, Y+4	; 0x04
     b10:	01 97       	sbiw	r24, 0x01	; 1
     b12:	9c 83       	std	Y+4, r25	; 0x04
     b14:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     b16:	eb 81       	ldd	r30, Y+3	; 0x03
     b18:	fc 81       	ldd	r31, Y+4	; 0x04
     b1a:	84 e0       	ldi	r24, 0x04	; 4
     b1c:	80 83       	st	Z, r24
	pxTopOfStack--;
     b1e:	8b 81       	ldd	r24, Y+3	; 0x03
     b20:	9c 81       	ldd	r25, Y+4	; 0x04
     b22:	01 97       	sbiw	r24, 0x01	; 1
     b24:	9c 83       	std	Y+4, r25	; 0x04
     b26:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     b28:	eb 81       	ldd	r30, Y+3	; 0x03
     b2a:	fc 81       	ldd	r31, Y+4	; 0x04
     b2c:	85 e0       	ldi	r24, 0x05	; 5
     b2e:	80 83       	st	Z, r24
	pxTopOfStack--;
     b30:	8b 81       	ldd	r24, Y+3	; 0x03
     b32:	9c 81       	ldd	r25, Y+4	; 0x04
     b34:	01 97       	sbiw	r24, 0x01	; 1
     b36:	9c 83       	std	Y+4, r25	; 0x04
     b38:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     b3a:	eb 81       	ldd	r30, Y+3	; 0x03
     b3c:	fc 81       	ldd	r31, Y+4	; 0x04
     b3e:	86 e0       	ldi	r24, 0x06	; 6
     b40:	80 83       	st	Z, r24
	pxTopOfStack--;
     b42:	8b 81       	ldd	r24, Y+3	; 0x03
     b44:	9c 81       	ldd	r25, Y+4	; 0x04
     b46:	01 97       	sbiw	r24, 0x01	; 1
     b48:	9c 83       	std	Y+4, r25	; 0x04
     b4a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     b4c:	eb 81       	ldd	r30, Y+3	; 0x03
     b4e:	fc 81       	ldd	r31, Y+4	; 0x04
     b50:	87 e0       	ldi	r24, 0x07	; 7
     b52:	80 83       	st	Z, r24
	pxTopOfStack--;
     b54:	8b 81       	ldd	r24, Y+3	; 0x03
     b56:	9c 81       	ldd	r25, Y+4	; 0x04
     b58:	01 97       	sbiw	r24, 0x01	; 1
     b5a:	9c 83       	std	Y+4, r25	; 0x04
     b5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     b5e:	eb 81       	ldd	r30, Y+3	; 0x03
     b60:	fc 81       	ldd	r31, Y+4	; 0x04
     b62:	88 e0       	ldi	r24, 0x08	; 8
     b64:	80 83       	st	Z, r24
	pxTopOfStack--;
     b66:	8b 81       	ldd	r24, Y+3	; 0x03
     b68:	9c 81       	ldd	r25, Y+4	; 0x04
     b6a:	01 97       	sbiw	r24, 0x01	; 1
     b6c:	9c 83       	std	Y+4, r25	; 0x04
     b6e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     b70:	eb 81       	ldd	r30, Y+3	; 0x03
     b72:	fc 81       	ldd	r31, Y+4	; 0x04
     b74:	89 e0       	ldi	r24, 0x09	; 9
     b76:	80 83       	st	Z, r24
	pxTopOfStack--;
     b78:	8b 81       	ldd	r24, Y+3	; 0x03
     b7a:	9c 81       	ldd	r25, Y+4	; 0x04
     b7c:	01 97       	sbiw	r24, 0x01	; 1
     b7e:	9c 83       	std	Y+4, r25	; 0x04
     b80:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     b82:	eb 81       	ldd	r30, Y+3	; 0x03
     b84:	fc 81       	ldd	r31, Y+4	; 0x04
     b86:	80 e1       	ldi	r24, 0x10	; 16
     b88:	80 83       	st	Z, r24
	pxTopOfStack--;
     b8a:	8b 81       	ldd	r24, Y+3	; 0x03
     b8c:	9c 81       	ldd	r25, Y+4	; 0x04
     b8e:	01 97       	sbiw	r24, 0x01	; 1
     b90:	9c 83       	std	Y+4, r25	; 0x04
     b92:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     b94:	eb 81       	ldd	r30, Y+3	; 0x03
     b96:	fc 81       	ldd	r31, Y+4	; 0x04
     b98:	81 e1       	ldi	r24, 0x11	; 17
     b9a:	80 83       	st	Z, r24
	pxTopOfStack--;
     b9c:	8b 81       	ldd	r24, Y+3	; 0x03
     b9e:	9c 81       	ldd	r25, Y+4	; 0x04
     ba0:	01 97       	sbiw	r24, 0x01	; 1
     ba2:	9c 83       	std	Y+4, r25	; 0x04
     ba4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     ba6:	eb 81       	ldd	r30, Y+3	; 0x03
     ba8:	fc 81       	ldd	r31, Y+4	; 0x04
     baa:	82 e1       	ldi	r24, 0x12	; 18
     bac:	80 83       	st	Z, r24
	pxTopOfStack--;
     bae:	8b 81       	ldd	r24, Y+3	; 0x03
     bb0:	9c 81       	ldd	r25, Y+4	; 0x04
     bb2:	01 97       	sbiw	r24, 0x01	; 1
     bb4:	9c 83       	std	Y+4, r25	; 0x04
     bb6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     bb8:	eb 81       	ldd	r30, Y+3	; 0x03
     bba:	fc 81       	ldd	r31, Y+4	; 0x04
     bbc:	83 e1       	ldi	r24, 0x13	; 19
     bbe:	80 83       	st	Z, r24
	pxTopOfStack--;
     bc0:	8b 81       	ldd	r24, Y+3	; 0x03
     bc2:	9c 81       	ldd	r25, Y+4	; 0x04
     bc4:	01 97       	sbiw	r24, 0x01	; 1
     bc6:	9c 83       	std	Y+4, r25	; 0x04
     bc8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     bca:	eb 81       	ldd	r30, Y+3	; 0x03
     bcc:	fc 81       	ldd	r31, Y+4	; 0x04
     bce:	84 e1       	ldi	r24, 0x14	; 20
     bd0:	80 83       	st	Z, r24
	pxTopOfStack--;
     bd2:	8b 81       	ldd	r24, Y+3	; 0x03
     bd4:	9c 81       	ldd	r25, Y+4	; 0x04
     bd6:	01 97       	sbiw	r24, 0x01	; 1
     bd8:	9c 83       	std	Y+4, r25	; 0x04
     bda:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     bdc:	eb 81       	ldd	r30, Y+3	; 0x03
     bde:	fc 81       	ldd	r31, Y+4	; 0x04
     be0:	85 e1       	ldi	r24, 0x15	; 21
     be2:	80 83       	st	Z, r24
	pxTopOfStack--;
     be4:	8b 81       	ldd	r24, Y+3	; 0x03
     be6:	9c 81       	ldd	r25, Y+4	; 0x04
     be8:	01 97       	sbiw	r24, 0x01	; 1
     bea:	9c 83       	std	Y+4, r25	; 0x04
     bec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     bee:	eb 81       	ldd	r30, Y+3	; 0x03
     bf0:	fc 81       	ldd	r31, Y+4	; 0x04
     bf2:	86 e1       	ldi	r24, 0x16	; 22
     bf4:	80 83       	st	Z, r24
	pxTopOfStack--;
     bf6:	8b 81       	ldd	r24, Y+3	; 0x03
     bf8:	9c 81       	ldd	r25, Y+4	; 0x04
     bfa:	01 97       	sbiw	r24, 0x01	; 1
     bfc:	9c 83       	std	Y+4, r25	; 0x04
     bfe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     c00:	eb 81       	ldd	r30, Y+3	; 0x03
     c02:	fc 81       	ldd	r31, Y+4	; 0x04
     c04:	87 e1       	ldi	r24, 0x17	; 23
     c06:	80 83       	st	Z, r24
	pxTopOfStack--;
     c08:	8b 81       	ldd	r24, Y+3	; 0x03
     c0a:	9c 81       	ldd	r25, Y+4	; 0x04
     c0c:	01 97       	sbiw	r24, 0x01	; 1
     c0e:	9c 83       	std	Y+4, r25	; 0x04
     c10:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     c12:	eb 81       	ldd	r30, Y+3	; 0x03
     c14:	fc 81       	ldd	r31, Y+4	; 0x04
     c16:	88 e1       	ldi	r24, 0x18	; 24
     c18:	80 83       	st	Z, r24
	pxTopOfStack--;
     c1a:	8b 81       	ldd	r24, Y+3	; 0x03
     c1c:	9c 81       	ldd	r25, Y+4	; 0x04
     c1e:	01 97       	sbiw	r24, 0x01	; 1
     c20:	9c 83       	std	Y+4, r25	; 0x04
     c22:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     c24:	eb 81       	ldd	r30, Y+3	; 0x03
     c26:	fc 81       	ldd	r31, Y+4	; 0x04
     c28:	89 e1       	ldi	r24, 0x19	; 25
     c2a:	80 83       	st	Z, r24
	pxTopOfStack--;
     c2c:	8b 81       	ldd	r24, Y+3	; 0x03
     c2e:	9c 81       	ldd	r25, Y+4	; 0x04
     c30:	01 97       	sbiw	r24, 0x01	; 1
     c32:	9c 83       	std	Y+4, r25	; 0x04
     c34:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     c36:	eb 81       	ldd	r30, Y+3	; 0x03
     c38:	fc 81       	ldd	r31, Y+4	; 0x04
     c3a:	80 e2       	ldi	r24, 0x20	; 32
     c3c:	80 83       	st	Z, r24
	pxTopOfStack--;
     c3e:	8b 81       	ldd	r24, Y+3	; 0x03
     c40:	9c 81       	ldd	r25, Y+4	; 0x04
     c42:	01 97       	sbiw	r24, 0x01	; 1
     c44:	9c 83       	std	Y+4, r25	; 0x04
     c46:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     c48:	eb 81       	ldd	r30, Y+3	; 0x03
     c4a:	fc 81       	ldd	r31, Y+4	; 0x04
     c4c:	81 e2       	ldi	r24, 0x21	; 33
     c4e:	80 83       	st	Z, r24
	pxTopOfStack--;
     c50:	8b 81       	ldd	r24, Y+3	; 0x03
     c52:	9c 81       	ldd	r25, Y+4	; 0x04
     c54:	01 97       	sbiw	r24, 0x01	; 1
     c56:	9c 83       	std	Y+4, r25	; 0x04
     c58:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     c5a:	eb 81       	ldd	r30, Y+3	; 0x03
     c5c:	fc 81       	ldd	r31, Y+4	; 0x04
     c5e:	82 e2       	ldi	r24, 0x22	; 34
     c60:	80 83       	st	Z, r24
	pxTopOfStack--;
     c62:	8b 81       	ldd	r24, Y+3	; 0x03
     c64:	9c 81       	ldd	r25, Y+4	; 0x04
     c66:	01 97       	sbiw	r24, 0x01	; 1
     c68:	9c 83       	std	Y+4, r25	; 0x04
     c6a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     c6c:	eb 81       	ldd	r30, Y+3	; 0x03
     c6e:	fc 81       	ldd	r31, Y+4	; 0x04
     c70:	83 e2       	ldi	r24, 0x23	; 35
     c72:	80 83       	st	Z, r24
	pxTopOfStack--;
     c74:	8b 81       	ldd	r24, Y+3	; 0x03
     c76:	9c 81       	ldd	r25, Y+4	; 0x04
     c78:	01 97       	sbiw	r24, 0x01	; 1
     c7a:	9c 83       	std	Y+4, r25	; 0x04
     c7c:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
     c7e:	8f 81       	ldd	r24, Y+7	; 0x07
     c80:	98 85       	ldd	r25, Y+8	; 0x08
     c82:	9a 83       	std	Y+2, r25	; 0x02
     c84:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     c86:	89 81       	ldd	r24, Y+1	; 0x01
     c88:	eb 81       	ldd	r30, Y+3	; 0x03
     c8a:	fc 81       	ldd	r31, Y+4	; 0x04
     c8c:	80 83       	st	Z, r24
	pxTopOfStack--;
     c8e:	8b 81       	ldd	r24, Y+3	; 0x03
     c90:	9c 81       	ldd	r25, Y+4	; 0x04
     c92:	01 97       	sbiw	r24, 0x01	; 1
     c94:	9c 83       	std	Y+4, r25	; 0x04
     c96:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     c98:	89 81       	ldd	r24, Y+1	; 0x01
     c9a:	9a 81       	ldd	r25, Y+2	; 0x02
     c9c:	89 2f       	mov	r24, r25
     c9e:	99 27       	eor	r25, r25
     ca0:	9a 83       	std	Y+2, r25	; 0x02
     ca2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     ca4:	89 81       	ldd	r24, Y+1	; 0x01
     ca6:	eb 81       	ldd	r30, Y+3	; 0x03
     ca8:	fc 81       	ldd	r31, Y+4	; 0x04
     caa:	80 83       	st	Z, r24
	pxTopOfStack--;
     cac:	8b 81       	ldd	r24, Y+3	; 0x03
     cae:	9c 81       	ldd	r25, Y+4	; 0x04
     cb0:	01 97       	sbiw	r24, 0x01	; 1
     cb2:	9c 83       	std	Y+4, r25	; 0x04
     cb4:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     cb6:	eb 81       	ldd	r30, Y+3	; 0x03
     cb8:	fc 81       	ldd	r31, Y+4	; 0x04
     cba:	86 e2       	ldi	r24, 0x26	; 38
     cbc:	80 83       	st	Z, r24
	pxTopOfStack--;
     cbe:	8b 81       	ldd	r24, Y+3	; 0x03
     cc0:	9c 81       	ldd	r25, Y+4	; 0x04
     cc2:	01 97       	sbiw	r24, 0x01	; 1
     cc4:	9c 83       	std	Y+4, r25	; 0x04
     cc6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     cc8:	eb 81       	ldd	r30, Y+3	; 0x03
     cca:	fc 81       	ldd	r31, Y+4	; 0x04
     ccc:	87 e2       	ldi	r24, 0x27	; 39
     cce:	80 83       	st	Z, r24
	pxTopOfStack--;
     cd0:	8b 81       	ldd	r24, Y+3	; 0x03
     cd2:	9c 81       	ldd	r25, Y+4	; 0x04
     cd4:	01 97       	sbiw	r24, 0x01	; 1
     cd6:	9c 83       	std	Y+4, r25	; 0x04
     cd8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     cda:	eb 81       	ldd	r30, Y+3	; 0x03
     cdc:	fc 81       	ldd	r31, Y+4	; 0x04
     cde:	88 e2       	ldi	r24, 0x28	; 40
     ce0:	80 83       	st	Z, r24
	pxTopOfStack--;
     ce2:	8b 81       	ldd	r24, Y+3	; 0x03
     ce4:	9c 81       	ldd	r25, Y+4	; 0x04
     ce6:	01 97       	sbiw	r24, 0x01	; 1
     ce8:	9c 83       	std	Y+4, r25	; 0x04
     cea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     cec:	eb 81       	ldd	r30, Y+3	; 0x03
     cee:	fc 81       	ldd	r31, Y+4	; 0x04
     cf0:	89 e2       	ldi	r24, 0x29	; 41
     cf2:	80 83       	st	Z, r24
	pxTopOfStack--;
     cf4:	8b 81       	ldd	r24, Y+3	; 0x03
     cf6:	9c 81       	ldd	r25, Y+4	; 0x04
     cf8:	01 97       	sbiw	r24, 0x01	; 1
     cfa:	9c 83       	std	Y+4, r25	; 0x04
     cfc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     cfe:	eb 81       	ldd	r30, Y+3	; 0x03
     d00:	fc 81       	ldd	r31, Y+4	; 0x04
     d02:	80 e3       	ldi	r24, 0x30	; 48
     d04:	80 83       	st	Z, r24
	pxTopOfStack--;
     d06:	8b 81       	ldd	r24, Y+3	; 0x03
     d08:	9c 81       	ldd	r25, Y+4	; 0x04
     d0a:	01 97       	sbiw	r24, 0x01	; 1
     d0c:	9c 83       	std	Y+4, r25	; 0x04
     d0e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     d10:	eb 81       	ldd	r30, Y+3	; 0x03
     d12:	fc 81       	ldd	r31, Y+4	; 0x04
     d14:	81 e3       	ldi	r24, 0x31	; 49
     d16:	80 83       	st	Z, r24
	pxTopOfStack--;
     d18:	8b 81       	ldd	r24, Y+3	; 0x03
     d1a:	9c 81       	ldd	r25, Y+4	; 0x04
     d1c:	01 97       	sbiw	r24, 0x01	; 1
     d1e:	9c 83       	std	Y+4, r25	; 0x04
     d20:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     d22:	8b 81       	ldd	r24, Y+3	; 0x03
     d24:	9c 81       	ldd	r25, Y+4	; 0x04
}
     d26:	28 96       	adiw	r28, 0x08	; 8
     d28:	0f b6       	in	r0, 0x3f	; 63
     d2a:	f8 94       	cli
     d2c:	de bf       	out	0x3e, r29	; 62
     d2e:	0f be       	out	0x3f, r0	; 63
     d30:	cd bf       	out	0x3d, r28	; 61
     d32:	cf 91       	pop	r28
     d34:	df 91       	pop	r29
     d36:	08 95       	ret

00000d38 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
     d38:	df 93       	push	r29
     d3a:	cf 93       	push	r28
     d3c:	cd b7       	in	r28, 0x3d	; 61
     d3e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     d40:	0e 94 8c 07 	call	0xf18	; 0xf18 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     d44:	a0 91 04 03 	lds	r26, 0x0304
     d48:	b0 91 05 03 	lds	r27, 0x0305
     d4c:	cd 91       	ld	r28, X+
     d4e:	cd bf       	out	0x3d, r28	; 61
     d50:	dd 91       	ld	r29, X+
     d52:	de bf       	out	0x3e, r29	; 62
     d54:	ff 91       	pop	r31
     d56:	ef 91       	pop	r30
     d58:	df 91       	pop	r29
     d5a:	cf 91       	pop	r28
     d5c:	bf 91       	pop	r27
     d5e:	af 91       	pop	r26
     d60:	9f 91       	pop	r25
     d62:	8f 91       	pop	r24
     d64:	7f 91       	pop	r23
     d66:	6f 91       	pop	r22
     d68:	5f 91       	pop	r21
     d6a:	4f 91       	pop	r20
     d6c:	3f 91       	pop	r19
     d6e:	2f 91       	pop	r18
     d70:	1f 91       	pop	r17
     d72:	0f 91       	pop	r16
     d74:	ff 90       	pop	r15
     d76:	ef 90       	pop	r14
     d78:	df 90       	pop	r13
     d7a:	cf 90       	pop	r12
     d7c:	bf 90       	pop	r11
     d7e:	af 90       	pop	r10
     d80:	9f 90       	pop	r9
     d82:	8f 90       	pop	r8
     d84:	7f 90       	pop	r7
     d86:	6f 90       	pop	r6
     d88:	5f 90       	pop	r5
     d8a:	4f 90       	pop	r4
     d8c:	3f 90       	pop	r3
     d8e:	2f 90       	pop	r2
     d90:	1f 90       	pop	r1
     d92:	0f 90       	pop	r0
     d94:	0f be       	out	0x3f, r0	; 63
     d96:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     d98:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     d9a:	81 e0       	ldi	r24, 0x01	; 1
}
     d9c:	cf 91       	pop	r28
     d9e:	df 91       	pop	r29
     da0:	08 95       	ret

00000da2 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     da2:	df 93       	push	r29
     da4:	cf 93       	push	r28
     da6:	cd b7       	in	r28, 0x3d	; 61
     da8:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     daa:	cf 91       	pop	r28
     dac:	df 91       	pop	r29
     dae:	08 95       	ret

00000db0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     db0:	0f 92       	push	r0
     db2:	0f b6       	in	r0, 0x3f	; 63
     db4:	f8 94       	cli
     db6:	0f 92       	push	r0
     db8:	1f 92       	push	r1
     dba:	11 24       	eor	r1, r1
     dbc:	2f 92       	push	r2
     dbe:	3f 92       	push	r3
     dc0:	4f 92       	push	r4
     dc2:	5f 92       	push	r5
     dc4:	6f 92       	push	r6
     dc6:	7f 92       	push	r7
     dc8:	8f 92       	push	r8
     dca:	9f 92       	push	r9
     dcc:	af 92       	push	r10
     dce:	bf 92       	push	r11
     dd0:	cf 92       	push	r12
     dd2:	df 92       	push	r13
     dd4:	ef 92       	push	r14
     dd6:	ff 92       	push	r15
     dd8:	0f 93       	push	r16
     dda:	1f 93       	push	r17
     ddc:	2f 93       	push	r18
     dde:	3f 93       	push	r19
     de0:	4f 93       	push	r20
     de2:	5f 93       	push	r21
     de4:	6f 93       	push	r22
     de6:	7f 93       	push	r23
     de8:	8f 93       	push	r24
     dea:	9f 93       	push	r25
     dec:	af 93       	push	r26
     dee:	bf 93       	push	r27
     df0:	cf 93       	push	r28
     df2:	df 93       	push	r29
     df4:	ef 93       	push	r30
     df6:	ff 93       	push	r31
     df8:	a0 91 04 03 	lds	r26, 0x0304
     dfc:	b0 91 05 03 	lds	r27, 0x0305
     e00:	0d b6       	in	r0, 0x3d	; 61
     e02:	0d 92       	st	X+, r0
     e04:	0e b6       	in	r0, 0x3e	; 62
     e06:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     e08:	0e 94 48 10 	call	0x2090	; 0x2090 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     e0c:	a0 91 04 03 	lds	r26, 0x0304
     e10:	b0 91 05 03 	lds	r27, 0x0305
     e14:	cd 91       	ld	r28, X+
     e16:	cd bf       	out	0x3d, r28	; 61
     e18:	dd 91       	ld	r29, X+
     e1a:	de bf       	out	0x3e, r29	; 62
     e1c:	ff 91       	pop	r31
     e1e:	ef 91       	pop	r30
     e20:	df 91       	pop	r29
     e22:	cf 91       	pop	r28
     e24:	bf 91       	pop	r27
     e26:	af 91       	pop	r26
     e28:	9f 91       	pop	r25
     e2a:	8f 91       	pop	r24
     e2c:	7f 91       	pop	r23
     e2e:	6f 91       	pop	r22
     e30:	5f 91       	pop	r21
     e32:	4f 91       	pop	r20
     e34:	3f 91       	pop	r19
     e36:	2f 91       	pop	r18
     e38:	1f 91       	pop	r17
     e3a:	0f 91       	pop	r16
     e3c:	ff 90       	pop	r15
     e3e:	ef 90       	pop	r14
     e40:	df 90       	pop	r13
     e42:	cf 90       	pop	r12
     e44:	bf 90       	pop	r11
     e46:	af 90       	pop	r10
     e48:	9f 90       	pop	r9
     e4a:	8f 90       	pop	r8
     e4c:	7f 90       	pop	r7
     e4e:	6f 90       	pop	r6
     e50:	5f 90       	pop	r5
     e52:	4f 90       	pop	r4
     e54:	3f 90       	pop	r3
     e56:	2f 90       	pop	r2
     e58:	1f 90       	pop	r1
     e5a:	0f 90       	pop	r0
     e5c:	0f be       	out	0x3f, r0	; 63
     e5e:	0f 90       	pop	r0

	asm volatile ( "ret" );
     e60:	08 95       	ret

00000e62 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     e62:	0f 92       	push	r0
     e64:	0f b6       	in	r0, 0x3f	; 63
     e66:	f8 94       	cli
     e68:	0f 92       	push	r0
     e6a:	1f 92       	push	r1
     e6c:	11 24       	eor	r1, r1
     e6e:	2f 92       	push	r2
     e70:	3f 92       	push	r3
     e72:	4f 92       	push	r4
     e74:	5f 92       	push	r5
     e76:	6f 92       	push	r6
     e78:	7f 92       	push	r7
     e7a:	8f 92       	push	r8
     e7c:	9f 92       	push	r9
     e7e:	af 92       	push	r10
     e80:	bf 92       	push	r11
     e82:	cf 92       	push	r12
     e84:	df 92       	push	r13
     e86:	ef 92       	push	r14
     e88:	ff 92       	push	r15
     e8a:	0f 93       	push	r16
     e8c:	1f 93       	push	r17
     e8e:	2f 93       	push	r18
     e90:	3f 93       	push	r19
     e92:	4f 93       	push	r20
     e94:	5f 93       	push	r21
     e96:	6f 93       	push	r22
     e98:	7f 93       	push	r23
     e9a:	8f 93       	push	r24
     e9c:	9f 93       	push	r25
     e9e:	af 93       	push	r26
     ea0:	bf 93       	push	r27
     ea2:	cf 93       	push	r28
     ea4:	df 93       	push	r29
     ea6:	ef 93       	push	r30
     ea8:	ff 93       	push	r31
     eaa:	a0 91 04 03 	lds	r26, 0x0304
     eae:	b0 91 05 03 	lds	r27, 0x0305
     eb2:	0d b6       	in	r0, 0x3d	; 61
     eb4:	0d 92       	st	X+, r0
     eb6:	0e b6       	in	r0, 0x3e	; 62
     eb8:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     eba:	0e 94 73 0f 	call	0x1ee6	; 0x1ee6 <vTaskIncrementTick>
	vTaskSwitchContext();
     ebe:	0e 94 48 10 	call	0x2090	; 0x2090 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     ec2:	a0 91 04 03 	lds	r26, 0x0304
     ec6:	b0 91 05 03 	lds	r27, 0x0305
     eca:	cd 91       	ld	r28, X+
     ecc:	cd bf       	out	0x3d, r28	; 61
     ece:	dd 91       	ld	r29, X+
     ed0:	de bf       	out	0x3e, r29	; 62
     ed2:	ff 91       	pop	r31
     ed4:	ef 91       	pop	r30
     ed6:	df 91       	pop	r29
     ed8:	cf 91       	pop	r28
     eda:	bf 91       	pop	r27
     edc:	af 91       	pop	r26
     ede:	9f 91       	pop	r25
     ee0:	8f 91       	pop	r24
     ee2:	7f 91       	pop	r23
     ee4:	6f 91       	pop	r22
     ee6:	5f 91       	pop	r21
     ee8:	4f 91       	pop	r20
     eea:	3f 91       	pop	r19
     eec:	2f 91       	pop	r18
     eee:	1f 91       	pop	r17
     ef0:	0f 91       	pop	r16
     ef2:	ff 90       	pop	r15
     ef4:	ef 90       	pop	r14
     ef6:	df 90       	pop	r13
     ef8:	cf 90       	pop	r12
     efa:	bf 90       	pop	r11
     efc:	af 90       	pop	r10
     efe:	9f 90       	pop	r9
     f00:	8f 90       	pop	r8
     f02:	7f 90       	pop	r7
     f04:	6f 90       	pop	r6
     f06:	5f 90       	pop	r5
     f08:	4f 90       	pop	r4
     f0a:	3f 90       	pop	r3
     f0c:	2f 90       	pop	r2
     f0e:	1f 90       	pop	r1
     f10:	0f 90       	pop	r0
     f12:	0f be       	out	0x3f, r0	; 63
     f14:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f16:	08 95       	ret

00000f18 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     f18:	df 93       	push	r29
     f1a:	cf 93       	push	r28
     f1c:	00 d0       	rcall	.+0      	; 0xf1e <prvSetupTimerInterrupt+0x6>
     f1e:	00 d0       	rcall	.+0      	; 0xf20 <prvSetupTimerInterrupt+0x8>
     f20:	00 d0       	rcall	.+0      	; 0xf22 <prvSetupTimerInterrupt+0xa>
     f22:	cd b7       	in	r28, 0x3d	; 61
     f24:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     f26:	80 e4       	ldi	r24, 0x40	; 64
     f28:	9f e1       	ldi	r25, 0x1F	; 31
     f2a:	a0 e0       	ldi	r26, 0x00	; 0
     f2c:	b0 e0       	ldi	r27, 0x00	; 0
     f2e:	8b 83       	std	Y+3, r24	; 0x03
     f30:	9c 83       	std	Y+4, r25	; 0x04
     f32:	ad 83       	std	Y+5, r26	; 0x05
     f34:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     f36:	8b 81       	ldd	r24, Y+3	; 0x03
     f38:	9c 81       	ldd	r25, Y+4	; 0x04
     f3a:	ad 81       	ldd	r26, Y+5	; 0x05
     f3c:	be 81       	ldd	r27, Y+6	; 0x06
     f3e:	68 94       	set
     f40:	15 f8       	bld	r1, 5
     f42:	b6 95       	lsr	r27
     f44:	a7 95       	ror	r26
     f46:	97 95       	ror	r25
     f48:	87 95       	ror	r24
     f4a:	16 94       	lsr	r1
     f4c:	d1 f7       	brne	.-12     	; 0xf42 <prvSetupTimerInterrupt+0x2a>
     f4e:	8b 83       	std	Y+3, r24	; 0x03
     f50:	9c 83       	std	Y+4, r25	; 0x04
     f52:	ad 83       	std	Y+5, r26	; 0x05
     f54:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
     f56:	8b 81       	ldd	r24, Y+3	; 0x03
     f58:	9c 81       	ldd	r25, Y+4	; 0x04
     f5a:	ad 81       	ldd	r26, Y+5	; 0x05
     f5c:	be 81       	ldd	r27, Y+6	; 0x06
     f5e:	01 97       	sbiw	r24, 0x01	; 1
     f60:	a1 09       	sbc	r26, r1
     f62:	b1 09       	sbc	r27, r1
     f64:	8b 83       	std	Y+3, r24	; 0x03
     f66:	9c 83       	std	Y+4, r25	; 0x04
     f68:	ad 83       	std	Y+5, r26	; 0x05
     f6a:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
     f6c:	8b 81       	ldd	r24, Y+3	; 0x03
     f6e:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
     f70:	8b 81       	ldd	r24, Y+3	; 0x03
     f72:	9c 81       	ldd	r25, Y+4	; 0x04
     f74:	ad 81       	ldd	r26, Y+5	; 0x05
     f76:	be 81       	ldd	r27, Y+6	; 0x06
     f78:	89 2f       	mov	r24, r25
     f7a:	9a 2f       	mov	r25, r26
     f7c:	ab 2f       	mov	r26, r27
     f7e:	bb 27       	eor	r27, r27
     f80:	8b 83       	std	Y+3, r24	; 0x03
     f82:	9c 83       	std	Y+4, r25	; 0x04
     f84:	ad 83       	std	Y+5, r26	; 0x05
     f86:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
     f88:	8b 81       	ldd	r24, Y+3	; 0x03
     f8a:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
     f8c:	eb e4       	ldi	r30, 0x4B	; 75
     f8e:	f0 e0       	ldi	r31, 0x00	; 0
     f90:	8a 81       	ldd	r24, Y+2	; 0x02
     f92:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
     f94:	ea e4       	ldi	r30, 0x4A	; 74
     f96:	f0 e0       	ldi	r31, 0x00	; 0
     f98:	89 81       	ldd	r24, Y+1	; 0x01
     f9a:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     f9c:	8b e0       	ldi	r24, 0x0B	; 11
     f9e:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
     fa0:	ee e4       	ldi	r30, 0x4E	; 78
     fa2:	f0 e0       	ldi	r31, 0x00	; 0
     fa4:	89 81       	ldd	r24, Y+1	; 0x01
     fa6:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     fa8:	e9 e5       	ldi	r30, 0x59	; 89
     faa:	f0 e0       	ldi	r31, 0x00	; 0
     fac:	80 81       	ld	r24, Z
     fae:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     fb0:	89 81       	ldd	r24, Y+1	; 0x01
     fb2:	80 61       	ori	r24, 0x10	; 16
     fb4:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
     fb6:	e9 e5       	ldi	r30, 0x59	; 89
     fb8:	f0 e0       	ldi	r31, 0x00	; 0
     fba:	89 81       	ldd	r24, Y+1	; 0x01
     fbc:	80 83       	st	Z, r24
}
     fbe:	26 96       	adiw	r28, 0x06	; 6
     fc0:	0f b6       	in	r0, 0x3f	; 63
     fc2:	f8 94       	cli
     fc4:	de bf       	out	0x3e, r29	; 62
     fc6:	0f be       	out	0x3f, r0	; 63
     fc8:	cd bf       	out	0x3d, r28	; 61
     fca:	cf 91       	pop	r28
     fcc:	df 91       	pop	r29
     fce:	08 95       	ret

00000fd0 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
     fd0:	0e 94 31 07 	call	0xe62	; 0xe62 <vPortYieldFromTick>
		asm volatile ( "reti" );
     fd4:	18 95       	reti

00000fd6 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
     fd6:	df 93       	push	r29
     fd8:	cf 93       	push	r28
     fda:	cd b7       	in	r28, 0x3d	; 61
     fdc:	de b7       	in	r29, 0x3e	; 62
     fde:	28 97       	sbiw	r28, 0x08	; 8
     fe0:	0f b6       	in	r0, 0x3f	; 63
     fe2:	f8 94       	cli
     fe4:	de bf       	out	0x3e, r29	; 62
     fe6:	0f be       	out	0x3f, r0	; 63
     fe8:	cd bf       	out	0x3d, r28	; 61
     fea:	8f 83       	std	Y+7, r24	; 0x07
     fec:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
     fee:	1a 82       	std	Y+2, r1	; 0x02
     ff0:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     ff2:	8f 81       	ldd	r24, Y+7	; 0x07
     ff4:	88 23       	and	r24, r24
     ff6:	09 f4       	brne	.+2      	; 0xffa <xQueueCreate+0x24>
     ff8:	8c c0       	rjmp	.+280    	; 0x1112 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     ffa:	8f e1       	ldi	r24, 0x1F	; 31
     ffc:	90 e0       	ldi	r25, 0x00	; 0
     ffe:	0e 94 72 03 	call	0x6e4	; 0x6e4 <pvPortMalloc>
    1002:	9e 83       	std	Y+6, r25	; 0x06
    1004:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    1006:	8d 81       	ldd	r24, Y+5	; 0x05
    1008:	9e 81       	ldd	r25, Y+6	; 0x06
    100a:	00 97       	sbiw	r24, 0x00	; 0
    100c:	09 f4       	brne	.+2      	; 0x1010 <xQueueCreate+0x3a>
    100e:	81 c0       	rjmp	.+258    	; 0x1112 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1010:	8f 81       	ldd	r24, Y+7	; 0x07
    1012:	28 2f       	mov	r18, r24
    1014:	30 e0       	ldi	r19, 0x00	; 0
    1016:	88 85       	ldd	r24, Y+8	; 0x08
    1018:	88 2f       	mov	r24, r24
    101a:	90 e0       	ldi	r25, 0x00	; 0
    101c:	ac 01       	movw	r20, r24
    101e:	24 9f       	mul	r18, r20
    1020:	c0 01       	movw	r24, r0
    1022:	25 9f       	mul	r18, r21
    1024:	90 0d       	add	r25, r0
    1026:	34 9f       	mul	r19, r20
    1028:	90 0d       	add	r25, r0
    102a:	11 24       	eor	r1, r1
    102c:	01 96       	adiw	r24, 0x01	; 1
    102e:	9c 83       	std	Y+4, r25	; 0x04
    1030:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1032:	8b 81       	ldd	r24, Y+3	; 0x03
    1034:	9c 81       	ldd	r25, Y+4	; 0x04
    1036:	0e 94 72 03 	call	0x6e4	; 0x6e4 <pvPortMalloc>
    103a:	ed 81       	ldd	r30, Y+5	; 0x05
    103c:	fe 81       	ldd	r31, Y+6	; 0x06
    103e:	91 83       	std	Z+1, r25	; 0x01
    1040:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    1042:	ed 81       	ldd	r30, Y+5	; 0x05
    1044:	fe 81       	ldd	r31, Y+6	; 0x06
    1046:	80 81       	ld	r24, Z
    1048:	91 81       	ldd	r25, Z+1	; 0x01
    104a:	00 97       	sbiw	r24, 0x00	; 0
    104c:	09 f4       	brne	.+2      	; 0x1050 <xQueueCreate+0x7a>
    104e:	5d c0       	rjmp	.+186    	; 0x110a <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    1050:	ed 81       	ldd	r30, Y+5	; 0x05
    1052:	fe 81       	ldd	r31, Y+6	; 0x06
    1054:	40 81       	ld	r20, Z
    1056:	51 81       	ldd	r21, Z+1	; 0x01
    1058:	8f 81       	ldd	r24, Y+7	; 0x07
    105a:	28 2f       	mov	r18, r24
    105c:	30 e0       	ldi	r19, 0x00	; 0
    105e:	88 85       	ldd	r24, Y+8	; 0x08
    1060:	88 2f       	mov	r24, r24
    1062:	90 e0       	ldi	r25, 0x00	; 0
    1064:	bc 01       	movw	r22, r24
    1066:	26 9f       	mul	r18, r22
    1068:	c0 01       	movw	r24, r0
    106a:	27 9f       	mul	r18, r23
    106c:	90 0d       	add	r25, r0
    106e:	36 9f       	mul	r19, r22
    1070:	90 0d       	add	r25, r0
    1072:	11 24       	eor	r1, r1
    1074:	84 0f       	add	r24, r20
    1076:	95 1f       	adc	r25, r21
    1078:	ed 81       	ldd	r30, Y+5	; 0x05
    107a:	fe 81       	ldd	r31, Y+6	; 0x06
    107c:	93 83       	std	Z+3, r25	; 0x03
    107e:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1080:	ed 81       	ldd	r30, Y+5	; 0x05
    1082:	fe 81       	ldd	r31, Y+6	; 0x06
    1084:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    1086:	ed 81       	ldd	r30, Y+5	; 0x05
    1088:	fe 81       	ldd	r31, Y+6	; 0x06
    108a:	80 81       	ld	r24, Z
    108c:	91 81       	ldd	r25, Z+1	; 0x01
    108e:	ed 81       	ldd	r30, Y+5	; 0x05
    1090:	fe 81       	ldd	r31, Y+6	; 0x06
    1092:	95 83       	std	Z+5, r25	; 0x05
    1094:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    1096:	ed 81       	ldd	r30, Y+5	; 0x05
    1098:	fe 81       	ldd	r31, Y+6	; 0x06
    109a:	40 81       	ld	r20, Z
    109c:	51 81       	ldd	r21, Z+1	; 0x01
    109e:	8f 81       	ldd	r24, Y+7	; 0x07
    10a0:	88 2f       	mov	r24, r24
    10a2:	90 e0       	ldi	r25, 0x00	; 0
    10a4:	9c 01       	movw	r18, r24
    10a6:	21 50       	subi	r18, 0x01	; 1
    10a8:	30 40       	sbci	r19, 0x00	; 0
    10aa:	88 85       	ldd	r24, Y+8	; 0x08
    10ac:	88 2f       	mov	r24, r24
    10ae:	90 e0       	ldi	r25, 0x00	; 0
    10b0:	bc 01       	movw	r22, r24
    10b2:	26 9f       	mul	r18, r22
    10b4:	c0 01       	movw	r24, r0
    10b6:	27 9f       	mul	r18, r23
    10b8:	90 0d       	add	r25, r0
    10ba:	36 9f       	mul	r19, r22
    10bc:	90 0d       	add	r25, r0
    10be:	11 24       	eor	r1, r1
    10c0:	84 0f       	add	r24, r20
    10c2:	95 1f       	adc	r25, r21
    10c4:	ed 81       	ldd	r30, Y+5	; 0x05
    10c6:	fe 81       	ldd	r31, Y+6	; 0x06
    10c8:	97 83       	std	Z+7, r25	; 0x07
    10ca:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    10cc:	ed 81       	ldd	r30, Y+5	; 0x05
    10ce:	fe 81       	ldd	r31, Y+6	; 0x06
    10d0:	8f 81       	ldd	r24, Y+7	; 0x07
    10d2:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    10d4:	ed 81       	ldd	r30, Y+5	; 0x05
    10d6:	fe 81       	ldd	r31, Y+6	; 0x06
    10d8:	88 85       	ldd	r24, Y+8	; 0x08
    10da:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    10dc:	ed 81       	ldd	r30, Y+5	; 0x05
    10de:	fe 81       	ldd	r31, Y+6	; 0x06
    10e0:	8f ef       	ldi	r24, 0xFF	; 255
    10e2:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    10e4:	ed 81       	ldd	r30, Y+5	; 0x05
    10e6:	fe 81       	ldd	r31, Y+6	; 0x06
    10e8:	8f ef       	ldi	r24, 0xFF	; 255
    10ea:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    10ec:	8d 81       	ldd	r24, Y+5	; 0x05
    10ee:	9e 81       	ldd	r25, Y+6	; 0x06
    10f0:	08 96       	adiw	r24, 0x08	; 8
    10f2:	0e 94 de 03 	call	0x7bc	; 0x7bc <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    10f6:	8d 81       	ldd	r24, Y+5	; 0x05
    10f8:	9e 81       	ldd	r25, Y+6	; 0x06
    10fa:	41 96       	adiw	r24, 0x11	; 17
    10fc:	0e 94 de 03 	call	0x7bc	; 0x7bc <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1100:	8d 81       	ldd	r24, Y+5	; 0x05
    1102:	9e 81       	ldd	r25, Y+6	; 0x06
    1104:	9a 83       	std	Y+2, r25	; 0x02
    1106:	89 83       	std	Y+1, r24	; 0x01
    1108:	04 c0       	rjmp	.+8      	; 0x1112 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    110a:	8d 81       	ldd	r24, Y+5	; 0x05
    110c:	9e 81       	ldd	r25, Y+6	; 0x06
    110e:	0e 94 b8 03 	call	0x770	; 0x770 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    1112:	89 81       	ldd	r24, Y+1	; 0x01
    1114:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1116:	28 96       	adiw	r28, 0x08	; 8
    1118:	0f b6       	in	r0, 0x3f	; 63
    111a:	f8 94       	cli
    111c:	de bf       	out	0x3e, r29	; 62
    111e:	0f be       	out	0x3f, r0	; 63
    1120:	cd bf       	out	0x3d, r28	; 61
    1122:	cf 91       	pop	r28
    1124:	df 91       	pop	r29
    1126:	08 95       	ret

00001128 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1128:	df 93       	push	r29
    112a:	cf 93       	push	r28
    112c:	cd b7       	in	r28, 0x3d	; 61
    112e:	de b7       	in	r29, 0x3e	; 62
    1130:	2c 97       	sbiw	r28, 0x0c	; 12
    1132:	0f b6       	in	r0, 0x3f	; 63
    1134:	f8 94       	cli
    1136:	de bf       	out	0x3e, r29	; 62
    1138:	0f be       	out	0x3f, r0	; 63
    113a:	cd bf       	out	0x3d, r28	; 61
    113c:	9e 83       	std	Y+6, r25	; 0x06
    113e:	8d 83       	std	Y+5, r24	; 0x05
    1140:	78 87       	std	Y+8, r23	; 0x08
    1142:	6f 83       	std	Y+7, r22	; 0x07
    1144:	5a 87       	std	Y+10, r21	; 0x0a
    1146:	49 87       	std	Y+9, r20	; 0x09
    1148:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    114a:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    114c:	0f b6       	in	r0, 0x3f	; 63
    114e:	f8 94       	cli
    1150:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1152:	ed 81       	ldd	r30, Y+5	; 0x05
    1154:	fe 81       	ldd	r31, Y+6	; 0x06
    1156:	92 8d       	ldd	r25, Z+26	; 0x1a
    1158:	ed 81       	ldd	r30, Y+5	; 0x05
    115a:	fe 81       	ldd	r31, Y+6	; 0x06
    115c:	83 8d       	ldd	r24, Z+27	; 0x1b
    115e:	98 17       	cp	r25, r24
    1160:	d8 f4       	brcc	.+54     	; 0x1198 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1162:	8d 81       	ldd	r24, Y+5	; 0x05
    1164:	9e 81       	ldd	r25, Y+6	; 0x06
    1166:	2f 81       	ldd	r18, Y+7	; 0x07
    1168:	38 85       	ldd	r19, Y+8	; 0x08
    116a:	b9 01       	movw	r22, r18
    116c:	4b 85       	ldd	r20, Y+11	; 0x0b
    116e:	0e 94 cf 0a 	call	0x159e	; 0x159e <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1172:	ed 81       	ldd	r30, Y+5	; 0x05
    1174:	fe 81       	ldd	r31, Y+6	; 0x06
    1176:	81 89       	ldd	r24, Z+17	; 0x11
    1178:	88 23       	and	r24, r24
    117a:	49 f0       	breq	.+18     	; 0x118e <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    117c:	8d 81       	ldd	r24, Y+5	; 0x05
    117e:	9e 81       	ldd	r25, Y+6	; 0x06
    1180:	41 96       	adiw	r24, 0x11	; 17
    1182:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <xTaskRemoveFromEventList>
    1186:	81 30       	cpi	r24, 0x01	; 1
    1188:	11 f4       	brne	.+4      	; 0x118e <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    118a:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    118e:	0f 90       	pop	r0
    1190:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1192:	81 e0       	ldi	r24, 0x01	; 1
    1194:	8c 87       	std	Y+12, r24	; 0x0c
    1196:	5c c0       	rjmp	.+184    	; 0x1250 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1198:	89 85       	ldd	r24, Y+9	; 0x09
    119a:	9a 85       	ldd	r25, Y+10	; 0x0a
    119c:	00 97       	sbiw	r24, 0x00	; 0
    119e:	21 f4       	brne	.+8      	; 0x11a8 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    11a0:	0f 90       	pop	r0
    11a2:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    11a4:	1c 86       	std	Y+12, r1	; 0x0c
    11a6:	54 c0       	rjmp	.+168    	; 0x1250 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    11a8:	89 81       	ldd	r24, Y+1	; 0x01
    11aa:	88 23       	and	r24, r24
    11ac:	31 f4       	brne	.+12     	; 0x11ba <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    11ae:	ce 01       	movw	r24, r28
    11b0:	02 96       	adiw	r24, 0x02	; 2
    11b2:	0e 94 4c 11 	call	0x2298	; 0x2298 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    11b6:	81 e0       	ldi	r24, 0x01	; 1
    11b8:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    11ba:	0f 90       	pop	r0
    11bc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    11be:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    11c2:	0f b6       	in	r0, 0x3f	; 63
    11c4:	f8 94       	cli
    11c6:	0f 92       	push	r0
    11c8:	ed 81       	ldd	r30, Y+5	; 0x05
    11ca:	fe 81       	ldd	r31, Y+6	; 0x06
    11cc:	85 8d       	ldd	r24, Z+29	; 0x1d
    11ce:	8f 3f       	cpi	r24, 0xFF	; 255
    11d0:	19 f4       	brne	.+6      	; 0x11d8 <xQueueGenericSend+0xb0>
    11d2:	ed 81       	ldd	r30, Y+5	; 0x05
    11d4:	fe 81       	ldd	r31, Y+6	; 0x06
    11d6:	15 8e       	std	Z+29, r1	; 0x1d
    11d8:	ed 81       	ldd	r30, Y+5	; 0x05
    11da:	fe 81       	ldd	r31, Y+6	; 0x06
    11dc:	86 8d       	ldd	r24, Z+30	; 0x1e
    11de:	8f 3f       	cpi	r24, 0xFF	; 255
    11e0:	19 f4       	brne	.+6      	; 0x11e8 <xQueueGenericSend+0xc0>
    11e2:	ed 81       	ldd	r30, Y+5	; 0x05
    11e4:	fe 81       	ldd	r31, Y+6	; 0x06
    11e6:	16 8e       	std	Z+30, r1	; 0x1e
    11e8:	0f 90       	pop	r0
    11ea:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    11ec:	ce 01       	movw	r24, r28
    11ee:	02 96       	adiw	r24, 0x02	; 2
    11f0:	9e 01       	movw	r18, r28
    11f2:	27 5f       	subi	r18, 0xF7	; 247
    11f4:	3f 4f       	sbci	r19, 0xFF	; 255
    11f6:	b9 01       	movw	r22, r18
    11f8:	0e 94 65 11 	call	0x22ca	; 0x22ca <xTaskCheckForTimeOut>
    11fc:	88 23       	and	r24, r24
    11fe:	09 f5       	brne	.+66     	; 0x1242 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1200:	8d 81       	ldd	r24, Y+5	; 0x05
    1202:	9e 81       	ldd	r25, Y+6	; 0x06
    1204:	0e 94 33 0c 	call	0x1866	; 0x1866 <prvIsQueueFull>
    1208:	88 23       	and	r24, r24
    120a:	a1 f0       	breq	.+40     	; 0x1234 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    120c:	8d 81       	ldd	r24, Y+5	; 0x05
    120e:	9e 81       	ldd	r25, Y+6	; 0x06
    1210:	08 96       	adiw	r24, 0x08	; 8
    1212:	29 85       	ldd	r18, Y+9	; 0x09
    1214:	3a 85       	ldd	r19, Y+10	; 0x0a
    1216:	b9 01       	movw	r22, r18
    1218:	0e 94 ae 10 	call	0x215c	; 0x215c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    121c:	8d 81       	ldd	r24, Y+5	; 0x05
    121e:	9e 81       	ldd	r25, Y+6	; 0x06
    1220:	0e 94 ac 0b 	call	0x1758	; 0x1758 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1224:	0e 94 b4 0e 	call	0x1d68	; 0x1d68 <xTaskResumeAll>
    1228:	88 23       	and	r24, r24
    122a:	09 f0       	breq	.+2      	; 0x122e <xQueueGenericSend+0x106>
    122c:	8f cf       	rjmp	.-226    	; 0x114c <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    122e:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <vPortYield>
    1232:	8c cf       	rjmp	.-232    	; 0x114c <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1234:	8d 81       	ldd	r24, Y+5	; 0x05
    1236:	9e 81       	ldd	r25, Y+6	; 0x06
    1238:	0e 94 ac 0b 	call	0x1758	; 0x1758 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    123c:	0e 94 b4 0e 	call	0x1d68	; 0x1d68 <xTaskResumeAll>
    1240:	85 cf       	rjmp	.-246    	; 0x114c <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1242:	8d 81       	ldd	r24, Y+5	; 0x05
    1244:	9e 81       	ldd	r25, Y+6	; 0x06
    1246:	0e 94 ac 0b 	call	0x1758	; 0x1758 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    124a:	0e 94 b4 0e 	call	0x1d68	; 0x1d68 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    124e:	1c 86       	std	Y+12, r1	; 0x0c
    1250:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    1252:	2c 96       	adiw	r28, 0x0c	; 12
    1254:	0f b6       	in	r0, 0x3f	; 63
    1256:	f8 94       	cli
    1258:	de bf       	out	0x3e, r29	; 62
    125a:	0f be       	out	0x3f, r0	; 63
    125c:	cd bf       	out	0x3d, r28	; 61
    125e:	cf 91       	pop	r28
    1260:	df 91       	pop	r29
    1262:	08 95       	ret

00001264 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1264:	df 93       	push	r29
    1266:	cf 93       	push	r28
    1268:	cd b7       	in	r28, 0x3d	; 61
    126a:	de b7       	in	r29, 0x3e	; 62
    126c:	29 97       	sbiw	r28, 0x09	; 9
    126e:	0f b6       	in	r0, 0x3f	; 63
    1270:	f8 94       	cli
    1272:	de bf       	out	0x3e, r29	; 62
    1274:	0f be       	out	0x3f, r0	; 63
    1276:	cd bf       	out	0x3d, r28	; 61
    1278:	9c 83       	std	Y+4, r25	; 0x04
    127a:	8b 83       	std	Y+3, r24	; 0x03
    127c:	7e 83       	std	Y+6, r23	; 0x06
    127e:	6d 83       	std	Y+5, r22	; 0x05
    1280:	58 87       	std	Y+8, r21	; 0x08
    1282:	4f 83       	std	Y+7, r20	; 0x07
    1284:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1286:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1288:	eb 81       	ldd	r30, Y+3	; 0x03
    128a:	fc 81       	ldd	r31, Y+4	; 0x04
    128c:	92 8d       	ldd	r25, Z+26	; 0x1a
    128e:	eb 81       	ldd	r30, Y+3	; 0x03
    1290:	fc 81       	ldd	r31, Y+4	; 0x04
    1292:	83 8d       	ldd	r24, Z+27	; 0x1b
    1294:	98 17       	cp	r25, r24
    1296:	40 f5       	brcc	.+80     	; 0x12e8 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1298:	8b 81       	ldd	r24, Y+3	; 0x03
    129a:	9c 81       	ldd	r25, Y+4	; 0x04
    129c:	2d 81       	ldd	r18, Y+5	; 0x05
    129e:	3e 81       	ldd	r19, Y+6	; 0x06
    12a0:	b9 01       	movw	r22, r18
    12a2:	49 85       	ldd	r20, Y+9	; 0x09
    12a4:	0e 94 cf 0a 	call	0x159e	; 0x159e <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    12a8:	eb 81       	ldd	r30, Y+3	; 0x03
    12aa:	fc 81       	ldd	r31, Y+4	; 0x04
    12ac:	86 8d       	ldd	r24, Z+30	; 0x1e
    12ae:	8f 3f       	cpi	r24, 0xFF	; 255
    12b0:	89 f4       	brne	.+34     	; 0x12d4 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    12b2:	eb 81       	ldd	r30, Y+3	; 0x03
    12b4:	fc 81       	ldd	r31, Y+4	; 0x04
    12b6:	81 89       	ldd	r24, Z+17	; 0x11
    12b8:	88 23       	and	r24, r24
    12ba:	99 f0       	breq	.+38     	; 0x12e2 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    12bc:	8b 81       	ldd	r24, Y+3	; 0x03
    12be:	9c 81       	ldd	r25, Y+4	; 0x04
    12c0:	41 96       	adiw	r24, 0x11	; 17
    12c2:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <xTaskRemoveFromEventList>
    12c6:	88 23       	and	r24, r24
    12c8:	61 f0       	breq	.+24     	; 0x12e2 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    12ca:	ef 81       	ldd	r30, Y+7	; 0x07
    12cc:	f8 85       	ldd	r31, Y+8	; 0x08
    12ce:	81 e0       	ldi	r24, 0x01	; 1
    12d0:	80 83       	st	Z, r24
    12d2:	07 c0       	rjmp	.+14     	; 0x12e2 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    12d4:	eb 81       	ldd	r30, Y+3	; 0x03
    12d6:	fc 81       	ldd	r31, Y+4	; 0x04
    12d8:	86 8d       	ldd	r24, Z+30	; 0x1e
    12da:	8f 5f       	subi	r24, 0xFF	; 255
    12dc:	eb 81       	ldd	r30, Y+3	; 0x03
    12de:	fc 81       	ldd	r31, Y+4	; 0x04
    12e0:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    12e2:	81 e0       	ldi	r24, 0x01	; 1
    12e4:	8a 83       	std	Y+2, r24	; 0x02
    12e6:	01 c0       	rjmp	.+2      	; 0x12ea <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    12e8:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    12ea:	8a 81       	ldd	r24, Y+2	; 0x02
}
    12ec:	29 96       	adiw	r28, 0x09	; 9
    12ee:	0f b6       	in	r0, 0x3f	; 63
    12f0:	f8 94       	cli
    12f2:	de bf       	out	0x3e, r29	; 62
    12f4:	0f be       	out	0x3f, r0	; 63
    12f6:	cd bf       	out	0x3d, r28	; 61
    12f8:	cf 91       	pop	r28
    12fa:	df 91       	pop	r29
    12fc:	08 95       	ret

000012fe <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    12fe:	df 93       	push	r29
    1300:	cf 93       	push	r28
    1302:	cd b7       	in	r28, 0x3d	; 61
    1304:	de b7       	in	r29, 0x3e	; 62
    1306:	2e 97       	sbiw	r28, 0x0e	; 14
    1308:	0f b6       	in	r0, 0x3f	; 63
    130a:	f8 94       	cli
    130c:	de bf       	out	0x3e, r29	; 62
    130e:	0f be       	out	0x3f, r0	; 63
    1310:	cd bf       	out	0x3d, r28	; 61
    1312:	98 87       	std	Y+8, r25	; 0x08
    1314:	8f 83       	std	Y+7, r24	; 0x07
    1316:	7a 87       	std	Y+10, r23	; 0x0a
    1318:	69 87       	std	Y+9, r22	; 0x09
    131a:	5c 87       	std	Y+12, r21	; 0x0c
    131c:	4b 87       	std	Y+11, r20	; 0x0b
    131e:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1320:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1322:	0f b6       	in	r0, 0x3f	; 63
    1324:	f8 94       	cli
    1326:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1328:	ef 81       	ldd	r30, Y+7	; 0x07
    132a:	f8 85       	ldd	r31, Y+8	; 0x08
    132c:	82 8d       	ldd	r24, Z+26	; 0x1a
    132e:	88 23       	and	r24, r24
    1330:	09 f4       	brne	.+2      	; 0x1334 <xQueueGenericReceive+0x36>
    1332:	3f c0       	rjmp	.+126    	; 0x13b2 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1334:	ef 81       	ldd	r30, Y+7	; 0x07
    1336:	f8 85       	ldd	r31, Y+8	; 0x08
    1338:	86 81       	ldd	r24, Z+6	; 0x06
    133a:	97 81       	ldd	r25, Z+7	; 0x07
    133c:	9a 83       	std	Y+2, r25	; 0x02
    133e:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1340:	8f 81       	ldd	r24, Y+7	; 0x07
    1342:	98 85       	ldd	r25, Y+8	; 0x08
    1344:	29 85       	ldd	r18, Y+9	; 0x09
    1346:	3a 85       	ldd	r19, Y+10	; 0x0a
    1348:	b9 01       	movw	r22, r18
    134a:	0e 94 64 0b 	call	0x16c8	; 0x16c8 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    134e:	8d 85       	ldd	r24, Y+13	; 0x0d
    1350:	88 23       	and	r24, r24
    1352:	b1 f4       	brne	.+44     	; 0x1380 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1354:	ef 81       	ldd	r30, Y+7	; 0x07
    1356:	f8 85       	ldd	r31, Y+8	; 0x08
    1358:	82 8d       	ldd	r24, Z+26	; 0x1a
    135a:	81 50       	subi	r24, 0x01	; 1
    135c:	ef 81       	ldd	r30, Y+7	; 0x07
    135e:	f8 85       	ldd	r31, Y+8	; 0x08
    1360:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1362:	ef 81       	ldd	r30, Y+7	; 0x07
    1364:	f8 85       	ldd	r31, Y+8	; 0x08
    1366:	80 85       	ldd	r24, Z+8	; 0x08
    1368:	88 23       	and	r24, r24
    136a:	f1 f0       	breq	.+60     	; 0x13a8 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    136c:	8f 81       	ldd	r24, Y+7	; 0x07
    136e:	98 85       	ldd	r25, Y+8	; 0x08
    1370:	08 96       	adiw	r24, 0x08	; 8
    1372:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <xTaskRemoveFromEventList>
    1376:	81 30       	cpi	r24, 0x01	; 1
    1378:	b9 f4       	brne	.+46     	; 0x13a8 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    137a:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <vPortYield>
    137e:	14 c0       	rjmp	.+40     	; 0x13a8 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1380:	ef 81       	ldd	r30, Y+7	; 0x07
    1382:	f8 85       	ldd	r31, Y+8	; 0x08
    1384:	89 81       	ldd	r24, Y+1	; 0x01
    1386:	9a 81       	ldd	r25, Y+2	; 0x02
    1388:	97 83       	std	Z+7, r25	; 0x07
    138a:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    138c:	ef 81       	ldd	r30, Y+7	; 0x07
    138e:	f8 85       	ldd	r31, Y+8	; 0x08
    1390:	81 89       	ldd	r24, Z+17	; 0x11
    1392:	88 23       	and	r24, r24
    1394:	49 f0       	breq	.+18     	; 0x13a8 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1396:	8f 81       	ldd	r24, Y+7	; 0x07
    1398:	98 85       	ldd	r25, Y+8	; 0x08
    139a:	41 96       	adiw	r24, 0x11	; 17
    139c:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <xTaskRemoveFromEventList>
    13a0:	88 23       	and	r24, r24
    13a2:	11 f0       	breq	.+4      	; 0x13a8 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    13a4:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    13a8:	0f 90       	pop	r0
    13aa:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    13ac:	81 e0       	ldi	r24, 0x01	; 1
    13ae:	8e 87       	std	Y+14, r24	; 0x0e
    13b0:	5c c0       	rjmp	.+184    	; 0x146a <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    13b2:	8b 85       	ldd	r24, Y+11	; 0x0b
    13b4:	9c 85       	ldd	r25, Y+12	; 0x0c
    13b6:	00 97       	sbiw	r24, 0x00	; 0
    13b8:	21 f4       	brne	.+8      	; 0x13c2 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    13ba:	0f 90       	pop	r0
    13bc:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    13be:	1e 86       	std	Y+14, r1	; 0x0e
    13c0:	54 c0       	rjmp	.+168    	; 0x146a <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    13c2:	8b 81       	ldd	r24, Y+3	; 0x03
    13c4:	88 23       	and	r24, r24
    13c6:	31 f4       	brne	.+12     	; 0x13d4 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    13c8:	ce 01       	movw	r24, r28
    13ca:	04 96       	adiw	r24, 0x04	; 4
    13cc:	0e 94 4c 11 	call	0x2298	; 0x2298 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    13d0:	81 e0       	ldi	r24, 0x01	; 1
    13d2:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    13d4:	0f 90       	pop	r0
    13d6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    13d8:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    13dc:	0f b6       	in	r0, 0x3f	; 63
    13de:	f8 94       	cli
    13e0:	0f 92       	push	r0
    13e2:	ef 81       	ldd	r30, Y+7	; 0x07
    13e4:	f8 85       	ldd	r31, Y+8	; 0x08
    13e6:	85 8d       	ldd	r24, Z+29	; 0x1d
    13e8:	8f 3f       	cpi	r24, 0xFF	; 255
    13ea:	19 f4       	brne	.+6      	; 0x13f2 <xQueueGenericReceive+0xf4>
    13ec:	ef 81       	ldd	r30, Y+7	; 0x07
    13ee:	f8 85       	ldd	r31, Y+8	; 0x08
    13f0:	15 8e       	std	Z+29, r1	; 0x1d
    13f2:	ef 81       	ldd	r30, Y+7	; 0x07
    13f4:	f8 85       	ldd	r31, Y+8	; 0x08
    13f6:	86 8d       	ldd	r24, Z+30	; 0x1e
    13f8:	8f 3f       	cpi	r24, 0xFF	; 255
    13fa:	19 f4       	brne	.+6      	; 0x1402 <xQueueGenericReceive+0x104>
    13fc:	ef 81       	ldd	r30, Y+7	; 0x07
    13fe:	f8 85       	ldd	r31, Y+8	; 0x08
    1400:	16 8e       	std	Z+30, r1	; 0x1e
    1402:	0f 90       	pop	r0
    1404:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1406:	ce 01       	movw	r24, r28
    1408:	04 96       	adiw	r24, 0x04	; 4
    140a:	9e 01       	movw	r18, r28
    140c:	25 5f       	subi	r18, 0xF5	; 245
    140e:	3f 4f       	sbci	r19, 0xFF	; 255
    1410:	b9 01       	movw	r22, r18
    1412:	0e 94 65 11 	call	0x22ca	; 0x22ca <xTaskCheckForTimeOut>
    1416:	88 23       	and	r24, r24
    1418:	09 f5       	brne	.+66     	; 0x145c <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    141a:	8f 81       	ldd	r24, Y+7	; 0x07
    141c:	98 85       	ldd	r25, Y+8	; 0x08
    141e:	0e 94 00 0c 	call	0x1800	; 0x1800 <prvIsQueueEmpty>
    1422:	88 23       	and	r24, r24
    1424:	a1 f0       	breq	.+40     	; 0x144e <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1426:	8f 81       	ldd	r24, Y+7	; 0x07
    1428:	98 85       	ldd	r25, Y+8	; 0x08
    142a:	41 96       	adiw	r24, 0x11	; 17
    142c:	2b 85       	ldd	r18, Y+11	; 0x0b
    142e:	3c 85       	ldd	r19, Y+12	; 0x0c
    1430:	b9 01       	movw	r22, r18
    1432:	0e 94 ae 10 	call	0x215c	; 0x215c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1436:	8f 81       	ldd	r24, Y+7	; 0x07
    1438:	98 85       	ldd	r25, Y+8	; 0x08
    143a:	0e 94 ac 0b 	call	0x1758	; 0x1758 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    143e:	0e 94 b4 0e 	call	0x1d68	; 0x1d68 <xTaskResumeAll>
    1442:	88 23       	and	r24, r24
    1444:	09 f0       	breq	.+2      	; 0x1448 <xQueueGenericReceive+0x14a>
    1446:	6d cf       	rjmp	.-294    	; 0x1322 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    1448:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <vPortYield>
    144c:	6a cf       	rjmp	.-300    	; 0x1322 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    144e:	8f 81       	ldd	r24, Y+7	; 0x07
    1450:	98 85       	ldd	r25, Y+8	; 0x08
    1452:	0e 94 ac 0b 	call	0x1758	; 0x1758 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1456:	0e 94 b4 0e 	call	0x1d68	; 0x1d68 <xTaskResumeAll>
    145a:	63 cf       	rjmp	.-314    	; 0x1322 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    145c:	8f 81       	ldd	r24, Y+7	; 0x07
    145e:	98 85       	ldd	r25, Y+8	; 0x08
    1460:	0e 94 ac 0b 	call	0x1758	; 0x1758 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1464:	0e 94 b4 0e 	call	0x1d68	; 0x1d68 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1468:	1e 86       	std	Y+14, r1	; 0x0e
    146a:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    146c:	2e 96       	adiw	r28, 0x0e	; 14
    146e:	0f b6       	in	r0, 0x3f	; 63
    1470:	f8 94       	cli
    1472:	de bf       	out	0x3e, r29	; 62
    1474:	0f be       	out	0x3f, r0	; 63
    1476:	cd bf       	out	0x3d, r28	; 61
    1478:	cf 91       	pop	r28
    147a:	df 91       	pop	r29
    147c:	08 95       	ret

0000147e <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    147e:	df 93       	push	r29
    1480:	cf 93       	push	r28
    1482:	cd b7       	in	r28, 0x3d	; 61
    1484:	de b7       	in	r29, 0x3e	; 62
    1486:	28 97       	sbiw	r28, 0x08	; 8
    1488:	0f b6       	in	r0, 0x3f	; 63
    148a:	f8 94       	cli
    148c:	de bf       	out	0x3e, r29	; 62
    148e:	0f be       	out	0x3f, r0	; 63
    1490:	cd bf       	out	0x3d, r28	; 61
    1492:	9c 83       	std	Y+4, r25	; 0x04
    1494:	8b 83       	std	Y+3, r24	; 0x03
    1496:	7e 83       	std	Y+6, r23	; 0x06
    1498:	6d 83       	std	Y+5, r22	; 0x05
    149a:	58 87       	std	Y+8, r21	; 0x08
    149c:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    149e:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    14a0:	eb 81       	ldd	r30, Y+3	; 0x03
    14a2:	fc 81       	ldd	r31, Y+4	; 0x04
    14a4:	82 8d       	ldd	r24, Z+26	; 0x1a
    14a6:	88 23       	and	r24, r24
    14a8:	71 f1       	breq	.+92     	; 0x1506 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    14aa:	8b 81       	ldd	r24, Y+3	; 0x03
    14ac:	9c 81       	ldd	r25, Y+4	; 0x04
    14ae:	2d 81       	ldd	r18, Y+5	; 0x05
    14b0:	3e 81       	ldd	r19, Y+6	; 0x06
    14b2:	b9 01       	movw	r22, r18
    14b4:	0e 94 64 0b 	call	0x16c8	; 0x16c8 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    14b8:	eb 81       	ldd	r30, Y+3	; 0x03
    14ba:	fc 81       	ldd	r31, Y+4	; 0x04
    14bc:	82 8d       	ldd	r24, Z+26	; 0x1a
    14be:	81 50       	subi	r24, 0x01	; 1
    14c0:	eb 81       	ldd	r30, Y+3	; 0x03
    14c2:	fc 81       	ldd	r31, Y+4	; 0x04
    14c4:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    14c6:	eb 81       	ldd	r30, Y+3	; 0x03
    14c8:	fc 81       	ldd	r31, Y+4	; 0x04
    14ca:	85 8d       	ldd	r24, Z+29	; 0x1d
    14cc:	8f 3f       	cpi	r24, 0xFF	; 255
    14ce:	89 f4       	brne	.+34     	; 0x14f2 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    14d0:	eb 81       	ldd	r30, Y+3	; 0x03
    14d2:	fc 81       	ldd	r31, Y+4	; 0x04
    14d4:	80 85       	ldd	r24, Z+8	; 0x08
    14d6:	88 23       	and	r24, r24
    14d8:	99 f0       	breq	.+38     	; 0x1500 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    14da:	8b 81       	ldd	r24, Y+3	; 0x03
    14dc:	9c 81       	ldd	r25, Y+4	; 0x04
    14de:	08 96       	adiw	r24, 0x08	; 8
    14e0:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <xTaskRemoveFromEventList>
    14e4:	88 23       	and	r24, r24
    14e6:	61 f0       	breq	.+24     	; 0x1500 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    14e8:	ef 81       	ldd	r30, Y+7	; 0x07
    14ea:	f8 85       	ldd	r31, Y+8	; 0x08
    14ec:	81 e0       	ldi	r24, 0x01	; 1
    14ee:	80 83       	st	Z, r24
    14f0:	07 c0       	rjmp	.+14     	; 0x1500 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    14f2:	eb 81       	ldd	r30, Y+3	; 0x03
    14f4:	fc 81       	ldd	r31, Y+4	; 0x04
    14f6:	85 8d       	ldd	r24, Z+29	; 0x1d
    14f8:	8f 5f       	subi	r24, 0xFF	; 255
    14fa:	eb 81       	ldd	r30, Y+3	; 0x03
    14fc:	fc 81       	ldd	r31, Y+4	; 0x04
    14fe:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1500:	81 e0       	ldi	r24, 0x01	; 1
    1502:	8a 83       	std	Y+2, r24	; 0x02
    1504:	01 c0       	rjmp	.+2      	; 0x1508 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    1506:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1508:	8a 81       	ldd	r24, Y+2	; 0x02
}
    150a:	28 96       	adiw	r28, 0x08	; 8
    150c:	0f b6       	in	r0, 0x3f	; 63
    150e:	f8 94       	cli
    1510:	de bf       	out	0x3e, r29	; 62
    1512:	0f be       	out	0x3f, r0	; 63
    1514:	cd bf       	out	0x3d, r28	; 61
    1516:	cf 91       	pop	r28
    1518:	df 91       	pop	r29
    151a:	08 95       	ret

0000151c <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    151c:	df 93       	push	r29
    151e:	cf 93       	push	r28
    1520:	00 d0       	rcall	.+0      	; 0x1522 <uxQueueMessagesWaiting+0x6>
    1522:	0f 92       	push	r0
    1524:	cd b7       	in	r28, 0x3d	; 61
    1526:	de b7       	in	r29, 0x3e	; 62
    1528:	9b 83       	std	Y+3, r25	; 0x03
    152a:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    152c:	0f b6       	in	r0, 0x3f	; 63
    152e:	f8 94       	cli
    1530:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1532:	ea 81       	ldd	r30, Y+2	; 0x02
    1534:	fb 81       	ldd	r31, Y+3	; 0x03
    1536:	82 8d       	ldd	r24, Z+26	; 0x1a
    1538:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    153a:	0f 90       	pop	r0
    153c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    153e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1540:	0f 90       	pop	r0
    1542:	0f 90       	pop	r0
    1544:	0f 90       	pop	r0
    1546:	cf 91       	pop	r28
    1548:	df 91       	pop	r29
    154a:	08 95       	ret

0000154c <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    154c:	df 93       	push	r29
    154e:	cf 93       	push	r28
    1550:	00 d0       	rcall	.+0      	; 0x1552 <uxQueueMessagesWaitingFromISR+0x6>
    1552:	0f 92       	push	r0
    1554:	cd b7       	in	r28, 0x3d	; 61
    1556:	de b7       	in	r29, 0x3e	; 62
    1558:	9b 83       	std	Y+3, r25	; 0x03
    155a:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    155c:	ea 81       	ldd	r30, Y+2	; 0x02
    155e:	fb 81       	ldd	r31, Y+3	; 0x03
    1560:	82 8d       	ldd	r24, Z+26	; 0x1a
    1562:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    1564:	89 81       	ldd	r24, Y+1	; 0x01
}
    1566:	0f 90       	pop	r0
    1568:	0f 90       	pop	r0
    156a:	0f 90       	pop	r0
    156c:	cf 91       	pop	r28
    156e:	df 91       	pop	r29
    1570:	08 95       	ret

00001572 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1572:	df 93       	push	r29
    1574:	cf 93       	push	r28
    1576:	00 d0       	rcall	.+0      	; 0x1578 <vQueueDelete+0x6>
    1578:	cd b7       	in	r28, 0x3d	; 61
    157a:	de b7       	in	r29, 0x3e	; 62
    157c:	9a 83       	std	Y+2, r25	; 0x02
    157e:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1580:	e9 81       	ldd	r30, Y+1	; 0x01
    1582:	fa 81       	ldd	r31, Y+2	; 0x02
    1584:	80 81       	ld	r24, Z
    1586:	91 81       	ldd	r25, Z+1	; 0x01
    1588:	0e 94 b8 03 	call	0x770	; 0x770 <vPortFree>
	vPortFree( pxQueue );
    158c:	89 81       	ldd	r24, Y+1	; 0x01
    158e:	9a 81       	ldd	r25, Y+2	; 0x02
    1590:	0e 94 b8 03 	call	0x770	; 0x770 <vPortFree>
}
    1594:	0f 90       	pop	r0
    1596:	0f 90       	pop	r0
    1598:	cf 91       	pop	r28
    159a:	df 91       	pop	r29
    159c:	08 95       	ret

0000159e <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    159e:	df 93       	push	r29
    15a0:	cf 93       	push	r28
    15a2:	00 d0       	rcall	.+0      	; 0x15a4 <prvCopyDataToQueue+0x6>
    15a4:	00 d0       	rcall	.+0      	; 0x15a6 <prvCopyDataToQueue+0x8>
    15a6:	0f 92       	push	r0
    15a8:	cd b7       	in	r28, 0x3d	; 61
    15aa:	de b7       	in	r29, 0x3e	; 62
    15ac:	9a 83       	std	Y+2, r25	; 0x02
    15ae:	89 83       	std	Y+1, r24	; 0x01
    15b0:	7c 83       	std	Y+4, r23	; 0x04
    15b2:	6b 83       	std	Y+3, r22	; 0x03
    15b4:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    15b6:	e9 81       	ldd	r30, Y+1	; 0x01
    15b8:	fa 81       	ldd	r31, Y+2	; 0x02
    15ba:	84 8d       	ldd	r24, Z+28	; 0x1c
    15bc:	88 23       	and	r24, r24
    15be:	09 f4       	brne	.+2      	; 0x15c2 <prvCopyDataToQueue+0x24>
    15c0:	74 c0       	rjmp	.+232    	; 0x16aa <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    15c2:	8d 81       	ldd	r24, Y+5	; 0x05
    15c4:	88 23       	and	r24, r24
    15c6:	99 f5       	brne	.+102    	; 0x162e <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    15c8:	e9 81       	ldd	r30, Y+1	; 0x01
    15ca:	fa 81       	ldd	r31, Y+2	; 0x02
    15cc:	64 81       	ldd	r22, Z+4	; 0x04
    15ce:	75 81       	ldd	r23, Z+5	; 0x05
    15d0:	e9 81       	ldd	r30, Y+1	; 0x01
    15d2:	fa 81       	ldd	r31, Y+2	; 0x02
    15d4:	84 8d       	ldd	r24, Z+28	; 0x1c
    15d6:	48 2f       	mov	r20, r24
    15d8:	50 e0       	ldi	r21, 0x00	; 0
    15da:	2b 81       	ldd	r18, Y+3	; 0x03
    15dc:	3c 81       	ldd	r19, Y+4	; 0x04
    15de:	cb 01       	movw	r24, r22
    15e0:	b9 01       	movw	r22, r18
    15e2:	0e 94 57 13 	call	0x26ae	; 0x26ae <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    15e6:	e9 81       	ldd	r30, Y+1	; 0x01
    15e8:	fa 81       	ldd	r31, Y+2	; 0x02
    15ea:	24 81       	ldd	r18, Z+4	; 0x04
    15ec:	35 81       	ldd	r19, Z+5	; 0x05
    15ee:	e9 81       	ldd	r30, Y+1	; 0x01
    15f0:	fa 81       	ldd	r31, Y+2	; 0x02
    15f2:	84 8d       	ldd	r24, Z+28	; 0x1c
    15f4:	88 2f       	mov	r24, r24
    15f6:	90 e0       	ldi	r25, 0x00	; 0
    15f8:	82 0f       	add	r24, r18
    15fa:	93 1f       	adc	r25, r19
    15fc:	e9 81       	ldd	r30, Y+1	; 0x01
    15fe:	fa 81       	ldd	r31, Y+2	; 0x02
    1600:	95 83       	std	Z+5, r25	; 0x05
    1602:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1604:	e9 81       	ldd	r30, Y+1	; 0x01
    1606:	fa 81       	ldd	r31, Y+2	; 0x02
    1608:	24 81       	ldd	r18, Z+4	; 0x04
    160a:	35 81       	ldd	r19, Z+5	; 0x05
    160c:	e9 81       	ldd	r30, Y+1	; 0x01
    160e:	fa 81       	ldd	r31, Y+2	; 0x02
    1610:	82 81       	ldd	r24, Z+2	; 0x02
    1612:	93 81       	ldd	r25, Z+3	; 0x03
    1614:	28 17       	cp	r18, r24
    1616:	39 07       	cpc	r19, r25
    1618:	08 f4       	brcc	.+2      	; 0x161c <prvCopyDataToQueue+0x7e>
    161a:	47 c0       	rjmp	.+142    	; 0x16aa <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    161c:	e9 81       	ldd	r30, Y+1	; 0x01
    161e:	fa 81       	ldd	r31, Y+2	; 0x02
    1620:	80 81       	ld	r24, Z
    1622:	91 81       	ldd	r25, Z+1	; 0x01
    1624:	e9 81       	ldd	r30, Y+1	; 0x01
    1626:	fa 81       	ldd	r31, Y+2	; 0x02
    1628:	95 83       	std	Z+5, r25	; 0x05
    162a:	84 83       	std	Z+4, r24	; 0x04
    162c:	3e c0       	rjmp	.+124    	; 0x16aa <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    162e:	e9 81       	ldd	r30, Y+1	; 0x01
    1630:	fa 81       	ldd	r31, Y+2	; 0x02
    1632:	66 81       	ldd	r22, Z+6	; 0x06
    1634:	77 81       	ldd	r23, Z+7	; 0x07
    1636:	e9 81       	ldd	r30, Y+1	; 0x01
    1638:	fa 81       	ldd	r31, Y+2	; 0x02
    163a:	84 8d       	ldd	r24, Z+28	; 0x1c
    163c:	48 2f       	mov	r20, r24
    163e:	50 e0       	ldi	r21, 0x00	; 0
    1640:	2b 81       	ldd	r18, Y+3	; 0x03
    1642:	3c 81       	ldd	r19, Y+4	; 0x04
    1644:	cb 01       	movw	r24, r22
    1646:	b9 01       	movw	r22, r18
    1648:	0e 94 57 13 	call	0x26ae	; 0x26ae <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    164c:	e9 81       	ldd	r30, Y+1	; 0x01
    164e:	fa 81       	ldd	r31, Y+2	; 0x02
    1650:	26 81       	ldd	r18, Z+6	; 0x06
    1652:	37 81       	ldd	r19, Z+7	; 0x07
    1654:	e9 81       	ldd	r30, Y+1	; 0x01
    1656:	fa 81       	ldd	r31, Y+2	; 0x02
    1658:	84 8d       	ldd	r24, Z+28	; 0x1c
    165a:	88 2f       	mov	r24, r24
    165c:	90 e0       	ldi	r25, 0x00	; 0
    165e:	90 95       	com	r25
    1660:	81 95       	neg	r24
    1662:	9f 4f       	sbci	r25, 0xFF	; 255
    1664:	82 0f       	add	r24, r18
    1666:	93 1f       	adc	r25, r19
    1668:	e9 81       	ldd	r30, Y+1	; 0x01
    166a:	fa 81       	ldd	r31, Y+2	; 0x02
    166c:	97 83       	std	Z+7, r25	; 0x07
    166e:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1670:	e9 81       	ldd	r30, Y+1	; 0x01
    1672:	fa 81       	ldd	r31, Y+2	; 0x02
    1674:	26 81       	ldd	r18, Z+6	; 0x06
    1676:	37 81       	ldd	r19, Z+7	; 0x07
    1678:	e9 81       	ldd	r30, Y+1	; 0x01
    167a:	fa 81       	ldd	r31, Y+2	; 0x02
    167c:	80 81       	ld	r24, Z
    167e:	91 81       	ldd	r25, Z+1	; 0x01
    1680:	28 17       	cp	r18, r24
    1682:	39 07       	cpc	r19, r25
    1684:	90 f4       	brcc	.+36     	; 0x16aa <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1686:	e9 81       	ldd	r30, Y+1	; 0x01
    1688:	fa 81       	ldd	r31, Y+2	; 0x02
    168a:	22 81       	ldd	r18, Z+2	; 0x02
    168c:	33 81       	ldd	r19, Z+3	; 0x03
    168e:	e9 81       	ldd	r30, Y+1	; 0x01
    1690:	fa 81       	ldd	r31, Y+2	; 0x02
    1692:	84 8d       	ldd	r24, Z+28	; 0x1c
    1694:	88 2f       	mov	r24, r24
    1696:	90 e0       	ldi	r25, 0x00	; 0
    1698:	90 95       	com	r25
    169a:	81 95       	neg	r24
    169c:	9f 4f       	sbci	r25, 0xFF	; 255
    169e:	82 0f       	add	r24, r18
    16a0:	93 1f       	adc	r25, r19
    16a2:	e9 81       	ldd	r30, Y+1	; 0x01
    16a4:	fa 81       	ldd	r31, Y+2	; 0x02
    16a6:	97 83       	std	Z+7, r25	; 0x07
    16a8:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    16aa:	e9 81       	ldd	r30, Y+1	; 0x01
    16ac:	fa 81       	ldd	r31, Y+2	; 0x02
    16ae:	82 8d       	ldd	r24, Z+26	; 0x1a
    16b0:	8f 5f       	subi	r24, 0xFF	; 255
    16b2:	e9 81       	ldd	r30, Y+1	; 0x01
    16b4:	fa 81       	ldd	r31, Y+2	; 0x02
    16b6:	82 8f       	std	Z+26, r24	; 0x1a
}
    16b8:	0f 90       	pop	r0
    16ba:	0f 90       	pop	r0
    16bc:	0f 90       	pop	r0
    16be:	0f 90       	pop	r0
    16c0:	0f 90       	pop	r0
    16c2:	cf 91       	pop	r28
    16c4:	df 91       	pop	r29
    16c6:	08 95       	ret

000016c8 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    16c8:	df 93       	push	r29
    16ca:	cf 93       	push	r28
    16cc:	00 d0       	rcall	.+0      	; 0x16ce <prvCopyDataFromQueue+0x6>
    16ce:	00 d0       	rcall	.+0      	; 0x16d0 <prvCopyDataFromQueue+0x8>
    16d0:	cd b7       	in	r28, 0x3d	; 61
    16d2:	de b7       	in	r29, 0x3e	; 62
    16d4:	9a 83       	std	Y+2, r25	; 0x02
    16d6:	89 83       	std	Y+1, r24	; 0x01
    16d8:	7c 83       	std	Y+4, r23	; 0x04
    16da:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    16dc:	e9 81       	ldd	r30, Y+1	; 0x01
    16de:	fa 81       	ldd	r31, Y+2	; 0x02
    16e0:	80 81       	ld	r24, Z
    16e2:	91 81       	ldd	r25, Z+1	; 0x01
    16e4:	00 97       	sbiw	r24, 0x00	; 0
    16e6:	89 f1       	breq	.+98     	; 0x174a <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    16e8:	e9 81       	ldd	r30, Y+1	; 0x01
    16ea:	fa 81       	ldd	r31, Y+2	; 0x02
    16ec:	26 81       	ldd	r18, Z+6	; 0x06
    16ee:	37 81       	ldd	r19, Z+7	; 0x07
    16f0:	e9 81       	ldd	r30, Y+1	; 0x01
    16f2:	fa 81       	ldd	r31, Y+2	; 0x02
    16f4:	84 8d       	ldd	r24, Z+28	; 0x1c
    16f6:	88 2f       	mov	r24, r24
    16f8:	90 e0       	ldi	r25, 0x00	; 0
    16fa:	82 0f       	add	r24, r18
    16fc:	93 1f       	adc	r25, r19
    16fe:	e9 81       	ldd	r30, Y+1	; 0x01
    1700:	fa 81       	ldd	r31, Y+2	; 0x02
    1702:	97 83       	std	Z+7, r25	; 0x07
    1704:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1706:	e9 81       	ldd	r30, Y+1	; 0x01
    1708:	fa 81       	ldd	r31, Y+2	; 0x02
    170a:	26 81       	ldd	r18, Z+6	; 0x06
    170c:	37 81       	ldd	r19, Z+7	; 0x07
    170e:	e9 81       	ldd	r30, Y+1	; 0x01
    1710:	fa 81       	ldd	r31, Y+2	; 0x02
    1712:	82 81       	ldd	r24, Z+2	; 0x02
    1714:	93 81       	ldd	r25, Z+3	; 0x03
    1716:	28 17       	cp	r18, r24
    1718:	39 07       	cpc	r19, r25
    171a:	40 f0       	brcs	.+16     	; 0x172c <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    171c:	e9 81       	ldd	r30, Y+1	; 0x01
    171e:	fa 81       	ldd	r31, Y+2	; 0x02
    1720:	80 81       	ld	r24, Z
    1722:	91 81       	ldd	r25, Z+1	; 0x01
    1724:	e9 81       	ldd	r30, Y+1	; 0x01
    1726:	fa 81       	ldd	r31, Y+2	; 0x02
    1728:	97 83       	std	Z+7, r25	; 0x07
    172a:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    172c:	e9 81       	ldd	r30, Y+1	; 0x01
    172e:	fa 81       	ldd	r31, Y+2	; 0x02
    1730:	46 81       	ldd	r20, Z+6	; 0x06
    1732:	57 81       	ldd	r21, Z+7	; 0x07
    1734:	e9 81       	ldd	r30, Y+1	; 0x01
    1736:	fa 81       	ldd	r31, Y+2	; 0x02
    1738:	84 8d       	ldd	r24, Z+28	; 0x1c
    173a:	28 2f       	mov	r18, r24
    173c:	30 e0       	ldi	r19, 0x00	; 0
    173e:	8b 81       	ldd	r24, Y+3	; 0x03
    1740:	9c 81       	ldd	r25, Y+4	; 0x04
    1742:	ba 01       	movw	r22, r20
    1744:	a9 01       	movw	r20, r18
    1746:	0e 94 57 13 	call	0x26ae	; 0x26ae <memcpy>
	}
}
    174a:	0f 90       	pop	r0
    174c:	0f 90       	pop	r0
    174e:	0f 90       	pop	r0
    1750:	0f 90       	pop	r0
    1752:	cf 91       	pop	r28
    1754:	df 91       	pop	r29
    1756:	08 95       	ret

00001758 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1758:	df 93       	push	r29
    175a:	cf 93       	push	r28
    175c:	00 d0       	rcall	.+0      	; 0x175e <prvUnlockQueue+0x6>
    175e:	cd b7       	in	r28, 0x3d	; 61
    1760:	de b7       	in	r29, 0x3e	; 62
    1762:	9a 83       	std	Y+2, r25	; 0x02
    1764:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1766:	0f b6       	in	r0, 0x3f	; 63
    1768:	f8 94       	cli
    176a:	0f 92       	push	r0
    176c:	15 c0       	rjmp	.+42     	; 0x1798 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    176e:	e9 81       	ldd	r30, Y+1	; 0x01
    1770:	fa 81       	ldd	r31, Y+2	; 0x02
    1772:	81 89       	ldd	r24, Z+17	; 0x11
    1774:	88 23       	and	r24, r24
    1776:	a9 f0       	breq	.+42     	; 0x17a2 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1778:	89 81       	ldd	r24, Y+1	; 0x01
    177a:	9a 81       	ldd	r25, Y+2	; 0x02
    177c:	41 96       	adiw	r24, 0x11	; 17
    177e:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <xTaskRemoveFromEventList>
    1782:	88 23       	and	r24, r24
    1784:	11 f0       	breq	.+4      	; 0x178a <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    1786:	0e 94 c2 11 	call	0x2384	; 0x2384 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    178a:	e9 81       	ldd	r30, Y+1	; 0x01
    178c:	fa 81       	ldd	r31, Y+2	; 0x02
    178e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1790:	81 50       	subi	r24, 0x01	; 1
    1792:	e9 81       	ldd	r30, Y+1	; 0x01
    1794:	fa 81       	ldd	r31, Y+2	; 0x02
    1796:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1798:	e9 81       	ldd	r30, Y+1	; 0x01
    179a:	fa 81       	ldd	r31, Y+2	; 0x02
    179c:	86 8d       	ldd	r24, Z+30	; 0x1e
    179e:	18 16       	cp	r1, r24
    17a0:	34 f3       	brlt	.-52     	; 0x176e <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    17a2:	e9 81       	ldd	r30, Y+1	; 0x01
    17a4:	fa 81       	ldd	r31, Y+2	; 0x02
    17a6:	8f ef       	ldi	r24, 0xFF	; 255
    17a8:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    17aa:	0f 90       	pop	r0
    17ac:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    17ae:	0f b6       	in	r0, 0x3f	; 63
    17b0:	f8 94       	cli
    17b2:	0f 92       	push	r0
    17b4:	15 c0       	rjmp	.+42     	; 0x17e0 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    17b6:	e9 81       	ldd	r30, Y+1	; 0x01
    17b8:	fa 81       	ldd	r31, Y+2	; 0x02
    17ba:	80 85       	ldd	r24, Z+8	; 0x08
    17bc:	88 23       	and	r24, r24
    17be:	a9 f0       	breq	.+42     	; 0x17ea <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    17c0:	89 81       	ldd	r24, Y+1	; 0x01
    17c2:	9a 81       	ldd	r25, Y+2	; 0x02
    17c4:	08 96       	adiw	r24, 0x08	; 8
    17c6:	0e 94 e4 10 	call	0x21c8	; 0x21c8 <xTaskRemoveFromEventList>
    17ca:	88 23       	and	r24, r24
    17cc:	11 f0       	breq	.+4      	; 0x17d2 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    17ce:	0e 94 c2 11 	call	0x2384	; 0x2384 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    17d2:	e9 81       	ldd	r30, Y+1	; 0x01
    17d4:	fa 81       	ldd	r31, Y+2	; 0x02
    17d6:	85 8d       	ldd	r24, Z+29	; 0x1d
    17d8:	81 50       	subi	r24, 0x01	; 1
    17da:	e9 81       	ldd	r30, Y+1	; 0x01
    17dc:	fa 81       	ldd	r31, Y+2	; 0x02
    17de:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    17e0:	e9 81       	ldd	r30, Y+1	; 0x01
    17e2:	fa 81       	ldd	r31, Y+2	; 0x02
    17e4:	85 8d       	ldd	r24, Z+29	; 0x1d
    17e6:	18 16       	cp	r1, r24
    17e8:	34 f3       	brlt	.-52     	; 0x17b6 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    17ea:	e9 81       	ldd	r30, Y+1	; 0x01
    17ec:	fa 81       	ldd	r31, Y+2	; 0x02
    17ee:	8f ef       	ldi	r24, 0xFF	; 255
    17f0:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    17f2:	0f 90       	pop	r0
    17f4:	0f be       	out	0x3f, r0	; 63
}
    17f6:	0f 90       	pop	r0
    17f8:	0f 90       	pop	r0
    17fa:	cf 91       	pop	r28
    17fc:	df 91       	pop	r29
    17fe:	08 95       	ret

00001800 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    1800:	df 93       	push	r29
    1802:	cf 93       	push	r28
    1804:	00 d0       	rcall	.+0      	; 0x1806 <prvIsQueueEmpty+0x6>
    1806:	0f 92       	push	r0
    1808:	cd b7       	in	r28, 0x3d	; 61
    180a:	de b7       	in	r29, 0x3e	; 62
    180c:	9b 83       	std	Y+3, r25	; 0x03
    180e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1810:	0f b6       	in	r0, 0x3f	; 63
    1812:	f8 94       	cli
    1814:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1816:	ea 81       	ldd	r30, Y+2	; 0x02
    1818:	fb 81       	ldd	r31, Y+3	; 0x03
    181a:	82 8d       	ldd	r24, Z+26	; 0x1a
    181c:	19 82       	std	Y+1, r1	; 0x01
    181e:	88 23       	and	r24, r24
    1820:	11 f4       	brne	.+4      	; 0x1826 <prvIsQueueEmpty+0x26>
    1822:	81 e0       	ldi	r24, 0x01	; 1
    1824:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1826:	0f 90       	pop	r0
    1828:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    182a:	89 81       	ldd	r24, Y+1	; 0x01
}
    182c:	0f 90       	pop	r0
    182e:	0f 90       	pop	r0
    1830:	0f 90       	pop	r0
    1832:	cf 91       	pop	r28
    1834:	df 91       	pop	r29
    1836:	08 95       	ret

00001838 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    1838:	df 93       	push	r29
    183a:	cf 93       	push	r28
    183c:	00 d0       	rcall	.+0      	; 0x183e <xQueueIsQueueEmptyFromISR+0x6>
    183e:	0f 92       	push	r0
    1840:	cd b7       	in	r28, 0x3d	; 61
    1842:	de b7       	in	r29, 0x3e	; 62
    1844:	9b 83       	std	Y+3, r25	; 0x03
    1846:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1848:	ea 81       	ldd	r30, Y+2	; 0x02
    184a:	fb 81       	ldd	r31, Y+3	; 0x03
    184c:	82 8d       	ldd	r24, Z+26	; 0x1a
    184e:	19 82       	std	Y+1, r1	; 0x01
    1850:	88 23       	and	r24, r24
    1852:	11 f4       	brne	.+4      	; 0x1858 <xQueueIsQueueEmptyFromISR+0x20>
    1854:	81 e0       	ldi	r24, 0x01	; 1
    1856:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    1858:	89 81       	ldd	r24, Y+1	; 0x01
}
    185a:	0f 90       	pop	r0
    185c:	0f 90       	pop	r0
    185e:	0f 90       	pop	r0
    1860:	cf 91       	pop	r28
    1862:	df 91       	pop	r29
    1864:	08 95       	ret

00001866 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    1866:	df 93       	push	r29
    1868:	cf 93       	push	r28
    186a:	00 d0       	rcall	.+0      	; 0x186c <prvIsQueueFull+0x6>
    186c:	0f 92       	push	r0
    186e:	cd b7       	in	r28, 0x3d	; 61
    1870:	de b7       	in	r29, 0x3e	; 62
    1872:	9b 83       	std	Y+3, r25	; 0x03
    1874:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1876:	0f b6       	in	r0, 0x3f	; 63
    1878:	f8 94       	cli
    187a:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    187c:	ea 81       	ldd	r30, Y+2	; 0x02
    187e:	fb 81       	ldd	r31, Y+3	; 0x03
    1880:	92 8d       	ldd	r25, Z+26	; 0x1a
    1882:	ea 81       	ldd	r30, Y+2	; 0x02
    1884:	fb 81       	ldd	r31, Y+3	; 0x03
    1886:	83 8d       	ldd	r24, Z+27	; 0x1b
    1888:	19 82       	std	Y+1, r1	; 0x01
    188a:	98 17       	cp	r25, r24
    188c:	11 f4       	brne	.+4      	; 0x1892 <prvIsQueueFull+0x2c>
    188e:	81 e0       	ldi	r24, 0x01	; 1
    1890:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1892:	0f 90       	pop	r0
    1894:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1896:	89 81       	ldd	r24, Y+1	; 0x01
}
    1898:	0f 90       	pop	r0
    189a:	0f 90       	pop	r0
    189c:	0f 90       	pop	r0
    189e:	cf 91       	pop	r28
    18a0:	df 91       	pop	r29
    18a2:	08 95       	ret

000018a4 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    18a4:	df 93       	push	r29
    18a6:	cf 93       	push	r28
    18a8:	00 d0       	rcall	.+0      	; 0x18aa <xQueueIsQueueFullFromISR+0x6>
    18aa:	0f 92       	push	r0
    18ac:	cd b7       	in	r28, 0x3d	; 61
    18ae:	de b7       	in	r29, 0x3e	; 62
    18b0:	9b 83       	std	Y+3, r25	; 0x03
    18b2:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    18b4:	ea 81       	ldd	r30, Y+2	; 0x02
    18b6:	fb 81       	ldd	r31, Y+3	; 0x03
    18b8:	92 8d       	ldd	r25, Z+26	; 0x1a
    18ba:	ea 81       	ldd	r30, Y+2	; 0x02
    18bc:	fb 81       	ldd	r31, Y+3	; 0x03
    18be:	83 8d       	ldd	r24, Z+27	; 0x1b
    18c0:	19 82       	std	Y+1, r1	; 0x01
    18c2:	98 17       	cp	r25, r24
    18c4:	11 f4       	brne	.+4      	; 0x18ca <xQueueIsQueueFullFromISR+0x26>
    18c6:	81 e0       	ldi	r24, 0x01	; 1
    18c8:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    18ca:	89 81       	ldd	r24, Y+1	; 0x01
}
    18cc:	0f 90       	pop	r0
    18ce:	0f 90       	pop	r0
    18d0:	0f 90       	pop	r0
    18d2:	cf 91       	pop	r28
    18d4:	df 91       	pop	r29
    18d6:	08 95       	ret

000018d8 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    18d8:	af 92       	push	r10
    18da:	bf 92       	push	r11
    18dc:	cf 92       	push	r12
    18de:	df 92       	push	r13
    18e0:	ef 92       	push	r14
    18e2:	ff 92       	push	r15
    18e4:	0f 93       	push	r16
    18e6:	1f 93       	push	r17
    18e8:	df 93       	push	r29
    18ea:	cf 93       	push	r28
    18ec:	cd b7       	in	r28, 0x3d	; 61
    18ee:	de b7       	in	r29, 0x3e	; 62
    18f0:	64 97       	sbiw	r28, 0x14	; 20
    18f2:	0f b6       	in	r0, 0x3f	; 63
    18f4:	f8 94       	cli
    18f6:	de bf       	out	0x3e, r29	; 62
    18f8:	0f be       	out	0x3f, r0	; 63
    18fa:	cd bf       	out	0x3d, r28	; 61
    18fc:	9f 83       	std	Y+7, r25	; 0x07
    18fe:	8e 83       	std	Y+6, r24	; 0x06
    1900:	79 87       	std	Y+9, r23	; 0x09
    1902:	68 87       	std	Y+8, r22	; 0x08
    1904:	5b 87       	std	Y+11, r21	; 0x0b
    1906:	4a 87       	std	Y+10, r20	; 0x0a
    1908:	3d 87       	std	Y+13, r19	; 0x0d
    190a:	2c 87       	std	Y+12, r18	; 0x0c
    190c:	0e 87       	std	Y+14, r16	; 0x0e
    190e:	f8 8a       	std	Y+16, r15	; 0x10
    1910:	ef 86       	std	Y+15, r14	; 0x0f
    1912:	da 8a       	std	Y+18, r13	; 0x12
    1914:	c9 8a       	std	Y+17, r12	; 0x11
    1916:	bc 8a       	std	Y+20, r11	; 0x14
    1918:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    191a:	8a 85       	ldd	r24, Y+10	; 0x0a
    191c:	9b 85       	ldd	r25, Y+11	; 0x0b
    191e:	29 89       	ldd	r18, Y+17	; 0x11
    1920:	3a 89       	ldd	r19, Y+18	; 0x12
    1922:	b9 01       	movw	r22, r18
    1924:	0e 94 f1 12 	call	0x25e2	; 0x25e2 <prvAllocateTCBAndStack>
    1928:	9c 83       	std	Y+4, r25	; 0x04
    192a:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    192c:	8b 81       	ldd	r24, Y+3	; 0x03
    192e:	9c 81       	ldd	r25, Y+4	; 0x04
    1930:	00 97       	sbiw	r24, 0x00	; 0
    1932:	09 f4       	brne	.+2      	; 0x1936 <xTaskGenericCreate+0x5e>
    1934:	99 c0       	rjmp	.+306    	; 0x1a68 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1936:	eb 81       	ldd	r30, Y+3	; 0x03
    1938:	fc 81       	ldd	r31, Y+4	; 0x04
    193a:	27 89       	ldd	r18, Z+23	; 0x17
    193c:	30 8d       	ldd	r19, Z+24	; 0x18
    193e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1940:	9b 85       	ldd	r25, Y+11	; 0x0b
    1942:	01 97       	sbiw	r24, 0x01	; 1
    1944:	82 0f       	add	r24, r18
    1946:	93 1f       	adc	r25, r19
    1948:	9a 83       	std	Y+2, r25	; 0x02
    194a:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    194c:	8b 81       	ldd	r24, Y+3	; 0x03
    194e:	9c 81       	ldd	r25, Y+4	; 0x04
    1950:	28 85       	ldd	r18, Y+8	; 0x08
    1952:	39 85       	ldd	r19, Y+9	; 0x09
    1954:	eb 89       	ldd	r30, Y+19	; 0x13
    1956:	fc 89       	ldd	r31, Y+20	; 0x14
    1958:	aa 85       	ldd	r26, Y+10	; 0x0a
    195a:	bb 85       	ldd	r27, Y+11	; 0x0b
    195c:	b9 01       	movw	r22, r18
    195e:	4e 85       	ldd	r20, Y+14	; 0x0e
    1960:	9f 01       	movw	r18, r30
    1962:	8d 01       	movw	r16, r26
    1964:	0e 94 d6 11 	call	0x23ac	; 0x23ac <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1968:	89 81       	ldd	r24, Y+1	; 0x01
    196a:	9a 81       	ldd	r25, Y+2	; 0x02
    196c:	2e 81       	ldd	r18, Y+6	; 0x06
    196e:	3f 81       	ldd	r19, Y+7	; 0x07
    1970:	4c 85       	ldd	r20, Y+12	; 0x0c
    1972:	5d 85       	ldd	r21, Y+13	; 0x0d
    1974:	b9 01       	movw	r22, r18
    1976:	0e 94 19 05 	call	0xa32	; 0xa32 <pxPortInitialiseStack>
    197a:	eb 81       	ldd	r30, Y+3	; 0x03
    197c:	fc 81       	ldd	r31, Y+4	; 0x04
    197e:	91 83       	std	Z+1, r25	; 0x01
    1980:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    1982:	8f 85       	ldd	r24, Y+15	; 0x0f
    1984:	98 89       	ldd	r25, Y+16	; 0x10
    1986:	00 97       	sbiw	r24, 0x00	; 0
    1988:	31 f0       	breq	.+12     	; 0x1996 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    198a:	ef 85       	ldd	r30, Y+15	; 0x0f
    198c:	f8 89       	ldd	r31, Y+16	; 0x10
    198e:	8b 81       	ldd	r24, Y+3	; 0x03
    1990:	9c 81       	ldd	r25, Y+4	; 0x04
    1992:	91 83       	std	Z+1, r25	; 0x01
    1994:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    1996:	0f b6       	in	r0, 0x3f	; 63
    1998:	f8 94       	cli
    199a:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    199c:	80 91 07 03 	lds	r24, 0x0307
    19a0:	8f 5f       	subi	r24, 0xFF	; 255
    19a2:	80 93 07 03 	sts	0x0307, r24
			if( pxCurrentTCB == NULL )
    19a6:	80 91 04 03 	lds	r24, 0x0304
    19aa:	90 91 05 03 	lds	r25, 0x0305
    19ae:	00 97       	sbiw	r24, 0x00	; 0
    19b0:	69 f4       	brne	.+26     	; 0x19cc <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    19b2:	8b 81       	ldd	r24, Y+3	; 0x03
    19b4:	9c 81       	ldd	r25, Y+4	; 0x04
    19b6:	90 93 05 03 	sts	0x0305, r25
    19ba:	80 93 04 03 	sts	0x0304, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    19be:	80 91 07 03 	lds	r24, 0x0307
    19c2:	81 30       	cpi	r24, 0x01	; 1
    19c4:	a9 f4       	brne	.+42     	; 0x19f0 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    19c6:	0e 94 2d 12 	call	0x245a	; 0x245a <prvInitialiseTaskLists>
    19ca:	12 c0       	rjmp	.+36     	; 0x19f0 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    19cc:	80 91 0c 03 	lds	r24, 0x030C
    19d0:	88 23       	and	r24, r24
    19d2:	71 f4       	brne	.+28     	; 0x19f0 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    19d4:	e0 91 04 03 	lds	r30, 0x0304
    19d8:	f0 91 05 03 	lds	r31, 0x0305
    19dc:	96 89       	ldd	r25, Z+22	; 0x16
    19de:	8e 85       	ldd	r24, Y+14	; 0x0e
    19e0:	89 17       	cp	r24, r25
    19e2:	30 f0       	brcs	.+12     	; 0x19f0 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    19e4:	8b 81       	ldd	r24, Y+3	; 0x03
    19e6:	9c 81       	ldd	r25, Y+4	; 0x04
    19e8:	90 93 05 03 	sts	0x0305, r25
    19ec:	80 93 04 03 	sts	0x0304, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    19f0:	eb 81       	ldd	r30, Y+3	; 0x03
    19f2:	fc 81       	ldd	r31, Y+4	; 0x04
    19f4:	96 89       	ldd	r25, Z+22	; 0x16
    19f6:	80 91 0a 03 	lds	r24, 0x030A
    19fa:	89 17       	cp	r24, r25
    19fc:	28 f4       	brcc	.+10     	; 0x1a08 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    19fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1a00:	fc 81       	ldd	r31, Y+4	; 0x04
    1a02:	86 89       	ldd	r24, Z+22	; 0x16
    1a04:	80 93 0a 03 	sts	0x030A, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1a08:	80 91 11 03 	lds	r24, 0x0311
    1a0c:	8f 5f       	subi	r24, 0xFF	; 255
    1a0e:	80 93 11 03 	sts	0x0311, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    1a12:	eb 81       	ldd	r30, Y+3	; 0x03
    1a14:	fc 81       	ldd	r31, Y+4	; 0x04
    1a16:	96 89       	ldd	r25, Z+22	; 0x16
    1a18:	80 91 0b 03 	lds	r24, 0x030B
    1a1c:	89 17       	cp	r24, r25
    1a1e:	28 f4       	brcc	.+10     	; 0x1a2a <xTaskGenericCreate+0x152>
    1a20:	eb 81       	ldd	r30, Y+3	; 0x03
    1a22:	fc 81       	ldd	r31, Y+4	; 0x04
    1a24:	86 89       	ldd	r24, Z+22	; 0x16
    1a26:	80 93 0b 03 	sts	0x030B, r24
    1a2a:	eb 81       	ldd	r30, Y+3	; 0x03
    1a2c:	fc 81       	ldd	r31, Y+4	; 0x04
    1a2e:	86 89       	ldd	r24, Z+22	; 0x16
    1a30:	28 2f       	mov	r18, r24
    1a32:	30 e0       	ldi	r19, 0x00	; 0
    1a34:	c9 01       	movw	r24, r18
    1a36:	88 0f       	add	r24, r24
    1a38:	99 1f       	adc	r25, r25
    1a3a:	88 0f       	add	r24, r24
    1a3c:	99 1f       	adc	r25, r25
    1a3e:	88 0f       	add	r24, r24
    1a40:	99 1f       	adc	r25, r25
    1a42:	82 0f       	add	r24, r18
    1a44:	93 1f       	adc	r25, r19
    1a46:	ac 01       	movw	r20, r24
    1a48:	4e 5e       	subi	r20, 0xEE	; 238
    1a4a:	5c 4f       	sbci	r21, 0xFC	; 252
    1a4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a4e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a50:	9c 01       	movw	r18, r24
    1a52:	2e 5f       	subi	r18, 0xFE	; 254
    1a54:	3f 4f       	sbci	r19, 0xFF	; 255
    1a56:	ca 01       	movw	r24, r20
    1a58:	b9 01       	movw	r22, r18
    1a5a:	0e 94 18 04 	call	0x830	; 0x830 <vListInsertEnd>

			xReturn = pdPASS;
    1a5e:	81 e0       	ldi	r24, 0x01	; 1
    1a60:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1a62:	0f 90       	pop	r0
    1a64:	0f be       	out	0x3f, r0	; 63
    1a66:	02 c0       	rjmp	.+4      	; 0x1a6c <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1a68:	8f ef       	ldi	r24, 0xFF	; 255
    1a6a:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    1a6c:	8d 81       	ldd	r24, Y+5	; 0x05
    1a6e:	81 30       	cpi	r24, 0x01	; 1
    1a70:	71 f4       	brne	.+28     	; 0x1a8e <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    1a72:	80 91 0c 03 	lds	r24, 0x030C
    1a76:	88 23       	and	r24, r24
    1a78:	51 f0       	breq	.+20     	; 0x1a8e <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1a7a:	e0 91 04 03 	lds	r30, 0x0304
    1a7e:	f0 91 05 03 	lds	r31, 0x0305
    1a82:	96 89       	ldd	r25, Z+22	; 0x16
    1a84:	8e 85       	ldd	r24, Y+14	; 0x0e
    1a86:	98 17       	cp	r25, r24
    1a88:	10 f4       	brcc	.+4      	; 0x1a8e <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    1a8a:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <vPortYield>
			}
		}
	}

	return xReturn;
    1a8e:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1a90:	64 96       	adiw	r28, 0x14	; 20
    1a92:	0f b6       	in	r0, 0x3f	; 63
    1a94:	f8 94       	cli
    1a96:	de bf       	out	0x3e, r29	; 62
    1a98:	0f be       	out	0x3f, r0	; 63
    1a9a:	cd bf       	out	0x3d, r28	; 61
    1a9c:	cf 91       	pop	r28
    1a9e:	df 91       	pop	r29
    1aa0:	1f 91       	pop	r17
    1aa2:	0f 91       	pop	r16
    1aa4:	ff 90       	pop	r15
    1aa6:	ef 90       	pop	r14
    1aa8:	df 90       	pop	r13
    1aaa:	cf 90       	pop	r12
    1aac:	bf 90       	pop	r11
    1aae:	af 90       	pop	r10
    1ab0:	08 95       	ret

00001ab2 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1ab2:	df 93       	push	r29
    1ab4:	cf 93       	push	r28
    1ab6:	00 d0       	rcall	.+0      	; 0x1ab8 <vTaskDelete+0x6>
    1ab8:	00 d0       	rcall	.+0      	; 0x1aba <vTaskDelete+0x8>
    1aba:	00 d0       	rcall	.+0      	; 0x1abc <vTaskDelete+0xa>
    1abc:	cd b7       	in	r28, 0x3d	; 61
    1abe:	de b7       	in	r29, 0x3e	; 62
    1ac0:	9c 83       	std	Y+4, r25	; 0x04
    1ac2:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1ac4:	0f b6       	in	r0, 0x3f	; 63
    1ac6:	f8 94       	cli
    1ac8:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1aca:	20 91 04 03 	lds	r18, 0x0304
    1ace:	30 91 05 03 	lds	r19, 0x0305
    1ad2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ad4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ad6:	82 17       	cp	r24, r18
    1ad8:	93 07       	cpc	r25, r19
    1ada:	11 f4       	brne	.+4      	; 0x1ae0 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    1adc:	1c 82       	std	Y+4, r1	; 0x04
    1ade:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1ae0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ae2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ae4:	00 97       	sbiw	r24, 0x00	; 0
    1ae6:	39 f4       	brne	.+14     	; 0x1af6 <vTaskDelete+0x44>
    1ae8:	80 91 04 03 	lds	r24, 0x0304
    1aec:	90 91 05 03 	lds	r25, 0x0305
    1af0:	9e 83       	std	Y+6, r25	; 0x06
    1af2:	8d 83       	std	Y+5, r24	; 0x05
    1af4:	04 c0       	rjmp	.+8      	; 0x1afe <vTaskDelete+0x4c>
    1af6:	8b 81       	ldd	r24, Y+3	; 0x03
    1af8:	9c 81       	ldd	r25, Y+4	; 0x04
    1afa:	9e 83       	std	Y+6, r25	; 0x06
    1afc:	8d 83       	std	Y+5, r24	; 0x05
    1afe:	8d 81       	ldd	r24, Y+5	; 0x05
    1b00:	9e 81       	ldd	r25, Y+6	; 0x06
    1b02:	9a 83       	std	Y+2, r25	; 0x02
    1b04:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1b06:	89 81       	ldd	r24, Y+1	; 0x01
    1b08:	9a 81       	ldd	r25, Y+2	; 0x02
    1b0a:	02 96       	adiw	r24, 0x02	; 2
    1b0c:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1b10:	e9 81       	ldd	r30, Y+1	; 0x01
    1b12:	fa 81       	ldd	r31, Y+2	; 0x02
    1b14:	84 89       	ldd	r24, Z+20	; 0x14
    1b16:	95 89       	ldd	r25, Z+21	; 0x15
    1b18:	00 97       	sbiw	r24, 0x00	; 0
    1b1a:	29 f0       	breq	.+10     	; 0x1b26 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1b1c:	89 81       	ldd	r24, Y+1	; 0x01
    1b1e:	9a 81       	ldd	r25, Y+2	; 0x02
    1b20:	0c 96       	adiw	r24, 0x0c	; 12
    1b22:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1b26:	89 81       	ldd	r24, Y+1	; 0x01
    1b28:	9a 81       	ldd	r25, Y+2	; 0x02
    1b2a:	9c 01       	movw	r18, r24
    1b2c:	2e 5f       	subi	r18, 0xFE	; 254
    1b2e:	3f 4f       	sbci	r19, 0xFF	; 255
    1b30:	8e e5       	ldi	r24, 0x5E	; 94
    1b32:	93 e0       	ldi	r25, 0x03	; 3
    1b34:	b9 01       	movw	r22, r18
    1b36:	0e 94 18 04 	call	0x830	; 0x830 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1b3a:	80 91 06 03 	lds	r24, 0x0306
    1b3e:	8f 5f       	subi	r24, 0xFF	; 255
    1b40:	80 93 06 03 	sts	0x0306, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1b44:	80 91 11 03 	lds	r24, 0x0311
    1b48:	8f 5f       	subi	r24, 0xFF	; 255
    1b4a:	80 93 11 03 	sts	0x0311, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1b4e:	0f 90       	pop	r0
    1b50:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1b52:	80 91 0c 03 	lds	r24, 0x030C
    1b56:	88 23       	and	r24, r24
    1b58:	31 f0       	breq	.+12     	; 0x1b66 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1b5a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b5c:	9c 81       	ldd	r25, Y+4	; 0x04
    1b5e:	00 97       	sbiw	r24, 0x00	; 0
    1b60:	11 f4       	brne	.+4      	; 0x1b66 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    1b62:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <vPortYield>
			}
		}
	}
    1b66:	26 96       	adiw	r28, 0x06	; 6
    1b68:	0f b6       	in	r0, 0x3f	; 63
    1b6a:	f8 94       	cli
    1b6c:	de bf       	out	0x3e, r29	; 62
    1b6e:	0f be       	out	0x3f, r0	; 63
    1b70:	cd bf       	out	0x3d, r28	; 61
    1b72:	cf 91       	pop	r28
    1b74:	df 91       	pop	r29
    1b76:	08 95       	ret

00001b78 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1b78:	df 93       	push	r29
    1b7a:	cf 93       	push	r28
    1b7c:	cd b7       	in	r28, 0x3d	; 61
    1b7e:	de b7       	in	r29, 0x3e	; 62
    1b80:	28 97       	sbiw	r28, 0x08	; 8
    1b82:	0f b6       	in	r0, 0x3f	; 63
    1b84:	f8 94       	cli
    1b86:	de bf       	out	0x3e, r29	; 62
    1b88:	0f be       	out	0x3f, r0	; 63
    1b8a:	cd bf       	out	0x3d, r28	; 61
    1b8c:	9e 83       	std	Y+6, r25	; 0x06
    1b8e:	8d 83       	std	Y+5, r24	; 0x05
    1b90:	78 87       	std	Y+8, r23	; 0x08
    1b92:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    1b94:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1b96:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1b9a:	ed 81       	ldd	r30, Y+5	; 0x05
    1b9c:	fe 81       	ldd	r31, Y+6	; 0x06
    1b9e:	20 81       	ld	r18, Z
    1ba0:	31 81       	ldd	r19, Z+1	; 0x01
    1ba2:	8f 81       	ldd	r24, Y+7	; 0x07
    1ba4:	98 85       	ldd	r25, Y+8	; 0x08
    1ba6:	82 0f       	add	r24, r18
    1ba8:	93 1f       	adc	r25, r19
    1baa:	9c 83       	std	Y+4, r25	; 0x04
    1bac:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    1bae:	ed 81       	ldd	r30, Y+5	; 0x05
    1bb0:	fe 81       	ldd	r31, Y+6	; 0x06
    1bb2:	20 81       	ld	r18, Z
    1bb4:	31 81       	ldd	r19, Z+1	; 0x01
    1bb6:	80 91 08 03 	lds	r24, 0x0308
    1bba:	90 91 09 03 	lds	r25, 0x0309
    1bbe:	82 17       	cp	r24, r18
    1bc0:	93 07       	cpc	r25, r19
    1bc2:	a8 f4       	brcc	.+42     	; 0x1bee <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1bc4:	ed 81       	ldd	r30, Y+5	; 0x05
    1bc6:	fe 81       	ldd	r31, Y+6	; 0x06
    1bc8:	20 81       	ld	r18, Z
    1bca:	31 81       	ldd	r19, Z+1	; 0x01
    1bcc:	8b 81       	ldd	r24, Y+3	; 0x03
    1bce:	9c 81       	ldd	r25, Y+4	; 0x04
    1bd0:	82 17       	cp	r24, r18
    1bd2:	93 07       	cpc	r25, r19
    1bd4:	00 f5       	brcc	.+64     	; 0x1c16 <vTaskDelayUntil+0x9e>
    1bd6:	20 91 08 03 	lds	r18, 0x0308
    1bda:	30 91 09 03 	lds	r19, 0x0309
    1bde:	8b 81       	ldd	r24, Y+3	; 0x03
    1be0:	9c 81       	ldd	r25, Y+4	; 0x04
    1be2:	28 17       	cp	r18, r24
    1be4:	39 07       	cpc	r19, r25
    1be6:	b8 f4       	brcc	.+46     	; 0x1c16 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1be8:	81 e0       	ldi	r24, 0x01	; 1
    1bea:	89 83       	std	Y+1, r24	; 0x01
    1bec:	14 c0       	rjmp	.+40     	; 0x1c16 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1bee:	ed 81       	ldd	r30, Y+5	; 0x05
    1bf0:	fe 81       	ldd	r31, Y+6	; 0x06
    1bf2:	20 81       	ld	r18, Z
    1bf4:	31 81       	ldd	r19, Z+1	; 0x01
    1bf6:	8b 81       	ldd	r24, Y+3	; 0x03
    1bf8:	9c 81       	ldd	r25, Y+4	; 0x04
    1bfa:	82 17       	cp	r24, r18
    1bfc:	93 07       	cpc	r25, r19
    1bfe:	48 f0       	brcs	.+18     	; 0x1c12 <vTaskDelayUntil+0x9a>
    1c00:	20 91 08 03 	lds	r18, 0x0308
    1c04:	30 91 09 03 	lds	r19, 0x0309
    1c08:	8b 81       	ldd	r24, Y+3	; 0x03
    1c0a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c0c:	28 17       	cp	r18, r24
    1c0e:	39 07       	cpc	r19, r25
    1c10:	10 f4       	brcc	.+4      	; 0x1c16 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1c12:	81 e0       	ldi	r24, 0x01	; 1
    1c14:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1c16:	ed 81       	ldd	r30, Y+5	; 0x05
    1c18:	fe 81       	ldd	r31, Y+6	; 0x06
    1c1a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c1c:	9c 81       	ldd	r25, Y+4	; 0x04
    1c1e:	91 83       	std	Z+1, r25	; 0x01
    1c20:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    1c22:	89 81       	ldd	r24, Y+1	; 0x01
    1c24:	88 23       	and	r24, r24
    1c26:	59 f0       	breq	.+22     	; 0x1c3e <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1c28:	80 91 04 03 	lds	r24, 0x0304
    1c2c:	90 91 05 03 	lds	r25, 0x0305
    1c30:	02 96       	adiw	r24, 0x02	; 2
    1c32:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1c36:	8b 81       	ldd	r24, Y+3	; 0x03
    1c38:	9c 81       	ldd	r25, Y+4	; 0x04
    1c3a:	0e 94 a8 12 	call	0x2550	; 0x2550 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1c3e:	0e 94 b4 0e 	call	0x1d68	; 0x1d68 <xTaskResumeAll>
    1c42:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1c44:	8a 81       	ldd	r24, Y+2	; 0x02
    1c46:	88 23       	and	r24, r24
    1c48:	11 f4       	brne	.+4      	; 0x1c4e <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    1c4a:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <vPortYield>
		}
	}
    1c4e:	28 96       	adiw	r28, 0x08	; 8
    1c50:	0f b6       	in	r0, 0x3f	; 63
    1c52:	f8 94       	cli
    1c54:	de bf       	out	0x3e, r29	; 62
    1c56:	0f be       	out	0x3f, r0	; 63
    1c58:	cd bf       	out	0x3d, r28	; 61
    1c5a:	cf 91       	pop	r28
    1c5c:	df 91       	pop	r29
    1c5e:	08 95       	ret

00001c60 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1c60:	df 93       	push	r29
    1c62:	cf 93       	push	r28
    1c64:	00 d0       	rcall	.+0      	; 0x1c66 <vTaskDelay+0x6>
    1c66:	00 d0       	rcall	.+0      	; 0x1c68 <vTaskDelay+0x8>
    1c68:	0f 92       	push	r0
    1c6a:	cd b7       	in	r28, 0x3d	; 61
    1c6c:	de b7       	in	r29, 0x3e	; 62
    1c6e:	9d 83       	std	Y+5, r25	; 0x05
    1c70:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1c72:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1c74:	8c 81       	ldd	r24, Y+4	; 0x04
    1c76:	9d 81       	ldd	r25, Y+5	; 0x05
    1c78:	00 97       	sbiw	r24, 0x00	; 0
    1c7a:	d1 f0       	breq	.+52     	; 0x1cb0 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    1c7c:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1c80:	20 91 08 03 	lds	r18, 0x0308
    1c84:	30 91 09 03 	lds	r19, 0x0309
    1c88:	8c 81       	ldd	r24, Y+4	; 0x04
    1c8a:	9d 81       	ldd	r25, Y+5	; 0x05
    1c8c:	82 0f       	add	r24, r18
    1c8e:	93 1f       	adc	r25, r19
    1c90:	9b 83       	std	Y+3, r25	; 0x03
    1c92:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1c94:	80 91 04 03 	lds	r24, 0x0304
    1c98:	90 91 05 03 	lds	r25, 0x0305
    1c9c:	02 96       	adiw	r24, 0x02	; 2
    1c9e:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1ca2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ca4:	9b 81       	ldd	r25, Y+3	; 0x03
    1ca6:	0e 94 a8 12 	call	0x2550	; 0x2550 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1caa:	0e 94 b4 0e 	call	0x1d68	; 0x1d68 <xTaskResumeAll>
    1cae:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1cb0:	89 81       	ldd	r24, Y+1	; 0x01
    1cb2:	88 23       	and	r24, r24
    1cb4:	11 f4       	brne	.+4      	; 0x1cba <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    1cb6:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <vPortYield>
		}
	}
    1cba:	0f 90       	pop	r0
    1cbc:	0f 90       	pop	r0
    1cbe:	0f 90       	pop	r0
    1cc0:	0f 90       	pop	r0
    1cc2:	0f 90       	pop	r0
    1cc4:	cf 91       	pop	r28
    1cc6:	df 91       	pop	r29
    1cc8:	08 95       	ret

00001cca <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1cca:	af 92       	push	r10
    1ccc:	bf 92       	push	r11
    1cce:	cf 92       	push	r12
    1cd0:	df 92       	push	r13
    1cd2:	ef 92       	push	r14
    1cd4:	ff 92       	push	r15
    1cd6:	0f 93       	push	r16
    1cd8:	df 93       	push	r29
    1cda:	cf 93       	push	r28
    1cdc:	0f 92       	push	r0
    1cde:	cd b7       	in	r28, 0x3d	; 61
    1ce0:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    1ce2:	26 e6       	ldi	r18, 0x66	; 102
    1ce4:	30 e0       	ldi	r19, 0x00	; 0
    1ce6:	8c ec       	ldi	r24, 0xCC	; 204
    1ce8:	91 e1       	ldi	r25, 0x11	; 17
    1cea:	b9 01       	movw	r22, r18
    1cec:	45 e5       	ldi	r20, 0x55	; 85
    1cee:	50 e0       	ldi	r21, 0x00	; 0
    1cf0:	20 e0       	ldi	r18, 0x00	; 0
    1cf2:	30 e0       	ldi	r19, 0x00	; 0
    1cf4:	00 e0       	ldi	r16, 0x00	; 0
    1cf6:	ee 24       	eor	r14, r14
    1cf8:	ff 24       	eor	r15, r15
    1cfa:	cc 24       	eor	r12, r12
    1cfc:	dd 24       	eor	r13, r13
    1cfe:	aa 24       	eor	r10, r10
    1d00:	bb 24       	eor	r11, r11
    1d02:	0e 94 6c 0c 	call	0x18d8	; 0x18d8 <xTaskGenericCreate>
    1d06:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    1d08:	89 81       	ldd	r24, Y+1	; 0x01
    1d0a:	81 30       	cpi	r24, 0x01	; 1
    1d0c:	51 f4       	brne	.+20     	; 0x1d22 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1d0e:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1d10:	81 e0       	ldi	r24, 0x01	; 1
    1d12:	80 93 0c 03 	sts	0x030C, r24
		xTickCount = ( portTickType ) 0U;
    1d16:	10 92 09 03 	sts	0x0309, r1
    1d1a:	10 92 08 03 	sts	0x0308, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1d1e:	0e 94 9c 06 	call	0xd38	; 0xd38 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    1d22:	0f 90       	pop	r0
    1d24:	cf 91       	pop	r28
    1d26:	df 91       	pop	r29
    1d28:	0f 91       	pop	r16
    1d2a:	ff 90       	pop	r15
    1d2c:	ef 90       	pop	r14
    1d2e:	df 90       	pop	r13
    1d30:	cf 90       	pop	r12
    1d32:	bf 90       	pop	r11
    1d34:	af 90       	pop	r10
    1d36:	08 95       	ret

00001d38 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    1d38:	df 93       	push	r29
    1d3a:	cf 93       	push	r28
    1d3c:	cd b7       	in	r28, 0x3d	; 61
    1d3e:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1d40:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1d42:	10 92 0c 03 	sts	0x030C, r1
	vPortEndScheduler();
    1d46:	0e 94 d1 06 	call	0xda2	; 0xda2 <vPortEndScheduler>
}
    1d4a:	cf 91       	pop	r28
    1d4c:	df 91       	pop	r29
    1d4e:	08 95       	ret

00001d50 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    1d50:	df 93       	push	r29
    1d52:	cf 93       	push	r28
    1d54:	cd b7       	in	r28, 0x3d	; 61
    1d56:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1d58:	80 91 0d 03 	lds	r24, 0x030D
    1d5c:	8f 5f       	subi	r24, 0xFF	; 255
    1d5e:	80 93 0d 03 	sts	0x030D, r24
}
    1d62:	cf 91       	pop	r28
    1d64:	df 91       	pop	r29
    1d66:	08 95       	ret

00001d68 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1d68:	df 93       	push	r29
    1d6a:	cf 93       	push	r28
    1d6c:	00 d0       	rcall	.+0      	; 0x1d6e <xTaskResumeAll+0x6>
    1d6e:	00 d0       	rcall	.+0      	; 0x1d70 <xTaskResumeAll+0x8>
    1d70:	cd b7       	in	r28, 0x3d	; 61
    1d72:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1d74:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1d76:	0f b6       	in	r0, 0x3f	; 63
    1d78:	f8 94       	cli
    1d7a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1d7c:	80 91 0d 03 	lds	r24, 0x030D
    1d80:	81 50       	subi	r24, 0x01	; 1
    1d82:	80 93 0d 03 	sts	0x030D, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1d86:	80 91 0d 03 	lds	r24, 0x030D
    1d8a:	88 23       	and	r24, r24
    1d8c:	09 f0       	breq	.+2      	; 0x1d90 <xTaskResumeAll+0x28>
    1d8e:	6c c0       	rjmp	.+216    	; 0x1e68 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1d90:	80 91 07 03 	lds	r24, 0x0307
    1d94:	88 23       	and	r24, r24
    1d96:	09 f4       	brne	.+2      	; 0x1d9a <xTaskResumeAll+0x32>
    1d98:	67 c0       	rjmp	.+206    	; 0x1e68 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    1d9a:	19 82       	std	Y+1, r1	; 0x01
    1d9c:	41 c0       	rjmp	.+130    	; 0x1e20 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1d9e:	e0 91 5a 03 	lds	r30, 0x035A
    1da2:	f0 91 5b 03 	lds	r31, 0x035B
    1da6:	86 81       	ldd	r24, Z+6	; 0x06
    1da8:	97 81       	ldd	r25, Z+7	; 0x07
    1daa:	9c 83       	std	Y+4, r25	; 0x04
    1dac:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    1dae:	8b 81       	ldd	r24, Y+3	; 0x03
    1db0:	9c 81       	ldd	r25, Y+4	; 0x04
    1db2:	0c 96       	adiw	r24, 0x0c	; 12
    1db4:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1db8:	8b 81       	ldd	r24, Y+3	; 0x03
    1dba:	9c 81       	ldd	r25, Y+4	; 0x04
    1dbc:	02 96       	adiw	r24, 0x02	; 2
    1dbe:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1dc2:	eb 81       	ldd	r30, Y+3	; 0x03
    1dc4:	fc 81       	ldd	r31, Y+4	; 0x04
    1dc6:	96 89       	ldd	r25, Z+22	; 0x16
    1dc8:	80 91 0b 03 	lds	r24, 0x030B
    1dcc:	89 17       	cp	r24, r25
    1dce:	28 f4       	brcc	.+10     	; 0x1dda <xTaskResumeAll+0x72>
    1dd0:	eb 81       	ldd	r30, Y+3	; 0x03
    1dd2:	fc 81       	ldd	r31, Y+4	; 0x04
    1dd4:	86 89       	ldd	r24, Z+22	; 0x16
    1dd6:	80 93 0b 03 	sts	0x030B, r24
    1dda:	eb 81       	ldd	r30, Y+3	; 0x03
    1ddc:	fc 81       	ldd	r31, Y+4	; 0x04
    1dde:	86 89       	ldd	r24, Z+22	; 0x16
    1de0:	28 2f       	mov	r18, r24
    1de2:	30 e0       	ldi	r19, 0x00	; 0
    1de4:	c9 01       	movw	r24, r18
    1de6:	88 0f       	add	r24, r24
    1de8:	99 1f       	adc	r25, r25
    1dea:	88 0f       	add	r24, r24
    1dec:	99 1f       	adc	r25, r25
    1dee:	88 0f       	add	r24, r24
    1df0:	99 1f       	adc	r25, r25
    1df2:	82 0f       	add	r24, r18
    1df4:	93 1f       	adc	r25, r19
    1df6:	8e 5e       	subi	r24, 0xEE	; 238
    1df8:	9c 4f       	sbci	r25, 0xFC	; 252
    1dfa:	2b 81       	ldd	r18, Y+3	; 0x03
    1dfc:	3c 81       	ldd	r19, Y+4	; 0x04
    1dfe:	2e 5f       	subi	r18, 0xFE	; 254
    1e00:	3f 4f       	sbci	r19, 0xFF	; 255
    1e02:	b9 01       	movw	r22, r18
    1e04:	0e 94 18 04 	call	0x830	; 0x830 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1e08:	eb 81       	ldd	r30, Y+3	; 0x03
    1e0a:	fc 81       	ldd	r31, Y+4	; 0x04
    1e0c:	96 89       	ldd	r25, Z+22	; 0x16
    1e0e:	e0 91 04 03 	lds	r30, 0x0304
    1e12:	f0 91 05 03 	lds	r31, 0x0305
    1e16:	86 89       	ldd	r24, Z+22	; 0x16
    1e18:	98 17       	cp	r25, r24
    1e1a:	10 f0       	brcs	.+4      	; 0x1e20 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    1e1c:	81 e0       	ldi	r24, 0x01	; 1
    1e1e:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1e20:	80 91 55 03 	lds	r24, 0x0355
    1e24:	88 23       	and	r24, r24
    1e26:	09 f0       	breq	.+2      	; 0x1e2a <xTaskResumeAll+0xc2>
    1e28:	ba cf       	rjmp	.-140    	; 0x1d9e <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1e2a:	80 91 0e 03 	lds	r24, 0x030E
    1e2e:	88 23       	and	r24, r24
    1e30:	71 f0       	breq	.+28     	; 0x1e4e <xTaskResumeAll+0xe6>
    1e32:	07 c0       	rjmp	.+14     	; 0x1e42 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    1e34:	0e 94 73 0f 	call	0x1ee6	; 0x1ee6 <vTaskIncrementTick>
						--uxMissedTicks;
    1e38:	80 91 0e 03 	lds	r24, 0x030E
    1e3c:	81 50       	subi	r24, 0x01	; 1
    1e3e:	80 93 0e 03 	sts	0x030E, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1e42:	80 91 0e 03 	lds	r24, 0x030E
    1e46:	88 23       	and	r24, r24
    1e48:	a9 f7       	brne	.-22     	; 0x1e34 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    1e4a:	81 e0       	ldi	r24, 0x01	; 1
    1e4c:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1e4e:	89 81       	ldd	r24, Y+1	; 0x01
    1e50:	81 30       	cpi	r24, 0x01	; 1
    1e52:	21 f0       	breq	.+8      	; 0x1e5c <xTaskResumeAll+0xf4>
    1e54:	80 91 0f 03 	lds	r24, 0x030F
    1e58:	81 30       	cpi	r24, 0x01	; 1
    1e5a:	31 f4       	brne	.+12     	; 0x1e68 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    1e5c:	81 e0       	ldi	r24, 0x01	; 1
    1e5e:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    1e60:	10 92 0f 03 	sts	0x030F, r1
					portYIELD_WITHIN_API();
    1e64:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    1e68:	0f 90       	pop	r0
    1e6a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    1e6c:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1e6e:	0f 90       	pop	r0
    1e70:	0f 90       	pop	r0
    1e72:	0f 90       	pop	r0
    1e74:	0f 90       	pop	r0
    1e76:	cf 91       	pop	r28
    1e78:	df 91       	pop	r29
    1e7a:	08 95       	ret

00001e7c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    1e7c:	df 93       	push	r29
    1e7e:	cf 93       	push	r28
    1e80:	00 d0       	rcall	.+0      	; 0x1e82 <xTaskGetTickCount+0x6>
    1e82:	cd b7       	in	r28, 0x3d	; 61
    1e84:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    1e86:	0f b6       	in	r0, 0x3f	; 63
    1e88:	f8 94       	cli
    1e8a:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1e8c:	80 91 08 03 	lds	r24, 0x0308
    1e90:	90 91 09 03 	lds	r25, 0x0309
    1e94:	9a 83       	std	Y+2, r25	; 0x02
    1e96:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    1e98:	0f 90       	pop	r0
    1e9a:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    1e9c:	89 81       	ldd	r24, Y+1	; 0x01
    1e9e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1ea0:	0f 90       	pop	r0
    1ea2:	0f 90       	pop	r0
    1ea4:	cf 91       	pop	r28
    1ea6:	df 91       	pop	r29
    1ea8:	08 95       	ret

00001eaa <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    1eaa:	df 93       	push	r29
    1eac:	cf 93       	push	r28
    1eae:	00 d0       	rcall	.+0      	; 0x1eb0 <xTaskGetTickCountFromISR+0x6>
    1eb0:	0f 92       	push	r0
    1eb2:	cd b7       	in	r28, 0x3d	; 61
    1eb4:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1eb6:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    1eb8:	80 91 08 03 	lds	r24, 0x0308
    1ebc:	90 91 09 03 	lds	r25, 0x0309
    1ec0:	9b 83       	std	Y+3, r25	; 0x03
    1ec2:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1ec4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ec6:	9b 81       	ldd	r25, Y+3	; 0x03
}
    1ec8:	0f 90       	pop	r0
    1eca:	0f 90       	pop	r0
    1ecc:	0f 90       	pop	r0
    1ece:	cf 91       	pop	r28
    1ed0:	df 91       	pop	r29
    1ed2:	08 95       	ret

00001ed4 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    1ed4:	df 93       	push	r29
    1ed6:	cf 93       	push	r28
    1ed8:	cd b7       	in	r28, 0x3d	; 61
    1eda:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1edc:	80 91 07 03 	lds	r24, 0x0307
}
    1ee0:	cf 91       	pop	r28
    1ee2:	df 91       	pop	r29
    1ee4:	08 95       	ret

00001ee6 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1ee6:	df 93       	push	r29
    1ee8:	cf 93       	push	r28
    1eea:	00 d0       	rcall	.+0      	; 0x1eec <vTaskIncrementTick+0x6>
    1eec:	00 d0       	rcall	.+0      	; 0x1eee <vTaskIncrementTick+0x8>
    1eee:	00 d0       	rcall	.+0      	; 0x1ef0 <vTaskIncrementTick+0xa>
    1ef0:	cd b7       	in	r28, 0x3d	; 61
    1ef2:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1ef4:	80 91 0d 03 	lds	r24, 0x030D
    1ef8:	88 23       	and	r24, r24
    1efa:	09 f0       	breq	.+2      	; 0x1efe <vTaskIncrementTick+0x18>
    1efc:	bb c0       	rjmp	.+374    	; 0x2074 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    1efe:	80 91 08 03 	lds	r24, 0x0308
    1f02:	90 91 09 03 	lds	r25, 0x0309
    1f06:	01 96       	adiw	r24, 0x01	; 1
    1f08:	90 93 09 03 	sts	0x0309, r25
    1f0c:	80 93 08 03 	sts	0x0308, r24
		if( xTickCount == ( portTickType ) 0U )
    1f10:	80 91 08 03 	lds	r24, 0x0308
    1f14:	90 91 09 03 	lds	r25, 0x0309
    1f18:	00 97       	sbiw	r24, 0x00	; 0
    1f1a:	d1 f5       	brne	.+116    	; 0x1f90 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    1f1c:	80 91 51 03 	lds	r24, 0x0351
    1f20:	90 91 52 03 	lds	r25, 0x0352
    1f24:	9c 83       	std	Y+4, r25	; 0x04
    1f26:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1f28:	80 91 53 03 	lds	r24, 0x0353
    1f2c:	90 91 54 03 	lds	r25, 0x0354
    1f30:	90 93 52 03 	sts	0x0352, r25
    1f34:	80 93 51 03 	sts	0x0351, r24
			pxOverflowDelayedTaskList = pxTemp;
    1f38:	8b 81       	ldd	r24, Y+3	; 0x03
    1f3a:	9c 81       	ldd	r25, Y+4	; 0x04
    1f3c:	90 93 54 03 	sts	0x0354, r25
    1f40:	80 93 53 03 	sts	0x0353, r24
			xNumOfOverflows++;
    1f44:	80 91 10 03 	lds	r24, 0x0310
    1f48:	8f 5f       	subi	r24, 0xFF	; 255
    1f4a:	80 93 10 03 	sts	0x0310, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1f4e:	e0 91 51 03 	lds	r30, 0x0351
    1f52:	f0 91 52 03 	lds	r31, 0x0352
    1f56:	80 81       	ld	r24, Z
    1f58:	88 23       	and	r24, r24
    1f5a:	39 f4       	brne	.+14     	; 0x1f6a <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    1f5c:	8f ef       	ldi	r24, 0xFF	; 255
    1f5e:	9f ef       	ldi	r25, 0xFF	; 255
    1f60:	90 93 6c 00 	sts	0x006C, r25
    1f64:	80 93 6b 00 	sts	0x006B, r24
    1f68:	13 c0       	rjmp	.+38     	; 0x1f90 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1f6a:	e0 91 51 03 	lds	r30, 0x0351
    1f6e:	f0 91 52 03 	lds	r31, 0x0352
    1f72:	05 80       	ldd	r0, Z+5	; 0x05
    1f74:	f6 81       	ldd	r31, Z+6	; 0x06
    1f76:	e0 2d       	mov	r30, r0
    1f78:	86 81       	ldd	r24, Z+6	; 0x06
    1f7a:	97 81       	ldd	r25, Z+7	; 0x07
    1f7c:	9e 83       	std	Y+6, r25	; 0x06
    1f7e:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1f80:	ed 81       	ldd	r30, Y+5	; 0x05
    1f82:	fe 81       	ldd	r31, Y+6	; 0x06
    1f84:	82 81       	ldd	r24, Z+2	; 0x02
    1f86:	93 81       	ldd	r25, Z+3	; 0x03
    1f88:	90 93 6c 00 	sts	0x006C, r25
    1f8c:	80 93 6b 00 	sts	0x006B, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1f90:	20 91 08 03 	lds	r18, 0x0308
    1f94:	30 91 09 03 	lds	r19, 0x0309
    1f98:	80 91 6b 00 	lds	r24, 0x006B
    1f9c:	90 91 6c 00 	lds	r25, 0x006C
    1fa0:	28 17       	cp	r18, r24
    1fa2:	39 07       	cpc	r19, r25
    1fa4:	08 f4       	brcc	.+2      	; 0x1fa8 <vTaskIncrementTick+0xc2>
    1fa6:	6b c0       	rjmp	.+214    	; 0x207e <vTaskIncrementTick+0x198>
    1fa8:	e0 91 51 03 	lds	r30, 0x0351
    1fac:	f0 91 52 03 	lds	r31, 0x0352
    1fb0:	80 81       	ld	r24, Z
    1fb2:	88 23       	and	r24, r24
    1fb4:	39 f4       	brne	.+14     	; 0x1fc4 <vTaskIncrementTick+0xde>
    1fb6:	8f ef       	ldi	r24, 0xFF	; 255
    1fb8:	9f ef       	ldi	r25, 0xFF	; 255
    1fba:	90 93 6c 00 	sts	0x006C, r25
    1fbe:	80 93 6b 00 	sts	0x006B, r24
    1fc2:	5d c0       	rjmp	.+186    	; 0x207e <vTaskIncrementTick+0x198>
    1fc4:	e0 91 51 03 	lds	r30, 0x0351
    1fc8:	f0 91 52 03 	lds	r31, 0x0352
    1fcc:	05 80       	ldd	r0, Z+5	; 0x05
    1fce:	f6 81       	ldd	r31, Z+6	; 0x06
    1fd0:	e0 2d       	mov	r30, r0
    1fd2:	86 81       	ldd	r24, Z+6	; 0x06
    1fd4:	97 81       	ldd	r25, Z+7	; 0x07
    1fd6:	9e 83       	std	Y+6, r25	; 0x06
    1fd8:	8d 83       	std	Y+5, r24	; 0x05
    1fda:	ed 81       	ldd	r30, Y+5	; 0x05
    1fdc:	fe 81       	ldd	r31, Y+6	; 0x06
    1fde:	82 81       	ldd	r24, Z+2	; 0x02
    1fe0:	93 81       	ldd	r25, Z+3	; 0x03
    1fe2:	9a 83       	std	Y+2, r25	; 0x02
    1fe4:	89 83       	std	Y+1, r24	; 0x01
    1fe6:	20 91 08 03 	lds	r18, 0x0308
    1fea:	30 91 09 03 	lds	r19, 0x0309
    1fee:	89 81       	ldd	r24, Y+1	; 0x01
    1ff0:	9a 81       	ldd	r25, Y+2	; 0x02
    1ff2:	28 17       	cp	r18, r24
    1ff4:	39 07       	cpc	r19, r25
    1ff6:	38 f4       	brcc	.+14     	; 0x2006 <vTaskIncrementTick+0x120>
    1ff8:	89 81       	ldd	r24, Y+1	; 0x01
    1ffa:	9a 81       	ldd	r25, Y+2	; 0x02
    1ffc:	90 93 6c 00 	sts	0x006C, r25
    2000:	80 93 6b 00 	sts	0x006B, r24
    2004:	3c c0       	rjmp	.+120    	; 0x207e <vTaskIncrementTick+0x198>
    2006:	8d 81       	ldd	r24, Y+5	; 0x05
    2008:	9e 81       	ldd	r25, Y+6	; 0x06
    200a:	02 96       	adiw	r24, 0x02	; 2
    200c:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <vListRemove>
    2010:	ed 81       	ldd	r30, Y+5	; 0x05
    2012:	fe 81       	ldd	r31, Y+6	; 0x06
    2014:	84 89       	ldd	r24, Z+20	; 0x14
    2016:	95 89       	ldd	r25, Z+21	; 0x15
    2018:	00 97       	sbiw	r24, 0x00	; 0
    201a:	29 f0       	breq	.+10     	; 0x2026 <vTaskIncrementTick+0x140>
    201c:	8d 81       	ldd	r24, Y+5	; 0x05
    201e:	9e 81       	ldd	r25, Y+6	; 0x06
    2020:	0c 96       	adiw	r24, 0x0c	; 12
    2022:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <vListRemove>
    2026:	ed 81       	ldd	r30, Y+5	; 0x05
    2028:	fe 81       	ldd	r31, Y+6	; 0x06
    202a:	96 89       	ldd	r25, Z+22	; 0x16
    202c:	80 91 0b 03 	lds	r24, 0x030B
    2030:	89 17       	cp	r24, r25
    2032:	28 f4       	brcc	.+10     	; 0x203e <vTaskIncrementTick+0x158>
    2034:	ed 81       	ldd	r30, Y+5	; 0x05
    2036:	fe 81       	ldd	r31, Y+6	; 0x06
    2038:	86 89       	ldd	r24, Z+22	; 0x16
    203a:	80 93 0b 03 	sts	0x030B, r24
    203e:	ed 81       	ldd	r30, Y+5	; 0x05
    2040:	fe 81       	ldd	r31, Y+6	; 0x06
    2042:	86 89       	ldd	r24, Z+22	; 0x16
    2044:	28 2f       	mov	r18, r24
    2046:	30 e0       	ldi	r19, 0x00	; 0
    2048:	c9 01       	movw	r24, r18
    204a:	88 0f       	add	r24, r24
    204c:	99 1f       	adc	r25, r25
    204e:	88 0f       	add	r24, r24
    2050:	99 1f       	adc	r25, r25
    2052:	88 0f       	add	r24, r24
    2054:	99 1f       	adc	r25, r25
    2056:	82 0f       	add	r24, r18
    2058:	93 1f       	adc	r25, r19
    205a:	ac 01       	movw	r20, r24
    205c:	4e 5e       	subi	r20, 0xEE	; 238
    205e:	5c 4f       	sbci	r21, 0xFC	; 252
    2060:	8d 81       	ldd	r24, Y+5	; 0x05
    2062:	9e 81       	ldd	r25, Y+6	; 0x06
    2064:	9c 01       	movw	r18, r24
    2066:	2e 5f       	subi	r18, 0xFE	; 254
    2068:	3f 4f       	sbci	r19, 0xFF	; 255
    206a:	ca 01       	movw	r24, r20
    206c:	b9 01       	movw	r22, r18
    206e:	0e 94 18 04 	call	0x830	; 0x830 <vListInsertEnd>
    2072:	9a cf       	rjmp	.-204    	; 0x1fa8 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    2074:	80 91 0e 03 	lds	r24, 0x030E
    2078:	8f 5f       	subi	r24, 0xFF	; 255
    207a:	80 93 0e 03 	sts	0x030E, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    207e:	26 96       	adiw	r28, 0x06	; 6
    2080:	0f b6       	in	r0, 0x3f	; 63
    2082:	f8 94       	cli
    2084:	de bf       	out	0x3e, r29	; 62
    2086:	0f be       	out	0x3f, r0	; 63
    2088:	cd bf       	out	0x3d, r28	; 61
    208a:	cf 91       	pop	r28
    208c:	df 91       	pop	r29
    208e:	08 95       	ret

00002090 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    2090:	df 93       	push	r29
    2092:	cf 93       	push	r28
    2094:	00 d0       	rcall	.+0      	; 0x2096 <vTaskSwitchContext+0x6>
    2096:	cd b7       	in	r28, 0x3d	; 61
    2098:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    209a:	80 91 0d 03 	lds	r24, 0x030D
    209e:	88 23       	and	r24, r24
    20a0:	49 f0       	breq	.+18     	; 0x20b4 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    20a2:	81 e0       	ldi	r24, 0x01	; 1
    20a4:	80 93 0f 03 	sts	0x030F, r24
    20a8:	54 c0       	rjmp	.+168    	; 0x2152 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    20aa:	80 91 0b 03 	lds	r24, 0x030B
    20ae:	81 50       	subi	r24, 0x01	; 1
    20b0:	80 93 0b 03 	sts	0x030B, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    20b4:	80 91 0b 03 	lds	r24, 0x030B
    20b8:	28 2f       	mov	r18, r24
    20ba:	30 e0       	ldi	r19, 0x00	; 0
    20bc:	c9 01       	movw	r24, r18
    20be:	88 0f       	add	r24, r24
    20c0:	99 1f       	adc	r25, r25
    20c2:	88 0f       	add	r24, r24
    20c4:	99 1f       	adc	r25, r25
    20c6:	88 0f       	add	r24, r24
    20c8:	99 1f       	adc	r25, r25
    20ca:	82 0f       	add	r24, r18
    20cc:	93 1f       	adc	r25, r19
    20ce:	fc 01       	movw	r30, r24
    20d0:	ee 5e       	subi	r30, 0xEE	; 238
    20d2:	fc 4f       	sbci	r31, 0xFC	; 252
    20d4:	80 81       	ld	r24, Z
    20d6:	88 23       	and	r24, r24
    20d8:	41 f3       	breq	.-48     	; 0x20aa <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    20da:	80 91 0b 03 	lds	r24, 0x030B
    20de:	28 2f       	mov	r18, r24
    20e0:	30 e0       	ldi	r19, 0x00	; 0
    20e2:	c9 01       	movw	r24, r18
    20e4:	88 0f       	add	r24, r24
    20e6:	99 1f       	adc	r25, r25
    20e8:	88 0f       	add	r24, r24
    20ea:	99 1f       	adc	r25, r25
    20ec:	88 0f       	add	r24, r24
    20ee:	99 1f       	adc	r25, r25
    20f0:	82 0f       	add	r24, r18
    20f2:	93 1f       	adc	r25, r19
    20f4:	8e 5e       	subi	r24, 0xEE	; 238
    20f6:	9c 4f       	sbci	r25, 0xFC	; 252
    20f8:	9a 83       	std	Y+2, r25	; 0x02
    20fa:	89 83       	std	Y+1, r24	; 0x01
    20fc:	e9 81       	ldd	r30, Y+1	; 0x01
    20fe:	fa 81       	ldd	r31, Y+2	; 0x02
    2100:	01 80       	ldd	r0, Z+1	; 0x01
    2102:	f2 81       	ldd	r31, Z+2	; 0x02
    2104:	e0 2d       	mov	r30, r0
    2106:	82 81       	ldd	r24, Z+2	; 0x02
    2108:	93 81       	ldd	r25, Z+3	; 0x03
    210a:	e9 81       	ldd	r30, Y+1	; 0x01
    210c:	fa 81       	ldd	r31, Y+2	; 0x02
    210e:	92 83       	std	Z+2, r25	; 0x02
    2110:	81 83       	std	Z+1, r24	; 0x01
    2112:	e9 81       	ldd	r30, Y+1	; 0x01
    2114:	fa 81       	ldd	r31, Y+2	; 0x02
    2116:	21 81       	ldd	r18, Z+1	; 0x01
    2118:	32 81       	ldd	r19, Z+2	; 0x02
    211a:	89 81       	ldd	r24, Y+1	; 0x01
    211c:	9a 81       	ldd	r25, Y+2	; 0x02
    211e:	03 96       	adiw	r24, 0x03	; 3
    2120:	28 17       	cp	r18, r24
    2122:	39 07       	cpc	r19, r25
    2124:	59 f4       	brne	.+22     	; 0x213c <vTaskSwitchContext+0xac>
    2126:	e9 81       	ldd	r30, Y+1	; 0x01
    2128:	fa 81       	ldd	r31, Y+2	; 0x02
    212a:	01 80       	ldd	r0, Z+1	; 0x01
    212c:	f2 81       	ldd	r31, Z+2	; 0x02
    212e:	e0 2d       	mov	r30, r0
    2130:	82 81       	ldd	r24, Z+2	; 0x02
    2132:	93 81       	ldd	r25, Z+3	; 0x03
    2134:	e9 81       	ldd	r30, Y+1	; 0x01
    2136:	fa 81       	ldd	r31, Y+2	; 0x02
    2138:	92 83       	std	Z+2, r25	; 0x02
    213a:	81 83       	std	Z+1, r24	; 0x01
    213c:	e9 81       	ldd	r30, Y+1	; 0x01
    213e:	fa 81       	ldd	r31, Y+2	; 0x02
    2140:	01 80       	ldd	r0, Z+1	; 0x01
    2142:	f2 81       	ldd	r31, Z+2	; 0x02
    2144:	e0 2d       	mov	r30, r0
    2146:	86 81       	ldd	r24, Z+6	; 0x06
    2148:	97 81       	ldd	r25, Z+7	; 0x07
    214a:	90 93 05 03 	sts	0x0305, r25
    214e:	80 93 04 03 	sts	0x0304, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    2152:	0f 90       	pop	r0
    2154:	0f 90       	pop	r0
    2156:	cf 91       	pop	r28
    2158:	df 91       	pop	r29
    215a:	08 95       	ret

0000215c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    215c:	df 93       	push	r29
    215e:	cf 93       	push	r28
    2160:	00 d0       	rcall	.+0      	; 0x2162 <vTaskPlaceOnEventList+0x6>
    2162:	00 d0       	rcall	.+0      	; 0x2164 <vTaskPlaceOnEventList+0x8>
    2164:	00 d0       	rcall	.+0      	; 0x2166 <vTaskPlaceOnEventList+0xa>
    2166:	cd b7       	in	r28, 0x3d	; 61
    2168:	de b7       	in	r29, 0x3e	; 62
    216a:	9c 83       	std	Y+4, r25	; 0x04
    216c:	8b 83       	std	Y+3, r24	; 0x03
    216e:	7e 83       	std	Y+6, r23	; 0x06
    2170:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    2172:	4b 81       	ldd	r20, Y+3	; 0x03
    2174:	5c 81       	ldd	r21, Y+4	; 0x04
    2176:	80 91 04 03 	lds	r24, 0x0304
    217a:	90 91 05 03 	lds	r25, 0x0305
    217e:	9c 01       	movw	r18, r24
    2180:	24 5f       	subi	r18, 0xF4	; 244
    2182:	3f 4f       	sbci	r19, 0xFF	; 255
    2184:	ca 01       	movw	r24, r20
    2186:	b9 01       	movw	r22, r18
    2188:	0e 94 64 04 	call	0x8c8	; 0x8c8 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    218c:	80 91 04 03 	lds	r24, 0x0304
    2190:	90 91 05 03 	lds	r25, 0x0305
    2194:	02 96       	adiw	r24, 0x02	; 2
    2196:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    219a:	20 91 08 03 	lds	r18, 0x0308
    219e:	30 91 09 03 	lds	r19, 0x0309
    21a2:	8d 81       	ldd	r24, Y+5	; 0x05
    21a4:	9e 81       	ldd	r25, Y+6	; 0x06
    21a6:	82 0f       	add	r24, r18
    21a8:	93 1f       	adc	r25, r19
    21aa:	9a 83       	std	Y+2, r25	; 0x02
    21ac:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    21ae:	89 81       	ldd	r24, Y+1	; 0x01
    21b0:	9a 81       	ldd	r25, Y+2	; 0x02
    21b2:	0e 94 a8 12 	call	0x2550	; 0x2550 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    21b6:	26 96       	adiw	r28, 0x06	; 6
    21b8:	0f b6       	in	r0, 0x3f	; 63
    21ba:	f8 94       	cli
    21bc:	de bf       	out	0x3e, r29	; 62
    21be:	0f be       	out	0x3f, r0	; 63
    21c0:	cd bf       	out	0x3d, r28	; 61
    21c2:	cf 91       	pop	r28
    21c4:	df 91       	pop	r29
    21c6:	08 95       	ret

000021c8 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    21c8:	df 93       	push	r29
    21ca:	cf 93       	push	r28
    21cc:	00 d0       	rcall	.+0      	; 0x21ce <xTaskRemoveFromEventList+0x6>
    21ce:	00 d0       	rcall	.+0      	; 0x21d0 <xTaskRemoveFromEventList+0x8>
    21d0:	0f 92       	push	r0
    21d2:	cd b7       	in	r28, 0x3d	; 61
    21d4:	de b7       	in	r29, 0x3e	; 62
    21d6:	9d 83       	std	Y+5, r25	; 0x05
    21d8:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    21da:	ec 81       	ldd	r30, Y+4	; 0x04
    21dc:	fd 81       	ldd	r31, Y+5	; 0x05
    21de:	05 80       	ldd	r0, Z+5	; 0x05
    21e0:	f6 81       	ldd	r31, Z+6	; 0x06
    21e2:	e0 2d       	mov	r30, r0
    21e4:	86 81       	ldd	r24, Z+6	; 0x06
    21e6:	97 81       	ldd	r25, Z+7	; 0x07
    21e8:	9b 83       	std	Y+3, r25	; 0x03
    21ea:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    21ec:	8a 81       	ldd	r24, Y+2	; 0x02
    21ee:	9b 81       	ldd	r25, Y+3	; 0x03
    21f0:	0c 96       	adiw	r24, 0x0c	; 12
    21f2:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    21f6:	80 91 0d 03 	lds	r24, 0x030D
    21fa:	88 23       	and	r24, r24
    21fc:	61 f5       	brne	.+88     	; 0x2256 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    21fe:	8a 81       	ldd	r24, Y+2	; 0x02
    2200:	9b 81       	ldd	r25, Y+3	; 0x03
    2202:	02 96       	adiw	r24, 0x02	; 2
    2204:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2208:	ea 81       	ldd	r30, Y+2	; 0x02
    220a:	fb 81       	ldd	r31, Y+3	; 0x03
    220c:	96 89       	ldd	r25, Z+22	; 0x16
    220e:	80 91 0b 03 	lds	r24, 0x030B
    2212:	89 17       	cp	r24, r25
    2214:	28 f4       	brcc	.+10     	; 0x2220 <xTaskRemoveFromEventList+0x58>
    2216:	ea 81       	ldd	r30, Y+2	; 0x02
    2218:	fb 81       	ldd	r31, Y+3	; 0x03
    221a:	86 89       	ldd	r24, Z+22	; 0x16
    221c:	80 93 0b 03 	sts	0x030B, r24
    2220:	ea 81       	ldd	r30, Y+2	; 0x02
    2222:	fb 81       	ldd	r31, Y+3	; 0x03
    2224:	86 89       	ldd	r24, Z+22	; 0x16
    2226:	28 2f       	mov	r18, r24
    2228:	30 e0       	ldi	r19, 0x00	; 0
    222a:	c9 01       	movw	r24, r18
    222c:	88 0f       	add	r24, r24
    222e:	99 1f       	adc	r25, r25
    2230:	88 0f       	add	r24, r24
    2232:	99 1f       	adc	r25, r25
    2234:	88 0f       	add	r24, r24
    2236:	99 1f       	adc	r25, r25
    2238:	82 0f       	add	r24, r18
    223a:	93 1f       	adc	r25, r19
    223c:	ac 01       	movw	r20, r24
    223e:	4e 5e       	subi	r20, 0xEE	; 238
    2240:	5c 4f       	sbci	r21, 0xFC	; 252
    2242:	8a 81       	ldd	r24, Y+2	; 0x02
    2244:	9b 81       	ldd	r25, Y+3	; 0x03
    2246:	9c 01       	movw	r18, r24
    2248:	2e 5f       	subi	r18, 0xFE	; 254
    224a:	3f 4f       	sbci	r19, 0xFF	; 255
    224c:	ca 01       	movw	r24, r20
    224e:	b9 01       	movw	r22, r18
    2250:	0e 94 18 04 	call	0x830	; 0x830 <vListInsertEnd>
    2254:	0a c0       	rjmp	.+20     	; 0x226a <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2256:	8a 81       	ldd	r24, Y+2	; 0x02
    2258:	9b 81       	ldd	r25, Y+3	; 0x03
    225a:	9c 01       	movw	r18, r24
    225c:	24 5f       	subi	r18, 0xF4	; 244
    225e:	3f 4f       	sbci	r19, 0xFF	; 255
    2260:	85 e5       	ldi	r24, 0x55	; 85
    2262:	93 e0       	ldi	r25, 0x03	; 3
    2264:	b9 01       	movw	r22, r18
    2266:	0e 94 18 04 	call	0x830	; 0x830 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    226a:	ea 81       	ldd	r30, Y+2	; 0x02
    226c:	fb 81       	ldd	r31, Y+3	; 0x03
    226e:	96 89       	ldd	r25, Z+22	; 0x16
    2270:	e0 91 04 03 	lds	r30, 0x0304
    2274:	f0 91 05 03 	lds	r31, 0x0305
    2278:	86 89       	ldd	r24, Z+22	; 0x16
    227a:	98 17       	cp	r25, r24
    227c:	18 f0       	brcs	.+6      	; 0x2284 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    227e:	81 e0       	ldi	r24, 0x01	; 1
    2280:	89 83       	std	Y+1, r24	; 0x01
    2282:	01 c0       	rjmp	.+2      	; 0x2286 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    2284:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2286:	89 81       	ldd	r24, Y+1	; 0x01
}
    2288:	0f 90       	pop	r0
    228a:	0f 90       	pop	r0
    228c:	0f 90       	pop	r0
    228e:	0f 90       	pop	r0
    2290:	0f 90       	pop	r0
    2292:	cf 91       	pop	r28
    2294:	df 91       	pop	r29
    2296:	08 95       	ret

00002298 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2298:	df 93       	push	r29
    229a:	cf 93       	push	r28
    229c:	00 d0       	rcall	.+0      	; 0x229e <vTaskSetTimeOutState+0x6>
    229e:	cd b7       	in	r28, 0x3d	; 61
    22a0:	de b7       	in	r29, 0x3e	; 62
    22a2:	9a 83       	std	Y+2, r25	; 0x02
    22a4:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    22a6:	80 91 10 03 	lds	r24, 0x0310
    22aa:	e9 81       	ldd	r30, Y+1	; 0x01
    22ac:	fa 81       	ldd	r31, Y+2	; 0x02
    22ae:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    22b0:	80 91 08 03 	lds	r24, 0x0308
    22b4:	90 91 09 03 	lds	r25, 0x0309
    22b8:	e9 81       	ldd	r30, Y+1	; 0x01
    22ba:	fa 81       	ldd	r31, Y+2	; 0x02
    22bc:	92 83       	std	Z+2, r25	; 0x02
    22be:	81 83       	std	Z+1, r24	; 0x01
}
    22c0:	0f 90       	pop	r0
    22c2:	0f 90       	pop	r0
    22c4:	cf 91       	pop	r28
    22c6:	df 91       	pop	r29
    22c8:	08 95       	ret

000022ca <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    22ca:	df 93       	push	r29
    22cc:	cf 93       	push	r28
    22ce:	00 d0       	rcall	.+0      	; 0x22d0 <xTaskCheckForTimeOut+0x6>
    22d0:	00 d0       	rcall	.+0      	; 0x22d2 <xTaskCheckForTimeOut+0x8>
    22d2:	0f 92       	push	r0
    22d4:	cd b7       	in	r28, 0x3d	; 61
    22d6:	de b7       	in	r29, 0x3e	; 62
    22d8:	9b 83       	std	Y+3, r25	; 0x03
    22da:	8a 83       	std	Y+2, r24	; 0x02
    22dc:	7d 83       	std	Y+5, r23	; 0x05
    22de:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    22e0:	0f b6       	in	r0, 0x3f	; 63
    22e2:	f8 94       	cli
    22e4:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    22e6:	ea 81       	ldd	r30, Y+2	; 0x02
    22e8:	fb 81       	ldd	r31, Y+3	; 0x03
    22ea:	90 81       	ld	r25, Z
    22ec:	80 91 10 03 	lds	r24, 0x0310
    22f0:	98 17       	cp	r25, r24
    22f2:	71 f0       	breq	.+28     	; 0x2310 <xTaskCheckForTimeOut+0x46>
    22f4:	ea 81       	ldd	r30, Y+2	; 0x02
    22f6:	fb 81       	ldd	r31, Y+3	; 0x03
    22f8:	21 81       	ldd	r18, Z+1	; 0x01
    22fa:	32 81       	ldd	r19, Z+2	; 0x02
    22fc:	80 91 08 03 	lds	r24, 0x0308
    2300:	90 91 09 03 	lds	r25, 0x0309
    2304:	82 17       	cp	r24, r18
    2306:	93 07       	cpc	r25, r19
    2308:	18 f0       	brcs	.+6      	; 0x2310 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    230a:	81 e0       	ldi	r24, 0x01	; 1
    230c:	89 83       	std	Y+1, r24	; 0x01
    230e:	2f c0       	rjmp	.+94     	; 0x236e <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2310:	20 91 08 03 	lds	r18, 0x0308
    2314:	30 91 09 03 	lds	r19, 0x0309
    2318:	ea 81       	ldd	r30, Y+2	; 0x02
    231a:	fb 81       	ldd	r31, Y+3	; 0x03
    231c:	81 81       	ldd	r24, Z+1	; 0x01
    231e:	92 81       	ldd	r25, Z+2	; 0x02
    2320:	28 1b       	sub	r18, r24
    2322:	39 0b       	sbc	r19, r25
    2324:	ec 81       	ldd	r30, Y+4	; 0x04
    2326:	fd 81       	ldd	r31, Y+5	; 0x05
    2328:	80 81       	ld	r24, Z
    232a:	91 81       	ldd	r25, Z+1	; 0x01
    232c:	28 17       	cp	r18, r24
    232e:	39 07       	cpc	r19, r25
    2330:	e0 f4       	brcc	.+56     	; 0x236a <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    2332:	ec 81       	ldd	r30, Y+4	; 0x04
    2334:	fd 81       	ldd	r31, Y+5	; 0x05
    2336:	40 81       	ld	r20, Z
    2338:	51 81       	ldd	r21, Z+1	; 0x01
    233a:	ea 81       	ldd	r30, Y+2	; 0x02
    233c:	fb 81       	ldd	r31, Y+3	; 0x03
    233e:	21 81       	ldd	r18, Z+1	; 0x01
    2340:	32 81       	ldd	r19, Z+2	; 0x02
    2342:	80 91 08 03 	lds	r24, 0x0308
    2346:	90 91 09 03 	lds	r25, 0x0309
    234a:	b9 01       	movw	r22, r18
    234c:	68 1b       	sub	r22, r24
    234e:	79 0b       	sbc	r23, r25
    2350:	cb 01       	movw	r24, r22
    2352:	84 0f       	add	r24, r20
    2354:	95 1f       	adc	r25, r21
    2356:	ec 81       	ldd	r30, Y+4	; 0x04
    2358:	fd 81       	ldd	r31, Y+5	; 0x05
    235a:	91 83       	std	Z+1, r25	; 0x01
    235c:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    235e:	8a 81       	ldd	r24, Y+2	; 0x02
    2360:	9b 81       	ldd	r25, Y+3	; 0x03
    2362:	0e 94 4c 11 	call	0x2298	; 0x2298 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2366:	19 82       	std	Y+1, r1	; 0x01
    2368:	02 c0       	rjmp	.+4      	; 0x236e <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    236a:	81 e0       	ldi	r24, 0x01	; 1
    236c:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    236e:	0f 90       	pop	r0
    2370:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2372:	89 81       	ldd	r24, Y+1	; 0x01
}
    2374:	0f 90       	pop	r0
    2376:	0f 90       	pop	r0
    2378:	0f 90       	pop	r0
    237a:	0f 90       	pop	r0
    237c:	0f 90       	pop	r0
    237e:	cf 91       	pop	r28
    2380:	df 91       	pop	r29
    2382:	08 95       	ret

00002384 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2384:	df 93       	push	r29
    2386:	cf 93       	push	r28
    2388:	cd b7       	in	r28, 0x3d	; 61
    238a:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    238c:	81 e0       	ldi	r24, 0x01	; 1
    238e:	80 93 0f 03 	sts	0x030F, r24
}
    2392:	cf 91       	pop	r28
    2394:	df 91       	pop	r29
    2396:	08 95       	ret

00002398 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2398:	df 93       	push	r29
    239a:	cf 93       	push	r28
    239c:	00 d0       	rcall	.+0      	; 0x239e <prvIdleTask+0x6>
    239e:	cd b7       	in	r28, 0x3d	; 61
    23a0:	de b7       	in	r29, 0x3e	; 62
    23a2:	9a 83       	std	Y+2, r25	; 0x02
    23a4:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    23a6:	0e 94 6a 12 	call	0x24d4	; 0x24d4 <prvCheckTasksWaitingTermination>
    23aa:	fd cf       	rjmp	.-6      	; 0x23a6 <prvIdleTask+0xe>

000023ac <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    23ac:	0f 93       	push	r16
    23ae:	1f 93       	push	r17
    23b0:	df 93       	push	r29
    23b2:	cf 93       	push	r28
    23b4:	cd b7       	in	r28, 0x3d	; 61
    23b6:	de b7       	in	r29, 0x3e	; 62
    23b8:	29 97       	sbiw	r28, 0x09	; 9
    23ba:	0f b6       	in	r0, 0x3f	; 63
    23bc:	f8 94       	cli
    23be:	de bf       	out	0x3e, r29	; 62
    23c0:	0f be       	out	0x3f, r0	; 63
    23c2:	cd bf       	out	0x3d, r28	; 61
    23c4:	9a 83       	std	Y+2, r25	; 0x02
    23c6:	89 83       	std	Y+1, r24	; 0x01
    23c8:	7c 83       	std	Y+4, r23	; 0x04
    23ca:	6b 83       	std	Y+3, r22	; 0x03
    23cc:	4d 83       	std	Y+5, r20	; 0x05
    23ce:	3f 83       	std	Y+7, r19	; 0x07
    23d0:	2e 83       	std	Y+6, r18	; 0x06
    23d2:	19 87       	std	Y+9, r17	; 0x09
    23d4:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    23d6:	89 81       	ldd	r24, Y+1	; 0x01
    23d8:	9a 81       	ldd	r25, Y+2	; 0x02
    23da:	49 96       	adiw	r24, 0x19	; 25
    23dc:	2b 81       	ldd	r18, Y+3	; 0x03
    23de:	3c 81       	ldd	r19, Y+4	; 0x04
    23e0:	b9 01       	movw	r22, r18
    23e2:	48 e0       	ldi	r20, 0x08	; 8
    23e4:	50 e0       	ldi	r21, 0x00	; 0
    23e6:	0e 94 67 13 	call	0x26ce	; 0x26ce <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    23ea:	e9 81       	ldd	r30, Y+1	; 0x01
    23ec:	fa 81       	ldd	r31, Y+2	; 0x02
    23ee:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    23f0:	8d 81       	ldd	r24, Y+5	; 0x05
    23f2:	85 30       	cpi	r24, 0x05	; 5
    23f4:	10 f0       	brcs	.+4      	; 0x23fa <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    23f6:	84 e0       	ldi	r24, 0x04	; 4
    23f8:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    23fa:	e9 81       	ldd	r30, Y+1	; 0x01
    23fc:	fa 81       	ldd	r31, Y+2	; 0x02
    23fe:	8d 81       	ldd	r24, Y+5	; 0x05
    2400:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2402:	89 81       	ldd	r24, Y+1	; 0x01
    2404:	9a 81       	ldd	r25, Y+2	; 0x02
    2406:	02 96       	adiw	r24, 0x02	; 2
    2408:	0e 94 08 04 	call	0x810	; 0x810 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    240c:	89 81       	ldd	r24, Y+1	; 0x01
    240e:	9a 81       	ldd	r25, Y+2	; 0x02
    2410:	0c 96       	adiw	r24, 0x0c	; 12
    2412:	0e 94 08 04 	call	0x810	; 0x810 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2416:	e9 81       	ldd	r30, Y+1	; 0x01
    2418:	fa 81       	ldd	r31, Y+2	; 0x02
    241a:	89 81       	ldd	r24, Y+1	; 0x01
    241c:	9a 81       	ldd	r25, Y+2	; 0x02
    241e:	91 87       	std	Z+9, r25	; 0x09
    2420:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2422:	8d 81       	ldd	r24, Y+5	; 0x05
    2424:	28 2f       	mov	r18, r24
    2426:	30 e0       	ldi	r19, 0x00	; 0
    2428:	85 e0       	ldi	r24, 0x05	; 5
    242a:	90 e0       	ldi	r25, 0x00	; 0
    242c:	82 1b       	sub	r24, r18
    242e:	93 0b       	sbc	r25, r19
    2430:	e9 81       	ldd	r30, Y+1	; 0x01
    2432:	fa 81       	ldd	r31, Y+2	; 0x02
    2434:	95 87       	std	Z+13, r25	; 0x0d
    2436:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2438:	e9 81       	ldd	r30, Y+1	; 0x01
    243a:	fa 81       	ldd	r31, Y+2	; 0x02
    243c:	89 81       	ldd	r24, Y+1	; 0x01
    243e:	9a 81       	ldd	r25, Y+2	; 0x02
    2440:	93 8b       	std	Z+19, r25	; 0x13
    2442:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    2444:	29 96       	adiw	r28, 0x09	; 9
    2446:	0f b6       	in	r0, 0x3f	; 63
    2448:	f8 94       	cli
    244a:	de bf       	out	0x3e, r29	; 62
    244c:	0f be       	out	0x3f, r0	; 63
    244e:	cd bf       	out	0x3d, r28	; 61
    2450:	cf 91       	pop	r28
    2452:	df 91       	pop	r29
    2454:	1f 91       	pop	r17
    2456:	0f 91       	pop	r16
    2458:	08 95       	ret

0000245a <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    245a:	df 93       	push	r29
    245c:	cf 93       	push	r28
    245e:	0f 92       	push	r0
    2460:	cd b7       	in	r28, 0x3d	; 61
    2462:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2464:	19 82       	std	Y+1, r1	; 0x01
    2466:	13 c0       	rjmp	.+38     	; 0x248e <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2468:	89 81       	ldd	r24, Y+1	; 0x01
    246a:	28 2f       	mov	r18, r24
    246c:	30 e0       	ldi	r19, 0x00	; 0
    246e:	c9 01       	movw	r24, r18
    2470:	88 0f       	add	r24, r24
    2472:	99 1f       	adc	r25, r25
    2474:	88 0f       	add	r24, r24
    2476:	99 1f       	adc	r25, r25
    2478:	88 0f       	add	r24, r24
    247a:	99 1f       	adc	r25, r25
    247c:	82 0f       	add	r24, r18
    247e:	93 1f       	adc	r25, r19
    2480:	8e 5e       	subi	r24, 0xEE	; 238
    2482:	9c 4f       	sbci	r25, 0xFC	; 252
    2484:	0e 94 de 03 	call	0x7bc	; 0x7bc <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2488:	89 81       	ldd	r24, Y+1	; 0x01
    248a:	8f 5f       	subi	r24, 0xFF	; 255
    248c:	89 83       	std	Y+1, r24	; 0x01
    248e:	89 81       	ldd	r24, Y+1	; 0x01
    2490:	85 30       	cpi	r24, 0x05	; 5
    2492:	50 f3       	brcs	.-44     	; 0x2468 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2494:	8f e3       	ldi	r24, 0x3F	; 63
    2496:	93 e0       	ldi	r25, 0x03	; 3
    2498:	0e 94 de 03 	call	0x7bc	; 0x7bc <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    249c:	88 e4       	ldi	r24, 0x48	; 72
    249e:	93 e0       	ldi	r25, 0x03	; 3
    24a0:	0e 94 de 03 	call	0x7bc	; 0x7bc <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    24a4:	85 e5       	ldi	r24, 0x55	; 85
    24a6:	93 e0       	ldi	r25, 0x03	; 3
    24a8:	0e 94 de 03 	call	0x7bc	; 0x7bc <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    24ac:	8e e5       	ldi	r24, 0x5E	; 94
    24ae:	93 e0       	ldi	r25, 0x03	; 3
    24b0:	0e 94 de 03 	call	0x7bc	; 0x7bc <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    24b4:	8f e3       	ldi	r24, 0x3F	; 63
    24b6:	93 e0       	ldi	r25, 0x03	; 3
    24b8:	90 93 52 03 	sts	0x0352, r25
    24bc:	80 93 51 03 	sts	0x0351, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    24c0:	88 e4       	ldi	r24, 0x48	; 72
    24c2:	93 e0       	ldi	r25, 0x03	; 3
    24c4:	90 93 54 03 	sts	0x0354, r25
    24c8:	80 93 53 03 	sts	0x0353, r24
}
    24cc:	0f 90       	pop	r0
    24ce:	cf 91       	pop	r28
    24d0:	df 91       	pop	r29
    24d2:	08 95       	ret

000024d4 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    24d4:	df 93       	push	r29
    24d6:	cf 93       	push	r28
    24d8:	00 d0       	rcall	.+0      	; 0x24da <prvCheckTasksWaitingTermination+0x6>
    24da:	0f 92       	push	r0
    24dc:	cd b7       	in	r28, 0x3d	; 61
    24de:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    24e0:	80 91 06 03 	lds	r24, 0x0306
    24e4:	88 23       	and	r24, r24
    24e6:	71 f1       	breq	.+92     	; 0x2544 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    24e8:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    24ec:	80 91 5e 03 	lds	r24, 0x035E
    24f0:	1b 82       	std	Y+3, r1	; 0x03
    24f2:	88 23       	and	r24, r24
    24f4:	11 f4       	brne	.+4      	; 0x24fa <prvCheckTasksWaitingTermination+0x26>
    24f6:	81 e0       	ldi	r24, 0x01	; 1
    24f8:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    24fa:	0e 94 b4 0e 	call	0x1d68	; 0x1d68 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    24fe:	8b 81       	ldd	r24, Y+3	; 0x03
    2500:	88 23       	and	r24, r24
    2502:	01 f5       	brne	.+64     	; 0x2544 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    2504:	0f b6       	in	r0, 0x3f	; 63
    2506:	f8 94       	cli
    2508:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    250a:	e0 91 63 03 	lds	r30, 0x0363
    250e:	f0 91 64 03 	lds	r31, 0x0364
    2512:	86 81       	ldd	r24, Z+6	; 0x06
    2514:	97 81       	ldd	r25, Z+7	; 0x07
    2516:	9a 83       	std	Y+2, r25	; 0x02
    2518:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    251a:	89 81       	ldd	r24, Y+1	; 0x01
    251c:	9a 81       	ldd	r25, Y+2	; 0x02
    251e:	02 96       	adiw	r24, 0x02	; 2
    2520:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <vListRemove>
					--uxCurrentNumberOfTasks;
    2524:	80 91 07 03 	lds	r24, 0x0307
    2528:	81 50       	subi	r24, 0x01	; 1
    252a:	80 93 07 03 	sts	0x0307, r24
					--uxTasksDeleted;
    252e:	80 91 06 03 	lds	r24, 0x0306
    2532:	81 50       	subi	r24, 0x01	; 1
    2534:	80 93 06 03 	sts	0x0306, r24
				}
				taskEXIT_CRITICAL();
    2538:	0f 90       	pop	r0
    253a:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    253c:	89 81       	ldd	r24, Y+1	; 0x01
    253e:	9a 81       	ldd	r25, Y+2	; 0x02
    2540:	0e 94 41 13 	call	0x2682	; 0x2682 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    2544:	0f 90       	pop	r0
    2546:	0f 90       	pop	r0
    2548:	0f 90       	pop	r0
    254a:	cf 91       	pop	r28
    254c:	df 91       	pop	r29
    254e:	08 95       	ret

00002550 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    2550:	df 93       	push	r29
    2552:	cf 93       	push	r28
    2554:	00 d0       	rcall	.+0      	; 0x2556 <prvAddCurrentTaskToDelayedList+0x6>
    2556:	cd b7       	in	r28, 0x3d	; 61
    2558:	de b7       	in	r29, 0x3e	; 62
    255a:	9a 83       	std	Y+2, r25	; 0x02
    255c:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    255e:	e0 91 04 03 	lds	r30, 0x0304
    2562:	f0 91 05 03 	lds	r31, 0x0305
    2566:	89 81       	ldd	r24, Y+1	; 0x01
    2568:	9a 81       	ldd	r25, Y+2	; 0x02
    256a:	93 83       	std	Z+3, r25	; 0x03
    256c:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    256e:	20 91 08 03 	lds	r18, 0x0308
    2572:	30 91 09 03 	lds	r19, 0x0309
    2576:	89 81       	ldd	r24, Y+1	; 0x01
    2578:	9a 81       	ldd	r25, Y+2	; 0x02
    257a:	82 17       	cp	r24, r18
    257c:	93 07       	cpc	r25, r19
    257e:	70 f4       	brcc	.+28     	; 0x259c <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2580:	80 91 53 03 	lds	r24, 0x0353
    2584:	90 91 54 03 	lds	r25, 0x0354
    2588:	20 91 04 03 	lds	r18, 0x0304
    258c:	30 91 05 03 	lds	r19, 0x0305
    2590:	2e 5f       	subi	r18, 0xFE	; 254
    2592:	3f 4f       	sbci	r19, 0xFF	; 255
    2594:	b9 01       	movw	r22, r18
    2596:	0e 94 64 04 	call	0x8c8	; 0x8c8 <vListInsert>
    259a:	1e c0       	rjmp	.+60     	; 0x25d8 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    259c:	40 91 51 03 	lds	r20, 0x0351
    25a0:	50 91 52 03 	lds	r21, 0x0352
    25a4:	80 91 04 03 	lds	r24, 0x0304
    25a8:	90 91 05 03 	lds	r25, 0x0305
    25ac:	9c 01       	movw	r18, r24
    25ae:	2e 5f       	subi	r18, 0xFE	; 254
    25b0:	3f 4f       	sbci	r19, 0xFF	; 255
    25b2:	ca 01       	movw	r24, r20
    25b4:	b9 01       	movw	r22, r18
    25b6:	0e 94 64 04 	call	0x8c8	; 0x8c8 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    25ba:	20 91 6b 00 	lds	r18, 0x006B
    25be:	30 91 6c 00 	lds	r19, 0x006C
    25c2:	89 81       	ldd	r24, Y+1	; 0x01
    25c4:	9a 81       	ldd	r25, Y+2	; 0x02
    25c6:	82 17       	cp	r24, r18
    25c8:	93 07       	cpc	r25, r19
    25ca:	30 f4       	brcc	.+12     	; 0x25d8 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    25cc:	89 81       	ldd	r24, Y+1	; 0x01
    25ce:	9a 81       	ldd	r25, Y+2	; 0x02
    25d0:	90 93 6c 00 	sts	0x006C, r25
    25d4:	80 93 6b 00 	sts	0x006B, r24
		}
	}
}
    25d8:	0f 90       	pop	r0
    25da:	0f 90       	pop	r0
    25dc:	cf 91       	pop	r28
    25de:	df 91       	pop	r29
    25e0:	08 95       	ret

000025e2 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    25e2:	df 93       	push	r29
    25e4:	cf 93       	push	r28
    25e6:	cd b7       	in	r28, 0x3d	; 61
    25e8:	de b7       	in	r29, 0x3e	; 62
    25ea:	28 97       	sbiw	r28, 0x08	; 8
    25ec:	0f b6       	in	r0, 0x3f	; 63
    25ee:	f8 94       	cli
    25f0:	de bf       	out	0x3e, r29	; 62
    25f2:	0f be       	out	0x3f, r0	; 63
    25f4:	cd bf       	out	0x3d, r28	; 61
    25f6:	9c 83       	std	Y+4, r25	; 0x04
    25f8:	8b 83       	std	Y+3, r24	; 0x03
    25fa:	7e 83       	std	Y+6, r23	; 0x06
    25fc:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    25fe:	81 e2       	ldi	r24, 0x21	; 33
    2600:	90 e0       	ldi	r25, 0x00	; 0
    2602:	0e 94 72 03 	call	0x6e4	; 0x6e4 <pvPortMalloc>
    2606:	9a 83       	std	Y+2, r25	; 0x02
    2608:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    260a:	89 81       	ldd	r24, Y+1	; 0x01
    260c:	9a 81       	ldd	r25, Y+2	; 0x02
    260e:	00 97       	sbiw	r24, 0x00	; 0
    2610:	69 f1       	breq	.+90     	; 0x266c <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2612:	8d 81       	ldd	r24, Y+5	; 0x05
    2614:	9e 81       	ldd	r25, Y+6	; 0x06
    2616:	00 97       	sbiw	r24, 0x00	; 0
    2618:	39 f4       	brne	.+14     	; 0x2628 <prvAllocateTCBAndStack+0x46>
    261a:	8b 81       	ldd	r24, Y+3	; 0x03
    261c:	9c 81       	ldd	r25, Y+4	; 0x04
    261e:	0e 94 72 03 	call	0x6e4	; 0x6e4 <pvPortMalloc>
    2622:	98 87       	std	Y+8, r25	; 0x08
    2624:	8f 83       	std	Y+7, r24	; 0x07
    2626:	04 c0       	rjmp	.+8      	; 0x2630 <prvAllocateTCBAndStack+0x4e>
    2628:	8d 81       	ldd	r24, Y+5	; 0x05
    262a:	9e 81       	ldd	r25, Y+6	; 0x06
    262c:	98 87       	std	Y+8, r25	; 0x08
    262e:	8f 83       	std	Y+7, r24	; 0x07
    2630:	e9 81       	ldd	r30, Y+1	; 0x01
    2632:	fa 81       	ldd	r31, Y+2	; 0x02
    2634:	8f 81       	ldd	r24, Y+7	; 0x07
    2636:	98 85       	ldd	r25, Y+8	; 0x08
    2638:	90 8f       	std	Z+24, r25	; 0x18
    263a:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    263c:	e9 81       	ldd	r30, Y+1	; 0x01
    263e:	fa 81       	ldd	r31, Y+2	; 0x02
    2640:	87 89       	ldd	r24, Z+23	; 0x17
    2642:	90 8d       	ldd	r25, Z+24	; 0x18
    2644:	00 97       	sbiw	r24, 0x00	; 0
    2646:	39 f4       	brne	.+14     	; 0x2656 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2648:	89 81       	ldd	r24, Y+1	; 0x01
    264a:	9a 81       	ldd	r25, Y+2	; 0x02
    264c:	0e 94 b8 03 	call	0x770	; 0x770 <vPortFree>
			pxNewTCB = NULL;
    2650:	1a 82       	std	Y+2, r1	; 0x02
    2652:	19 82       	std	Y+1, r1	; 0x01
    2654:	0b c0       	rjmp	.+22     	; 0x266c <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    2656:	e9 81       	ldd	r30, Y+1	; 0x01
    2658:	fa 81       	ldd	r31, Y+2	; 0x02
    265a:	87 89       	ldd	r24, Z+23	; 0x17
    265c:	90 8d       	ldd	r25, Z+24	; 0x18
    265e:	2b 81       	ldd	r18, Y+3	; 0x03
    2660:	3c 81       	ldd	r19, Y+4	; 0x04
    2662:	65 ea       	ldi	r22, 0xA5	; 165
    2664:	70 e0       	ldi	r23, 0x00	; 0
    2666:	a9 01       	movw	r20, r18
    2668:	0e 94 60 13 	call	0x26c0	; 0x26c0 <memset>
		}
	}

	return pxNewTCB;
    266c:	89 81       	ldd	r24, Y+1	; 0x01
    266e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2670:	28 96       	adiw	r28, 0x08	; 8
    2672:	0f b6       	in	r0, 0x3f	; 63
    2674:	f8 94       	cli
    2676:	de bf       	out	0x3e, r29	; 62
    2678:	0f be       	out	0x3f, r0	; 63
    267a:	cd bf       	out	0x3d, r28	; 61
    267c:	cf 91       	pop	r28
    267e:	df 91       	pop	r29
    2680:	08 95       	ret

00002682 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    2682:	df 93       	push	r29
    2684:	cf 93       	push	r28
    2686:	00 d0       	rcall	.+0      	; 0x2688 <prvDeleteTCB+0x6>
    2688:	cd b7       	in	r28, 0x3d	; 61
    268a:	de b7       	in	r29, 0x3e	; 62
    268c:	9a 83       	std	Y+2, r25	; 0x02
    268e:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    2690:	e9 81       	ldd	r30, Y+1	; 0x01
    2692:	fa 81       	ldd	r31, Y+2	; 0x02
    2694:	87 89       	ldd	r24, Z+23	; 0x17
    2696:	90 8d       	ldd	r25, Z+24	; 0x18
    2698:	0e 94 b8 03 	call	0x770	; 0x770 <vPortFree>
		vPortFree( pxTCB );
    269c:	89 81       	ldd	r24, Y+1	; 0x01
    269e:	9a 81       	ldd	r25, Y+2	; 0x02
    26a0:	0e 94 b8 03 	call	0x770	; 0x770 <vPortFree>
	}
    26a4:	0f 90       	pop	r0
    26a6:	0f 90       	pop	r0
    26a8:	cf 91       	pop	r28
    26aa:	df 91       	pop	r29
    26ac:	08 95       	ret

000026ae <memcpy>:
    26ae:	fb 01       	movw	r30, r22
    26b0:	dc 01       	movw	r26, r24
    26b2:	02 c0       	rjmp	.+4      	; 0x26b8 <memcpy+0xa>
    26b4:	01 90       	ld	r0, Z+
    26b6:	0d 92       	st	X+, r0
    26b8:	41 50       	subi	r20, 0x01	; 1
    26ba:	50 40       	sbci	r21, 0x00	; 0
    26bc:	d8 f7       	brcc	.-10     	; 0x26b4 <memcpy+0x6>
    26be:	08 95       	ret

000026c0 <memset>:
    26c0:	dc 01       	movw	r26, r24
    26c2:	01 c0       	rjmp	.+2      	; 0x26c6 <memset+0x6>
    26c4:	6d 93       	st	X+, r22
    26c6:	41 50       	subi	r20, 0x01	; 1
    26c8:	50 40       	sbci	r21, 0x00	; 0
    26ca:	e0 f7       	brcc	.-8      	; 0x26c4 <memset+0x4>
    26cc:	08 95       	ret

000026ce <strncpy>:
    26ce:	fb 01       	movw	r30, r22
    26d0:	dc 01       	movw	r26, r24
    26d2:	41 50       	subi	r20, 0x01	; 1
    26d4:	50 40       	sbci	r21, 0x00	; 0
    26d6:	48 f0       	brcs	.+18     	; 0x26ea <strncpy+0x1c>
    26d8:	01 90       	ld	r0, Z+
    26da:	0d 92       	st	X+, r0
    26dc:	00 20       	and	r0, r0
    26de:	c9 f7       	brne	.-14     	; 0x26d2 <strncpy+0x4>
    26e0:	01 c0       	rjmp	.+2      	; 0x26e4 <strncpy+0x16>
    26e2:	1d 92       	st	X+, r1
    26e4:	41 50       	subi	r20, 0x01	; 1
    26e6:	50 40       	sbci	r21, 0x00	; 0
    26e8:	e0 f7       	brcc	.-8      	; 0x26e2 <strncpy+0x14>
    26ea:	08 95       	ret

000026ec <_exit>:
    26ec:	f8 94       	cli

000026ee <__stop_program>:
    26ee:	ff cf       	rjmp	.-2      	; 0x26ee <__stop_program>
