
RTOS_Task2_Pre-emption.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000276c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000014  00800060  0000276c  00002800  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002fb  00800074  00800074  00002814  2**0
                  ALLOC
  3 .stab         0000435c  00000000  00000000  00002814  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002963  00000000  00000000  00006b70  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 ff 07 	jmp	0xffe	; 0xffe <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec e6       	ldi	r30, 0x6C	; 108
      68:	f7 e2       	ldi	r31, 0x27	; 39
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a4 37       	cpi	r26, 0x74	; 116
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	a4 e7       	ldi	r26, 0x74	; 116
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	af 36       	cpi	r26, 0x6F	; 111
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 49 00 	call	0x92	; 0x92 <main>
      8a:	0c 94 b4 13 	jmp	0x2768	; 0x2768 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <main>:
      92:	af 92       	push	r10
      94:	bf 92       	push	r11
      96:	cf 92       	push	r12
      98:	df 92       	push	r13
      9a:	ef 92       	push	r14
      9c:	ff 92       	push	r15
      9e:	0f 93       	push	r16
      a0:	df 93       	push	r29
      a2:	cf 93       	push	r28
      a4:	cd b7       	in	r28, 0x3d	; 61
      a6:	de b7       	in	r29, 0x3e	; 62
      a8:	a7 e3       	ldi	r26, 0x37	; 55
      aa:	b0 e0       	ldi	r27, 0x00	; 0
      ac:	e7 e3       	ldi	r30, 0x37	; 55
      ae:	f0 e0       	ldi	r31, 0x00	; 0
      b0:	80 81       	ld	r24, Z
      b2:	81 60       	ori	r24, 0x01	; 1
      b4:	8c 93       	st	X, r24
      b6:	20 e6       	ldi	r18, 0x60	; 96
      b8:	30 e0       	ldi	r19, 0x00	; 0
      ba:	8f e8       	ldi	r24, 0x8F	; 143
      bc:	90 e0       	ldi	r25, 0x00	; 0
      be:	e4 e7       	ldi	r30, 0x74	; 116
      c0:	f0 e0       	ldi	r31, 0x00	; 0
      c2:	b9 01       	movw	r22, r18
      c4:	45 e5       	ldi	r20, 0x55	; 85
      c6:	50 e0       	ldi	r21, 0x00	; 0
      c8:	20 e0       	ldi	r18, 0x00	; 0
      ca:	30 e0       	ldi	r19, 0x00	; 0
      cc:	02 e0       	ldi	r16, 0x02	; 2
      ce:	7f 01       	movw	r14, r30
      d0:	cc 24       	eor	r12, r12
      d2:	dd 24       	eor	r13, r13
      d4:	aa 24       	eor	r10, r10
      d6:	bb 24       	eor	r11, r11
      d8:	0e 94 aa 0c 	call	0x1954	; 0x1954 <xTaskGenericCreate>
      dc:	26 e6       	ldi	r18, 0x66	; 102
      de:	30 e0       	ldi	r19, 0x00	; 0
      e0:	8e e9       	ldi	r24, 0x9E	; 158
      e2:	90 e0       	ldi	r25, 0x00	; 0
      e4:	e6 e7       	ldi	r30, 0x76	; 118
      e6:	f0 e0       	ldi	r31, 0x00	; 0
      e8:	b9 01       	movw	r22, r18
      ea:	45 e5       	ldi	r20, 0x55	; 85
      ec:	50 e0       	ldi	r21, 0x00	; 0
      ee:	20 e0       	ldi	r18, 0x00	; 0
      f0:	30 e0       	ldi	r19, 0x00	; 0
      f2:	03 e0       	ldi	r16, 0x03	; 3
      f4:	7f 01       	movw	r14, r30
      f6:	cc 24       	eor	r12, r12
      f8:	dd 24       	eor	r13, r13
      fa:	aa 24       	eor	r10, r10
      fc:	bb 24       	eor	r11, r11
      fe:	0e 94 aa 0c 	call	0x1954	; 0x1954 <xTaskGenericCreate>
     102:	0e 94 a3 0e 	call	0x1d46	; 0x1d46 <vTaskStartScheduler>
     106:	80 e0       	ldi	r24, 0x00	; 0
     108:	90 e0       	ldi	r25, 0x00	; 0
     10a:	cf 91       	pop	r28
     10c:	df 91       	pop	r29
     10e:	0f 91       	pop	r16
     110:	ff 90       	pop	r15
     112:	ef 90       	pop	r14
     114:	df 90       	pop	r13
     116:	cf 90       	pop	r12
     118:	bf 90       	pop	r11
     11a:	af 90       	pop	r10
     11c:	08 95       	ret

0000011e <LedOn_code>:
}

/*Task1 Code */


 void LedOn_code( void* pvParamter){
     11e:	df 93       	push	r29
     120:	cf 93       	push	r28
     122:	00 d0       	rcall	.+0      	; 0x124 <LedOn_code+0x6>
     124:	cd b7       	in	r28, 0x3d	; 61
     126:	de b7       	in	r29, 0x3e	; 62
     128:	9a 83       	std	Y+2, r25	; 0x02
     12a:	89 83       	std	Y+1, r24	; 0x01

	for (;;)
	{
		/*Turn On  Led */
		PORTB |= 0x01;
     12c:	a8 e3       	ldi	r26, 0x38	; 56
     12e:	b0 e0       	ldi	r27, 0x00	; 0
     130:	e8 e3       	ldi	r30, 0x38	; 56
     132:	f0 e0       	ldi	r31, 0x00	; 0
     134:	80 81       	ld	r24, Z
     136:	81 60       	ori	r24, 0x01	; 1
     138:	8c 93       	st	X, r24
     13a:	f8 cf       	rjmp	.-16     	; 0x12c <LedOn_code+0xe>

0000013c <LedOFF_code>:

	}
 }
 void LedOFF_code( void* pvParamter){
     13c:	df 93       	push	r29
     13e:	cf 93       	push	r28
     140:	00 d0       	rcall	.+0      	; 0x142 <LedOFF_code+0x6>
     142:	cd b7       	in	r28, 0x3d	; 61
     144:	de b7       	in	r29, 0x3e	; 62
     146:	9a 83       	std	Y+2, r25	; 0x02
     148:	89 83       	std	Y+1, r24	; 0x01

		vTaskDelay(2000);
     14a:	80 ed       	ldi	r24, 0xD0	; 208
     14c:	97 e0       	ldi	r25, 0x07	; 7
     14e:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <vTaskDelay>
		for (;;)
		{
			/*Turn Off Led */
			PORTB &= 0xFE;
     152:	a8 e3       	ldi	r26, 0x38	; 56
     154:	b0 e0       	ldi	r27, 0x00	; 0
     156:	e8 e3       	ldi	r30, 0x38	; 56
     158:	f0 e0       	ldi	r31, 0x00	; 0
     15a:	80 81       	ld	r24, Z
     15c:	8e 7f       	andi	r24, 0xFE	; 254
     15e:	8c 93       	st	X, r24
     160:	f8 cf       	rjmp	.-16     	; 0x152 <LedOFF_code+0x16>

00000162 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     162:	df 93       	push	r29
     164:	cf 93       	push	r28
     166:	cd b7       	in	r28, 0x3d	; 61
     168:	de b7       	in	r29, 0x3e	; 62
     16a:	27 97       	sbiw	r28, 0x07	; 7
     16c:	0f b6       	in	r0, 0x3f	; 63
     16e:	f8 94       	cli
     170:	de bf       	out	0x3e, r29	; 62
     172:	0f be       	out	0x3f, r0	; 63
     174:	cd bf       	out	0x3d, r28	; 61
     176:	9d 83       	std	Y+5, r25	; 0x05
     178:	8c 83       	std	Y+4, r24	; 0x04
     17a:	6e 83       	std	Y+6, r22	; 0x06
     17c:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     17e:	8a e1       	ldi	r24, 0x1A	; 26
     180:	90 e0       	ldi	r25, 0x00	; 0
     182:	0e 94 89 03 	call	0x712	; 0x712 <pvPortMalloc>
     186:	9a 83       	std	Y+2, r25	; 0x02
     188:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     18a:	89 81       	ldd	r24, Y+1	; 0x01
     18c:	9a 81       	ldd	r25, Y+2	; 0x02
     18e:	00 97       	sbiw	r24, 0x00	; 0
     190:	09 f4       	brne	.+2      	; 0x194 <xCoRoutineCreate+0x32>
     192:	6f c0       	rjmp	.+222    	; 0x272 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     194:	80 91 78 00 	lds	r24, 0x0078
     198:	90 91 79 00 	lds	r25, 0x0079
     19c:	00 97       	sbiw	r24, 0x00	; 0
     19e:	41 f4       	brne	.+16     	; 0x1b0 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     1a0:	89 81       	ldd	r24, Y+1	; 0x01
     1a2:	9a 81       	ldd	r25, Y+2	; 0x02
     1a4:	90 93 79 00 	sts	0x0079, r25
     1a8:	80 93 78 00 	sts	0x0078, r24
			prvInitialiseCoRoutineLists();
     1ac:	0e 94 18 03 	call	0x630	; 0x630 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     1b0:	8e 81       	ldd	r24, Y+6	; 0x06
     1b2:	82 30       	cpi	r24, 0x02	; 2
     1b4:	10 f0       	brcs	.+4      	; 0x1ba <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     1b6:	81 e0       	ldi	r24, 0x01	; 1
     1b8:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     1ba:	e9 81       	ldd	r30, Y+1	; 0x01
     1bc:	fa 81       	ldd	r31, Y+2	; 0x02
     1be:	11 8e       	std	Z+25, r1	; 0x19
     1c0:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     1c2:	e9 81       	ldd	r30, Y+1	; 0x01
     1c4:	fa 81       	ldd	r31, Y+2	; 0x02
     1c6:	8e 81       	ldd	r24, Y+6	; 0x06
     1c8:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     1ca:	e9 81       	ldd	r30, Y+1	; 0x01
     1cc:	fa 81       	ldd	r31, Y+2	; 0x02
     1ce:	8f 81       	ldd	r24, Y+7	; 0x07
     1d0:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     1d2:	e9 81       	ldd	r30, Y+1	; 0x01
     1d4:	fa 81       	ldd	r31, Y+2	; 0x02
     1d6:	8c 81       	ldd	r24, Y+4	; 0x04
     1d8:	9d 81       	ldd	r25, Y+5	; 0x05
     1da:	91 83       	std	Z+1, r25	; 0x01
     1dc:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     1de:	89 81       	ldd	r24, Y+1	; 0x01
     1e0:	9a 81       	ldd	r25, Y+2	; 0x02
     1e2:	02 96       	adiw	r24, 0x02	; 2
     1e4:	0e 94 1f 04 	call	0x83e	; 0x83e <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     1e8:	89 81       	ldd	r24, Y+1	; 0x01
     1ea:	9a 81       	ldd	r25, Y+2	; 0x02
     1ec:	0c 96       	adiw	r24, 0x0c	; 12
     1ee:	0e 94 1f 04 	call	0x83e	; 0x83e <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     1f2:	e9 81       	ldd	r30, Y+1	; 0x01
     1f4:	fa 81       	ldd	r31, Y+2	; 0x02
     1f6:	89 81       	ldd	r24, Y+1	; 0x01
     1f8:	9a 81       	ldd	r25, Y+2	; 0x02
     1fa:	91 87       	std	Z+9, r25	; 0x09
     1fc:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     1fe:	e9 81       	ldd	r30, Y+1	; 0x01
     200:	fa 81       	ldd	r31, Y+2	; 0x02
     202:	89 81       	ldd	r24, Y+1	; 0x01
     204:	9a 81       	ldd	r25, Y+2	; 0x02
     206:	93 8b       	std	Z+19, r25	; 0x13
     208:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     20a:	8e 81       	ldd	r24, Y+6	; 0x06
     20c:	28 2f       	mov	r18, r24
     20e:	30 e0       	ldi	r19, 0x00	; 0
     210:	85 e0       	ldi	r24, 0x05	; 5
     212:	90 e0       	ldi	r25, 0x00	; 0
     214:	82 1b       	sub	r24, r18
     216:	93 0b       	sbc	r25, r19
     218:	e9 81       	ldd	r30, Y+1	; 0x01
     21a:	fa 81       	ldd	r31, Y+2	; 0x02
     21c:	95 87       	std	Z+13, r25	; 0x0d
     21e:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     220:	e9 81       	ldd	r30, Y+1	; 0x01
     222:	fa 81       	ldd	r31, Y+2	; 0x02
     224:	96 89       	ldd	r25, Z+22	; 0x16
     226:	80 91 7a 00 	lds	r24, 0x007A
     22a:	89 17       	cp	r24, r25
     22c:	28 f4       	brcc	.+10     	; 0x238 <xCoRoutineCreate+0xd6>
     22e:	e9 81       	ldd	r30, Y+1	; 0x01
     230:	fa 81       	ldd	r31, Y+2	; 0x02
     232:	86 89       	ldd	r24, Z+22	; 0x16
     234:	80 93 7a 00 	sts	0x007A, r24
     238:	e9 81       	ldd	r30, Y+1	; 0x01
     23a:	fa 81       	ldd	r31, Y+2	; 0x02
     23c:	86 89       	ldd	r24, Z+22	; 0x16
     23e:	28 2f       	mov	r18, r24
     240:	30 e0       	ldi	r19, 0x00	; 0
     242:	c9 01       	movw	r24, r18
     244:	88 0f       	add	r24, r24
     246:	99 1f       	adc	r25, r25
     248:	88 0f       	add	r24, r24
     24a:	99 1f       	adc	r25, r25
     24c:	88 0f       	add	r24, r24
     24e:	99 1f       	adc	r25, r25
     250:	82 0f       	add	r24, r18
     252:	93 1f       	adc	r25, r19
     254:	ac 01       	movw	r20, r24
     256:	4f 57       	subi	r20, 0x7F	; 127
     258:	5f 4f       	sbci	r21, 0xFF	; 255
     25a:	89 81       	ldd	r24, Y+1	; 0x01
     25c:	9a 81       	ldd	r25, Y+2	; 0x02
     25e:	9c 01       	movw	r18, r24
     260:	2e 5f       	subi	r18, 0xFE	; 254
     262:	3f 4f       	sbci	r19, 0xFF	; 255
     264:	ca 01       	movw	r24, r20
     266:	b9 01       	movw	r22, r18
     268:	0e 94 2f 04 	call	0x85e	; 0x85e <vListInsertEnd>

		xReturn = pdPASS;
     26c:	81 e0       	ldi	r24, 0x01	; 1
     26e:	8b 83       	std	Y+3, r24	; 0x03
     270:	02 c0       	rjmp	.+4      	; 0x276 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     272:	8f ef       	ldi	r24, 0xFF	; 255
     274:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     276:	8b 81       	ldd	r24, Y+3	; 0x03
}
     278:	27 96       	adiw	r28, 0x07	; 7
     27a:	0f b6       	in	r0, 0x3f	; 63
     27c:	f8 94       	cli
     27e:	de bf       	out	0x3e, r29	; 62
     280:	0f be       	out	0x3f, r0	; 63
     282:	cd bf       	out	0x3d, r28	; 61
     284:	cf 91       	pop	r28
     286:	df 91       	pop	r29
     288:	08 95       	ret

0000028a <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     28a:	df 93       	push	r29
     28c:	cf 93       	push	r28
     28e:	00 d0       	rcall	.+0      	; 0x290 <vCoRoutineAddToDelayedList+0x6>
     290:	00 d0       	rcall	.+0      	; 0x292 <vCoRoutineAddToDelayedList+0x8>
     292:	00 d0       	rcall	.+0      	; 0x294 <vCoRoutineAddToDelayedList+0xa>
     294:	cd b7       	in	r28, 0x3d	; 61
     296:	de b7       	in	r29, 0x3e	; 62
     298:	9c 83       	std	Y+4, r25	; 0x04
     29a:	8b 83       	std	Y+3, r24	; 0x03
     29c:	7e 83       	std	Y+6, r23	; 0x06
     29e:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     2a0:	20 91 7b 00 	lds	r18, 0x007B
     2a4:	30 91 7c 00 	lds	r19, 0x007C
     2a8:	8b 81       	ldd	r24, Y+3	; 0x03
     2aa:	9c 81       	ldd	r25, Y+4	; 0x04
     2ac:	82 0f       	add	r24, r18
     2ae:	93 1f       	adc	r25, r19
     2b0:	9a 83       	std	Y+2, r25	; 0x02
     2b2:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     2b4:	80 91 78 00 	lds	r24, 0x0078
     2b8:	90 91 79 00 	lds	r25, 0x0079
     2bc:	02 96       	adiw	r24, 0x02	; 2
     2be:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     2c2:	e0 91 78 00 	lds	r30, 0x0078
     2c6:	f0 91 79 00 	lds	r31, 0x0079
     2ca:	89 81       	ldd	r24, Y+1	; 0x01
     2cc:	9a 81       	ldd	r25, Y+2	; 0x02
     2ce:	93 83       	std	Z+3, r25	; 0x03
     2d0:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     2d2:	20 91 7b 00 	lds	r18, 0x007B
     2d6:	30 91 7c 00 	lds	r19, 0x007C
     2da:	89 81       	ldd	r24, Y+1	; 0x01
     2dc:	9a 81       	ldd	r25, Y+2	; 0x02
     2de:	82 17       	cp	r24, r18
     2e0:	93 07       	cpc	r25, r19
     2e2:	70 f4       	brcc	.+28     	; 0x300 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     2e4:	80 91 a7 00 	lds	r24, 0x00A7
     2e8:	90 91 a8 00 	lds	r25, 0x00A8
     2ec:	20 91 78 00 	lds	r18, 0x0078
     2f0:	30 91 79 00 	lds	r19, 0x0079
     2f4:	2e 5f       	subi	r18, 0xFE	; 254
     2f6:	3f 4f       	sbci	r19, 0xFF	; 255
     2f8:	b9 01       	movw	r22, r18
     2fa:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <vListInsert>
     2fe:	0d c0       	rjmp	.+26     	; 0x31a <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     300:	80 91 a5 00 	lds	r24, 0x00A5
     304:	90 91 a6 00 	lds	r25, 0x00A6
     308:	20 91 78 00 	lds	r18, 0x0078
     30c:	30 91 79 00 	lds	r19, 0x0079
     310:	2e 5f       	subi	r18, 0xFE	; 254
     312:	3f 4f       	sbci	r19, 0xFF	; 255
     314:	b9 01       	movw	r22, r18
     316:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <vListInsert>
	}

	if( pxEventList )
     31a:	8d 81       	ldd	r24, Y+5	; 0x05
     31c:	9e 81       	ldd	r25, Y+6	; 0x06
     31e:	00 97       	sbiw	r24, 0x00	; 0
     320:	61 f0       	breq	.+24     	; 0x33a <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     322:	80 91 78 00 	lds	r24, 0x0078
     326:	90 91 79 00 	lds	r25, 0x0079
     32a:	9c 01       	movw	r18, r24
     32c:	24 5f       	subi	r18, 0xF4	; 244
     32e:	3f 4f       	sbci	r19, 0xFF	; 255
     330:	8d 81       	ldd	r24, Y+5	; 0x05
     332:	9e 81       	ldd	r25, Y+6	; 0x06
     334:	b9 01       	movw	r22, r18
     336:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <vListInsert>
	}
}
     33a:	26 96       	adiw	r28, 0x06	; 6
     33c:	0f b6       	in	r0, 0x3f	; 63
     33e:	f8 94       	cli
     340:	de bf       	out	0x3e, r29	; 62
     342:	0f be       	out	0x3f, r0	; 63
     344:	cd bf       	out	0x3d, r28	; 61
     346:	cf 91       	pop	r28
     348:	df 91       	pop	r29
     34a:	08 95       	ret

0000034c <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     34c:	df 93       	push	r29
     34e:	cf 93       	push	r28
     350:	00 d0       	rcall	.+0      	; 0x352 <prvCheckPendingReadyList+0x6>
     352:	cd b7       	in	r28, 0x3d	; 61
     354:	de b7       	in	r29, 0x3e	; 62
     356:	3a c0       	rjmp	.+116    	; 0x3cc <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     358:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     35a:	e0 91 ae 00 	lds	r30, 0x00AE
     35e:	f0 91 af 00 	lds	r31, 0x00AF
     362:	86 81       	ldd	r24, Z+6	; 0x06
     364:	97 81       	ldd	r25, Z+7	; 0x07
     366:	9a 83       	std	Y+2, r25	; 0x02
     368:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     36a:	89 81       	ldd	r24, Y+1	; 0x01
     36c:	9a 81       	ldd	r25, Y+2	; 0x02
     36e:	0c 96       	adiw	r24, 0x0c	; 12
     370:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListRemove>
		}
		portENABLE_INTERRUPTS();
     374:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     376:	89 81       	ldd	r24, Y+1	; 0x01
     378:	9a 81       	ldd	r25, Y+2	; 0x02
     37a:	02 96       	adiw	r24, 0x02	; 2
     37c:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     380:	e9 81       	ldd	r30, Y+1	; 0x01
     382:	fa 81       	ldd	r31, Y+2	; 0x02
     384:	96 89       	ldd	r25, Z+22	; 0x16
     386:	80 91 7a 00 	lds	r24, 0x007A
     38a:	89 17       	cp	r24, r25
     38c:	28 f4       	brcc	.+10     	; 0x398 <prvCheckPendingReadyList+0x4c>
     38e:	e9 81       	ldd	r30, Y+1	; 0x01
     390:	fa 81       	ldd	r31, Y+2	; 0x02
     392:	86 89       	ldd	r24, Z+22	; 0x16
     394:	80 93 7a 00 	sts	0x007A, r24
     398:	e9 81       	ldd	r30, Y+1	; 0x01
     39a:	fa 81       	ldd	r31, Y+2	; 0x02
     39c:	86 89       	ldd	r24, Z+22	; 0x16
     39e:	28 2f       	mov	r18, r24
     3a0:	30 e0       	ldi	r19, 0x00	; 0
     3a2:	c9 01       	movw	r24, r18
     3a4:	88 0f       	add	r24, r24
     3a6:	99 1f       	adc	r25, r25
     3a8:	88 0f       	add	r24, r24
     3aa:	99 1f       	adc	r25, r25
     3ac:	88 0f       	add	r24, r24
     3ae:	99 1f       	adc	r25, r25
     3b0:	82 0f       	add	r24, r18
     3b2:	93 1f       	adc	r25, r19
     3b4:	ac 01       	movw	r20, r24
     3b6:	4f 57       	subi	r20, 0x7F	; 127
     3b8:	5f 4f       	sbci	r21, 0xFF	; 255
     3ba:	89 81       	ldd	r24, Y+1	; 0x01
     3bc:	9a 81       	ldd	r25, Y+2	; 0x02
     3be:	9c 01       	movw	r18, r24
     3c0:	2e 5f       	subi	r18, 0xFE	; 254
     3c2:	3f 4f       	sbci	r19, 0xFF	; 255
     3c4:	ca 01       	movw	r24, r20
     3c6:	b9 01       	movw	r22, r18
     3c8:	0e 94 2f 04 	call	0x85e	; 0x85e <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     3cc:	80 91 a9 00 	lds	r24, 0x00A9
     3d0:	88 23       	and	r24, r24
     3d2:	09 f0       	breq	.+2      	; 0x3d6 <prvCheckPendingReadyList+0x8a>
     3d4:	c1 cf       	rjmp	.-126    	; 0x358 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     3d6:	0f 90       	pop	r0
     3d8:	0f 90       	pop	r0
     3da:	cf 91       	pop	r28
     3dc:	df 91       	pop	r29
     3de:	08 95       	ret

000003e0 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     3e0:	df 93       	push	r29
     3e2:	cf 93       	push	r28
     3e4:	00 d0       	rcall	.+0      	; 0x3e6 <prvCheckDelayedList+0x6>
     3e6:	00 d0       	rcall	.+0      	; 0x3e8 <prvCheckDelayedList+0x8>
     3e8:	cd b7       	in	r28, 0x3d	; 61
     3ea:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     3ec:	0e 94 7a 0f 	call	0x1ef4	; 0x1ef4 <xTaskGetTickCount>
     3f0:	20 91 7d 00 	lds	r18, 0x007D
     3f4:	30 91 7e 00 	lds	r19, 0x007E
     3f8:	82 1b       	sub	r24, r18
     3fa:	93 0b       	sbc	r25, r19
     3fc:	90 93 80 00 	sts	0x0080, r25
     400:	80 93 7f 00 	sts	0x007F, r24
     404:	85 c0       	rjmp	.+266    	; 0x510 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     406:	80 91 7b 00 	lds	r24, 0x007B
     40a:	90 91 7c 00 	lds	r25, 0x007C
     40e:	01 96       	adiw	r24, 0x01	; 1
     410:	90 93 7c 00 	sts	0x007C, r25
     414:	80 93 7b 00 	sts	0x007B, r24
		xPassedTicks--;
     418:	80 91 7f 00 	lds	r24, 0x007F
     41c:	90 91 80 00 	lds	r25, 0x0080
     420:	01 97       	sbiw	r24, 0x01	; 1
     422:	90 93 80 00 	sts	0x0080, r25
     426:	80 93 7f 00 	sts	0x007F, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     42a:	80 91 7b 00 	lds	r24, 0x007B
     42e:	90 91 7c 00 	lds	r25, 0x007C
     432:	00 97       	sbiw	r24, 0x00	; 0
     434:	09 f0       	breq	.+2      	; 0x438 <prvCheckDelayedList+0x58>
     436:	64 c0       	rjmp	.+200    	; 0x500 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     438:	80 91 a5 00 	lds	r24, 0x00A5
     43c:	90 91 a6 00 	lds	r25, 0x00A6
     440:	9a 83       	std	Y+2, r25	; 0x02
     442:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     444:	80 91 a7 00 	lds	r24, 0x00A7
     448:	90 91 a8 00 	lds	r25, 0x00A8
     44c:	90 93 a6 00 	sts	0x00A6, r25
     450:	80 93 a5 00 	sts	0x00A5, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     454:	89 81       	ldd	r24, Y+1	; 0x01
     456:	9a 81       	ldd	r25, Y+2	; 0x02
     458:	90 93 a8 00 	sts	0x00A8, r25
     45c:	80 93 a7 00 	sts	0x00A7, r24
     460:	4f c0       	rjmp	.+158    	; 0x500 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     462:	e0 91 a5 00 	lds	r30, 0x00A5
     466:	f0 91 a6 00 	lds	r31, 0x00A6
     46a:	05 80       	ldd	r0, Z+5	; 0x05
     46c:	f6 81       	ldd	r31, Z+6	; 0x06
     46e:	e0 2d       	mov	r30, r0
     470:	86 81       	ldd	r24, Z+6	; 0x06
     472:	97 81       	ldd	r25, Z+7	; 0x07
     474:	9c 83       	std	Y+4, r25	; 0x04
     476:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     478:	eb 81       	ldd	r30, Y+3	; 0x03
     47a:	fc 81       	ldd	r31, Y+4	; 0x04
     47c:	22 81       	ldd	r18, Z+2	; 0x02
     47e:	33 81       	ldd	r19, Z+3	; 0x03
     480:	80 91 7b 00 	lds	r24, 0x007B
     484:	90 91 7c 00 	lds	r25, 0x007C
     488:	82 17       	cp	r24, r18
     48a:	93 07       	cpc	r25, r19
     48c:	08 f4       	brcc	.+2      	; 0x490 <prvCheckDelayedList+0xb0>
     48e:	40 c0       	rjmp	.+128    	; 0x510 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     490:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     492:	8b 81       	ldd	r24, Y+3	; 0x03
     494:	9c 81       	ldd	r25, Y+4	; 0x04
     496:	02 96       	adiw	r24, 0x02	; 2
     498:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     49c:	eb 81       	ldd	r30, Y+3	; 0x03
     49e:	fc 81       	ldd	r31, Y+4	; 0x04
     4a0:	84 89       	ldd	r24, Z+20	; 0x14
     4a2:	95 89       	ldd	r25, Z+21	; 0x15
     4a4:	00 97       	sbiw	r24, 0x00	; 0
     4a6:	29 f0       	breq	.+10     	; 0x4b2 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     4a8:	8b 81       	ldd	r24, Y+3	; 0x03
     4aa:	9c 81       	ldd	r25, Y+4	; 0x04
     4ac:	0c 96       	adiw	r24, 0x0c	; 12
     4ae:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     4b2:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     4b4:	eb 81       	ldd	r30, Y+3	; 0x03
     4b6:	fc 81       	ldd	r31, Y+4	; 0x04
     4b8:	96 89       	ldd	r25, Z+22	; 0x16
     4ba:	80 91 7a 00 	lds	r24, 0x007A
     4be:	89 17       	cp	r24, r25
     4c0:	28 f4       	brcc	.+10     	; 0x4cc <prvCheckDelayedList+0xec>
     4c2:	eb 81       	ldd	r30, Y+3	; 0x03
     4c4:	fc 81       	ldd	r31, Y+4	; 0x04
     4c6:	86 89       	ldd	r24, Z+22	; 0x16
     4c8:	80 93 7a 00 	sts	0x007A, r24
     4cc:	eb 81       	ldd	r30, Y+3	; 0x03
     4ce:	fc 81       	ldd	r31, Y+4	; 0x04
     4d0:	86 89       	ldd	r24, Z+22	; 0x16
     4d2:	28 2f       	mov	r18, r24
     4d4:	30 e0       	ldi	r19, 0x00	; 0
     4d6:	c9 01       	movw	r24, r18
     4d8:	88 0f       	add	r24, r24
     4da:	99 1f       	adc	r25, r25
     4dc:	88 0f       	add	r24, r24
     4de:	99 1f       	adc	r25, r25
     4e0:	88 0f       	add	r24, r24
     4e2:	99 1f       	adc	r25, r25
     4e4:	82 0f       	add	r24, r18
     4e6:	93 1f       	adc	r25, r19
     4e8:	ac 01       	movw	r20, r24
     4ea:	4f 57       	subi	r20, 0x7F	; 127
     4ec:	5f 4f       	sbci	r21, 0xFF	; 255
     4ee:	8b 81       	ldd	r24, Y+3	; 0x03
     4f0:	9c 81       	ldd	r25, Y+4	; 0x04
     4f2:	9c 01       	movw	r18, r24
     4f4:	2e 5f       	subi	r18, 0xFE	; 254
     4f6:	3f 4f       	sbci	r19, 0xFF	; 255
     4f8:	ca 01       	movw	r24, r20
     4fa:	b9 01       	movw	r22, r18
     4fc:	0e 94 2f 04 	call	0x85e	; 0x85e <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     500:	e0 91 a5 00 	lds	r30, 0x00A5
     504:	f0 91 a6 00 	lds	r31, 0x00A6
     508:	80 81       	ld	r24, Z
     50a:	88 23       	and	r24, r24
     50c:	09 f0       	breq	.+2      	; 0x510 <prvCheckDelayedList+0x130>
     50e:	a9 cf       	rjmp	.-174    	; 0x462 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     510:	80 91 7f 00 	lds	r24, 0x007F
     514:	90 91 80 00 	lds	r25, 0x0080
     518:	00 97       	sbiw	r24, 0x00	; 0
     51a:	09 f0       	breq	.+2      	; 0x51e <prvCheckDelayedList+0x13e>
     51c:	74 cf       	rjmp	.-280    	; 0x406 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     51e:	80 91 7b 00 	lds	r24, 0x007B
     522:	90 91 7c 00 	lds	r25, 0x007C
     526:	90 93 7e 00 	sts	0x007E, r25
     52a:	80 93 7d 00 	sts	0x007D, r24
}
     52e:	0f 90       	pop	r0
     530:	0f 90       	pop	r0
     532:	0f 90       	pop	r0
     534:	0f 90       	pop	r0
     536:	cf 91       	pop	r28
     538:	df 91       	pop	r29
     53a:	08 95       	ret

0000053c <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     53c:	df 93       	push	r29
     53e:	cf 93       	push	r28
     540:	00 d0       	rcall	.+0      	; 0x542 <vCoRoutineSchedule+0x6>
     542:	cd b7       	in	r28, 0x3d	; 61
     544:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     546:	0e 94 a6 01 	call	0x34c	; 0x34c <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     54a:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <prvCheckDelayedList>
     54e:	0a c0       	rjmp	.+20     	; 0x564 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     550:	80 91 7a 00 	lds	r24, 0x007A
     554:	88 23       	and	r24, r24
     556:	09 f4       	brne	.+2      	; 0x55a <vCoRoutineSchedule+0x1e>
     558:	66 c0       	rjmp	.+204    	; 0x626 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     55a:	80 91 7a 00 	lds	r24, 0x007A
     55e:	81 50       	subi	r24, 0x01	; 1
     560:	80 93 7a 00 	sts	0x007A, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     564:	80 91 7a 00 	lds	r24, 0x007A
     568:	28 2f       	mov	r18, r24
     56a:	30 e0       	ldi	r19, 0x00	; 0
     56c:	c9 01       	movw	r24, r18
     56e:	88 0f       	add	r24, r24
     570:	99 1f       	adc	r25, r25
     572:	88 0f       	add	r24, r24
     574:	99 1f       	adc	r25, r25
     576:	88 0f       	add	r24, r24
     578:	99 1f       	adc	r25, r25
     57a:	82 0f       	add	r24, r18
     57c:	93 1f       	adc	r25, r19
     57e:	fc 01       	movw	r30, r24
     580:	ef 57       	subi	r30, 0x7F	; 127
     582:	ff 4f       	sbci	r31, 0xFF	; 255
     584:	80 81       	ld	r24, Z
     586:	88 23       	and	r24, r24
     588:	19 f3       	breq	.-58     	; 0x550 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     58a:	80 91 7a 00 	lds	r24, 0x007A
     58e:	28 2f       	mov	r18, r24
     590:	30 e0       	ldi	r19, 0x00	; 0
     592:	c9 01       	movw	r24, r18
     594:	88 0f       	add	r24, r24
     596:	99 1f       	adc	r25, r25
     598:	88 0f       	add	r24, r24
     59a:	99 1f       	adc	r25, r25
     59c:	88 0f       	add	r24, r24
     59e:	99 1f       	adc	r25, r25
     5a0:	82 0f       	add	r24, r18
     5a2:	93 1f       	adc	r25, r19
     5a4:	8f 57       	subi	r24, 0x7F	; 127
     5a6:	9f 4f       	sbci	r25, 0xFF	; 255
     5a8:	9a 83       	std	Y+2, r25	; 0x02
     5aa:	89 83       	std	Y+1, r24	; 0x01
     5ac:	e9 81       	ldd	r30, Y+1	; 0x01
     5ae:	fa 81       	ldd	r31, Y+2	; 0x02
     5b0:	01 80       	ldd	r0, Z+1	; 0x01
     5b2:	f2 81       	ldd	r31, Z+2	; 0x02
     5b4:	e0 2d       	mov	r30, r0
     5b6:	82 81       	ldd	r24, Z+2	; 0x02
     5b8:	93 81       	ldd	r25, Z+3	; 0x03
     5ba:	e9 81       	ldd	r30, Y+1	; 0x01
     5bc:	fa 81       	ldd	r31, Y+2	; 0x02
     5be:	92 83       	std	Z+2, r25	; 0x02
     5c0:	81 83       	std	Z+1, r24	; 0x01
     5c2:	e9 81       	ldd	r30, Y+1	; 0x01
     5c4:	fa 81       	ldd	r31, Y+2	; 0x02
     5c6:	21 81       	ldd	r18, Z+1	; 0x01
     5c8:	32 81       	ldd	r19, Z+2	; 0x02
     5ca:	89 81       	ldd	r24, Y+1	; 0x01
     5cc:	9a 81       	ldd	r25, Y+2	; 0x02
     5ce:	03 96       	adiw	r24, 0x03	; 3
     5d0:	28 17       	cp	r18, r24
     5d2:	39 07       	cpc	r19, r25
     5d4:	59 f4       	brne	.+22     	; 0x5ec <vCoRoutineSchedule+0xb0>
     5d6:	e9 81       	ldd	r30, Y+1	; 0x01
     5d8:	fa 81       	ldd	r31, Y+2	; 0x02
     5da:	01 80       	ldd	r0, Z+1	; 0x01
     5dc:	f2 81       	ldd	r31, Z+2	; 0x02
     5de:	e0 2d       	mov	r30, r0
     5e0:	82 81       	ldd	r24, Z+2	; 0x02
     5e2:	93 81       	ldd	r25, Z+3	; 0x03
     5e4:	e9 81       	ldd	r30, Y+1	; 0x01
     5e6:	fa 81       	ldd	r31, Y+2	; 0x02
     5e8:	92 83       	std	Z+2, r25	; 0x02
     5ea:	81 83       	std	Z+1, r24	; 0x01
     5ec:	e9 81       	ldd	r30, Y+1	; 0x01
     5ee:	fa 81       	ldd	r31, Y+2	; 0x02
     5f0:	01 80       	ldd	r0, Z+1	; 0x01
     5f2:	f2 81       	ldd	r31, Z+2	; 0x02
     5f4:	e0 2d       	mov	r30, r0
     5f6:	86 81       	ldd	r24, Z+6	; 0x06
     5f8:	97 81       	ldd	r25, Z+7	; 0x07
     5fa:	90 93 79 00 	sts	0x0079, r25
     5fe:	80 93 78 00 	sts	0x0078, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     602:	e0 91 78 00 	lds	r30, 0x0078
     606:	f0 91 79 00 	lds	r31, 0x0079
     60a:	40 81       	ld	r20, Z
     60c:	51 81       	ldd	r21, Z+1	; 0x01
     60e:	80 91 78 00 	lds	r24, 0x0078
     612:	90 91 79 00 	lds	r25, 0x0079
     616:	e0 91 78 00 	lds	r30, 0x0078
     61a:	f0 91 79 00 	lds	r31, 0x0079
     61e:	27 89       	ldd	r18, Z+23	; 0x17
     620:	62 2f       	mov	r22, r18
     622:	fa 01       	movw	r30, r20
     624:	09 95       	icall

	return;
}
     626:	0f 90       	pop	r0
     628:	0f 90       	pop	r0
     62a:	cf 91       	pop	r28
     62c:	df 91       	pop	r29
     62e:	08 95       	ret

00000630 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     630:	df 93       	push	r29
     632:	cf 93       	push	r28
     634:	0f 92       	push	r0
     636:	cd b7       	in	r28, 0x3d	; 61
     638:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     63a:	19 82       	std	Y+1, r1	; 0x01
     63c:	13 c0       	rjmp	.+38     	; 0x664 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     63e:	89 81       	ldd	r24, Y+1	; 0x01
     640:	28 2f       	mov	r18, r24
     642:	30 e0       	ldi	r19, 0x00	; 0
     644:	c9 01       	movw	r24, r18
     646:	88 0f       	add	r24, r24
     648:	99 1f       	adc	r25, r25
     64a:	88 0f       	add	r24, r24
     64c:	99 1f       	adc	r25, r25
     64e:	88 0f       	add	r24, r24
     650:	99 1f       	adc	r25, r25
     652:	82 0f       	add	r24, r18
     654:	93 1f       	adc	r25, r19
     656:	8f 57       	subi	r24, 0x7F	; 127
     658:	9f 4f       	sbci	r25, 0xFF	; 255
     65a:	0e 94 f5 03 	call	0x7ea	; 0x7ea <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     65e:	89 81       	ldd	r24, Y+1	; 0x01
     660:	8f 5f       	subi	r24, 0xFF	; 255
     662:	89 83       	std	Y+1, r24	; 0x01
     664:	89 81       	ldd	r24, Y+1	; 0x01
     666:	82 30       	cpi	r24, 0x02	; 2
     668:	50 f3       	brcs	.-44     	; 0x63e <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     66a:	83 e9       	ldi	r24, 0x93	; 147
     66c:	90 e0       	ldi	r25, 0x00	; 0
     66e:	0e 94 f5 03 	call	0x7ea	; 0x7ea <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     672:	8c e9       	ldi	r24, 0x9C	; 156
     674:	90 e0       	ldi	r25, 0x00	; 0
     676:	0e 94 f5 03 	call	0x7ea	; 0x7ea <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     67a:	89 ea       	ldi	r24, 0xA9	; 169
     67c:	90 e0       	ldi	r25, 0x00	; 0
     67e:	0e 94 f5 03 	call	0x7ea	; 0x7ea <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     682:	83 e9       	ldi	r24, 0x93	; 147
     684:	90 e0       	ldi	r25, 0x00	; 0
     686:	90 93 a6 00 	sts	0x00A6, r25
     68a:	80 93 a5 00 	sts	0x00A5, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     68e:	8c e9       	ldi	r24, 0x9C	; 156
     690:	90 e0       	ldi	r25, 0x00	; 0
     692:	90 93 a8 00 	sts	0x00A8, r25
     696:	80 93 a7 00 	sts	0x00A7, r24
}
     69a:	0f 90       	pop	r0
     69c:	cf 91       	pop	r28
     69e:	df 91       	pop	r29
     6a0:	08 95       	ret

000006a2 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     6a2:	df 93       	push	r29
     6a4:	cf 93       	push	r28
     6a6:	00 d0       	rcall	.+0      	; 0x6a8 <xCoRoutineRemoveFromEventList+0x6>
     6a8:	00 d0       	rcall	.+0      	; 0x6aa <xCoRoutineRemoveFromEventList+0x8>
     6aa:	0f 92       	push	r0
     6ac:	cd b7       	in	r28, 0x3d	; 61
     6ae:	de b7       	in	r29, 0x3e	; 62
     6b0:	9d 83       	std	Y+5, r25	; 0x05
     6b2:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     6b4:	ec 81       	ldd	r30, Y+4	; 0x04
     6b6:	fd 81       	ldd	r31, Y+5	; 0x05
     6b8:	05 80       	ldd	r0, Z+5	; 0x05
     6ba:	f6 81       	ldd	r31, Z+6	; 0x06
     6bc:	e0 2d       	mov	r30, r0
     6be:	86 81       	ldd	r24, Z+6	; 0x06
     6c0:	97 81       	ldd	r25, Z+7	; 0x07
     6c2:	9b 83       	std	Y+3, r25	; 0x03
     6c4:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     6c6:	8a 81       	ldd	r24, Y+2	; 0x02
     6c8:	9b 81       	ldd	r25, Y+3	; 0x03
     6ca:	0c 96       	adiw	r24, 0x0c	; 12
     6cc:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     6d0:	8a 81       	ldd	r24, Y+2	; 0x02
     6d2:	9b 81       	ldd	r25, Y+3	; 0x03
     6d4:	9c 01       	movw	r18, r24
     6d6:	24 5f       	subi	r18, 0xF4	; 244
     6d8:	3f 4f       	sbci	r19, 0xFF	; 255
     6da:	89 ea       	ldi	r24, 0xA9	; 169
     6dc:	90 e0       	ldi	r25, 0x00	; 0
     6de:	b9 01       	movw	r22, r18
     6e0:	0e 94 2f 04 	call	0x85e	; 0x85e <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     6e4:	ea 81       	ldd	r30, Y+2	; 0x02
     6e6:	fb 81       	ldd	r31, Y+3	; 0x03
     6e8:	96 89       	ldd	r25, Z+22	; 0x16
     6ea:	e0 91 78 00 	lds	r30, 0x0078
     6ee:	f0 91 79 00 	lds	r31, 0x0079
     6f2:	86 89       	ldd	r24, Z+22	; 0x16
     6f4:	98 17       	cp	r25, r24
     6f6:	18 f0       	brcs	.+6      	; 0x6fe <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
     6f8:	81 e0       	ldi	r24, 0x01	; 1
     6fa:	89 83       	std	Y+1, r24	; 0x01
     6fc:	01 c0       	rjmp	.+2      	; 0x700 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
     6fe:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
     700:	89 81       	ldd	r24, Y+1	; 0x01
}
     702:	0f 90       	pop	r0
     704:	0f 90       	pop	r0
     706:	0f 90       	pop	r0
     708:	0f 90       	pop	r0
     70a:	0f 90       	pop	r0
     70c:	cf 91       	pop	r28
     70e:	df 91       	pop	r29
     710:	08 95       	ret

00000712 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     712:	df 93       	push	r29
     714:	cf 93       	push	r28
     716:	00 d0       	rcall	.+0      	; 0x718 <pvPortMalloc+0x6>
     718:	00 d0       	rcall	.+0      	; 0x71a <pvPortMalloc+0x8>
     71a:	cd b7       	in	r28, 0x3d	; 61
     71c:	de b7       	in	r29, 0x3e	; 62
     71e:	9c 83       	std	Y+4, r25	; 0x04
     720:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
     722:	1a 82       	std	Y+2, r1	; 0x02
     724:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     726:	0e 94 e6 0e 	call	0x1dcc	; 0x1dcc <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     72a:	80 91 b2 00 	lds	r24, 0x00B2
     72e:	90 91 b3 00 	lds	r25, 0x00B3
     732:	2b 81       	ldd	r18, Y+3	; 0x03
     734:	3c 81       	ldd	r19, Y+4	; 0x04
     736:	82 0f       	add	r24, r18
     738:	93 1f       	adc	r25, r19
     73a:	22 e0       	ldi	r18, 0x02	; 2
     73c:	88 35       	cpi	r24, 0x58	; 88
     73e:	92 07       	cpc	r25, r18
     740:	18 f5       	brcc	.+70     	; 0x788 <pvPortMalloc+0x76>
     742:	20 91 b2 00 	lds	r18, 0x00B2
     746:	30 91 b3 00 	lds	r19, 0x00B3
     74a:	8b 81       	ldd	r24, Y+3	; 0x03
     74c:	9c 81       	ldd	r25, Y+4	; 0x04
     74e:	28 0f       	add	r18, r24
     750:	39 1f       	adc	r19, r25
     752:	80 91 b2 00 	lds	r24, 0x00B2
     756:	90 91 b3 00 	lds	r25, 0x00B3
     75a:	82 17       	cp	r24, r18
     75c:	93 07       	cpc	r25, r19
     75e:	a0 f4       	brcc	.+40     	; 0x788 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     760:	80 91 b2 00 	lds	r24, 0x00B2
     764:	90 91 b3 00 	lds	r25, 0x00B3
     768:	8c 54       	subi	r24, 0x4C	; 76
     76a:	9f 4f       	sbci	r25, 0xFF	; 255
     76c:	9a 83       	std	Y+2, r25	; 0x02
     76e:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
     770:	20 91 b2 00 	lds	r18, 0x00B2
     774:	30 91 b3 00 	lds	r19, 0x00B3
     778:	8b 81       	ldd	r24, Y+3	; 0x03
     77a:	9c 81       	ldd	r25, Y+4	; 0x04
     77c:	82 0f       	add	r24, r18
     77e:	93 1f       	adc	r25, r19
     780:	90 93 b3 00 	sts	0x00B3, r25
     784:	80 93 b2 00 	sts	0x00B2, r24
		}	
	}
	xTaskResumeAll();
     788:	0e 94 f2 0e 	call	0x1de4	; 0x1de4 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
     78c:	89 81       	ldd	r24, Y+1	; 0x01
     78e:	9a 81       	ldd	r25, Y+2	; 0x02
}
     790:	0f 90       	pop	r0
     792:	0f 90       	pop	r0
     794:	0f 90       	pop	r0
     796:	0f 90       	pop	r0
     798:	cf 91       	pop	r28
     79a:	df 91       	pop	r29
     79c:	08 95       	ret

0000079e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     79e:	df 93       	push	r29
     7a0:	cf 93       	push	r28
     7a2:	00 d0       	rcall	.+0      	; 0x7a4 <vPortFree+0x6>
     7a4:	cd b7       	in	r28, 0x3d	; 61
     7a6:	de b7       	in	r29, 0x3e	; 62
     7a8:	9a 83       	std	Y+2, r25	; 0x02
     7aa:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     7ac:	0f 90       	pop	r0
     7ae:	0f 90       	pop	r0
     7b0:	cf 91       	pop	r28
     7b2:	df 91       	pop	r29
     7b4:	08 95       	ret

000007b6 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     7b6:	df 93       	push	r29
     7b8:	cf 93       	push	r28
     7ba:	cd b7       	in	r28, 0x3d	; 61
     7bc:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     7be:	10 92 b3 00 	sts	0x00B3, r1
     7c2:	10 92 b2 00 	sts	0x00B2, r1
}
     7c6:	cf 91       	pop	r28
     7c8:	df 91       	pop	r29
     7ca:	08 95       	ret

000007cc <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     7cc:	df 93       	push	r29
     7ce:	cf 93       	push	r28
     7d0:	cd b7       	in	r28, 0x3d	; 61
     7d2:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     7d4:	20 91 b2 00 	lds	r18, 0x00B2
     7d8:	30 91 b3 00 	lds	r19, 0x00B3
     7dc:	88 e5       	ldi	r24, 0x58	; 88
     7de:	92 e0       	ldi	r25, 0x02	; 2
     7e0:	82 1b       	sub	r24, r18
     7e2:	93 0b       	sbc	r25, r19
}
     7e4:	cf 91       	pop	r28
     7e6:	df 91       	pop	r29
     7e8:	08 95       	ret

000007ea <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     7ea:	df 93       	push	r29
     7ec:	cf 93       	push	r28
     7ee:	00 d0       	rcall	.+0      	; 0x7f0 <vListInitialise+0x6>
     7f0:	cd b7       	in	r28, 0x3d	; 61
     7f2:	de b7       	in	r29, 0x3e	; 62
     7f4:	9a 83       	std	Y+2, r25	; 0x02
     7f6:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     7f8:	89 81       	ldd	r24, Y+1	; 0x01
     7fa:	9a 81       	ldd	r25, Y+2	; 0x02
     7fc:	03 96       	adiw	r24, 0x03	; 3
     7fe:	e9 81       	ldd	r30, Y+1	; 0x01
     800:	fa 81       	ldd	r31, Y+2	; 0x02
     802:	92 83       	std	Z+2, r25	; 0x02
     804:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     806:	e9 81       	ldd	r30, Y+1	; 0x01
     808:	fa 81       	ldd	r31, Y+2	; 0x02
     80a:	8f ef       	ldi	r24, 0xFF	; 255
     80c:	9f ef       	ldi	r25, 0xFF	; 255
     80e:	94 83       	std	Z+4, r25	; 0x04
     810:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     812:	89 81       	ldd	r24, Y+1	; 0x01
     814:	9a 81       	ldd	r25, Y+2	; 0x02
     816:	03 96       	adiw	r24, 0x03	; 3
     818:	e9 81       	ldd	r30, Y+1	; 0x01
     81a:	fa 81       	ldd	r31, Y+2	; 0x02
     81c:	96 83       	std	Z+6, r25	; 0x06
     81e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     820:	89 81       	ldd	r24, Y+1	; 0x01
     822:	9a 81       	ldd	r25, Y+2	; 0x02
     824:	03 96       	adiw	r24, 0x03	; 3
     826:	e9 81       	ldd	r30, Y+1	; 0x01
     828:	fa 81       	ldd	r31, Y+2	; 0x02
     82a:	90 87       	std	Z+8, r25	; 0x08
     82c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     82e:	e9 81       	ldd	r30, Y+1	; 0x01
     830:	fa 81       	ldd	r31, Y+2	; 0x02
     832:	10 82       	st	Z, r1
}
     834:	0f 90       	pop	r0
     836:	0f 90       	pop	r0
     838:	cf 91       	pop	r28
     83a:	df 91       	pop	r29
     83c:	08 95       	ret

0000083e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
     83e:	df 93       	push	r29
     840:	cf 93       	push	r28
     842:	00 d0       	rcall	.+0      	; 0x844 <vListInitialiseItem+0x6>
     844:	cd b7       	in	r28, 0x3d	; 61
     846:	de b7       	in	r29, 0x3e	; 62
     848:	9a 83       	std	Y+2, r25	; 0x02
     84a:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     84c:	e9 81       	ldd	r30, Y+1	; 0x01
     84e:	fa 81       	ldd	r31, Y+2	; 0x02
     850:	11 86       	std	Z+9, r1	; 0x09
     852:	10 86       	std	Z+8, r1	; 0x08
}
     854:	0f 90       	pop	r0
     856:	0f 90       	pop	r0
     858:	cf 91       	pop	r28
     85a:	df 91       	pop	r29
     85c:	08 95       	ret

0000085e <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     85e:	df 93       	push	r29
     860:	cf 93       	push	r28
     862:	00 d0       	rcall	.+0      	; 0x864 <__stack+0x5>
     864:	00 d0       	rcall	.+0      	; 0x866 <__stack+0x7>
     866:	00 d0       	rcall	.+0      	; 0x868 <__stack+0x9>
     868:	cd b7       	in	r28, 0x3d	; 61
     86a:	de b7       	in	r29, 0x3e	; 62
     86c:	9c 83       	std	Y+4, r25	; 0x04
     86e:	8b 83       	std	Y+3, r24	; 0x03
     870:	7e 83       	std	Y+6, r23	; 0x06
     872:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     874:	eb 81       	ldd	r30, Y+3	; 0x03
     876:	fc 81       	ldd	r31, Y+4	; 0x04
     878:	81 81       	ldd	r24, Z+1	; 0x01
     87a:	92 81       	ldd	r25, Z+2	; 0x02
     87c:	9a 83       	std	Y+2, r25	; 0x02
     87e:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
     880:	e9 81       	ldd	r30, Y+1	; 0x01
     882:	fa 81       	ldd	r31, Y+2	; 0x02
     884:	82 81       	ldd	r24, Z+2	; 0x02
     886:	93 81       	ldd	r25, Z+3	; 0x03
     888:	ed 81       	ldd	r30, Y+5	; 0x05
     88a:	fe 81       	ldd	r31, Y+6	; 0x06
     88c:	93 83       	std	Z+3, r25	; 0x03
     88e:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     890:	eb 81       	ldd	r30, Y+3	; 0x03
     892:	fc 81       	ldd	r31, Y+4	; 0x04
     894:	81 81       	ldd	r24, Z+1	; 0x01
     896:	92 81       	ldd	r25, Z+2	; 0x02
     898:	ed 81       	ldd	r30, Y+5	; 0x05
     89a:	fe 81       	ldd	r31, Y+6	; 0x06
     89c:	95 83       	std	Z+5, r25	; 0x05
     89e:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     8a0:	e9 81       	ldd	r30, Y+1	; 0x01
     8a2:	fa 81       	ldd	r31, Y+2	; 0x02
     8a4:	02 80       	ldd	r0, Z+2	; 0x02
     8a6:	f3 81       	ldd	r31, Z+3	; 0x03
     8a8:	e0 2d       	mov	r30, r0
     8aa:	8d 81       	ldd	r24, Y+5	; 0x05
     8ac:	9e 81       	ldd	r25, Y+6	; 0x06
     8ae:	95 83       	std	Z+5, r25	; 0x05
     8b0:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     8b2:	8d 81       	ldd	r24, Y+5	; 0x05
     8b4:	9e 81       	ldd	r25, Y+6	; 0x06
     8b6:	e9 81       	ldd	r30, Y+1	; 0x01
     8b8:	fa 81       	ldd	r31, Y+2	; 0x02
     8ba:	93 83       	std	Z+3, r25	; 0x03
     8bc:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     8be:	8d 81       	ldd	r24, Y+5	; 0x05
     8c0:	9e 81       	ldd	r25, Y+6	; 0x06
     8c2:	eb 81       	ldd	r30, Y+3	; 0x03
     8c4:	fc 81       	ldd	r31, Y+4	; 0x04
     8c6:	92 83       	std	Z+2, r25	; 0x02
     8c8:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     8ca:	ed 81       	ldd	r30, Y+5	; 0x05
     8cc:	fe 81       	ldd	r31, Y+6	; 0x06
     8ce:	8b 81       	ldd	r24, Y+3	; 0x03
     8d0:	9c 81       	ldd	r25, Y+4	; 0x04
     8d2:	91 87       	std	Z+9, r25	; 0x09
     8d4:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     8d6:	eb 81       	ldd	r30, Y+3	; 0x03
     8d8:	fc 81       	ldd	r31, Y+4	; 0x04
     8da:	80 81       	ld	r24, Z
     8dc:	8f 5f       	subi	r24, 0xFF	; 255
     8de:	eb 81       	ldd	r30, Y+3	; 0x03
     8e0:	fc 81       	ldd	r31, Y+4	; 0x04
     8e2:	80 83       	st	Z, r24
}
     8e4:	26 96       	adiw	r28, 0x06	; 6
     8e6:	0f b6       	in	r0, 0x3f	; 63
     8e8:	f8 94       	cli
     8ea:	de bf       	out	0x3e, r29	; 62
     8ec:	0f be       	out	0x3f, r0	; 63
     8ee:	cd bf       	out	0x3d, r28	; 61
     8f0:	cf 91       	pop	r28
     8f2:	df 91       	pop	r29
     8f4:	08 95       	ret

000008f6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     8f6:	df 93       	push	r29
     8f8:	cf 93       	push	r28
     8fa:	cd b7       	in	r28, 0x3d	; 61
     8fc:	de b7       	in	r29, 0x3e	; 62
     8fe:	28 97       	sbiw	r28, 0x08	; 8
     900:	0f b6       	in	r0, 0x3f	; 63
     902:	f8 94       	cli
     904:	de bf       	out	0x3e, r29	; 62
     906:	0f be       	out	0x3f, r0	; 63
     908:	cd bf       	out	0x3d, r28	; 61
     90a:	9e 83       	std	Y+6, r25	; 0x06
     90c:	8d 83       	std	Y+5, r24	; 0x05
     90e:	78 87       	std	Y+8, r23	; 0x08
     910:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     912:	ef 81       	ldd	r30, Y+7	; 0x07
     914:	f8 85       	ldd	r31, Y+8	; 0x08
     916:	80 81       	ld	r24, Z
     918:	91 81       	ldd	r25, Z+1	; 0x01
     91a:	9a 83       	std	Y+2, r25	; 0x02
     91c:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     91e:	89 81       	ldd	r24, Y+1	; 0x01
     920:	9a 81       	ldd	r25, Y+2	; 0x02
     922:	2f ef       	ldi	r18, 0xFF	; 255
     924:	8f 3f       	cpi	r24, 0xFF	; 255
     926:	92 07       	cpc	r25, r18
     928:	39 f4       	brne	.+14     	; 0x938 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     92a:	ed 81       	ldd	r30, Y+5	; 0x05
     92c:	fe 81       	ldd	r31, Y+6	; 0x06
     92e:	87 81       	ldd	r24, Z+7	; 0x07
     930:	90 85       	ldd	r25, Z+8	; 0x08
     932:	9c 83       	std	Y+4, r25	; 0x04
     934:	8b 83       	std	Y+3, r24	; 0x03
     936:	18 c0       	rjmp	.+48     	; 0x968 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     938:	8d 81       	ldd	r24, Y+5	; 0x05
     93a:	9e 81       	ldd	r25, Y+6	; 0x06
     93c:	03 96       	adiw	r24, 0x03	; 3
     93e:	9c 83       	std	Y+4, r25	; 0x04
     940:	8b 83       	std	Y+3, r24	; 0x03
     942:	06 c0       	rjmp	.+12     	; 0x950 <vListInsert+0x5a>
     944:	eb 81       	ldd	r30, Y+3	; 0x03
     946:	fc 81       	ldd	r31, Y+4	; 0x04
     948:	82 81       	ldd	r24, Z+2	; 0x02
     94a:	93 81       	ldd	r25, Z+3	; 0x03
     94c:	9c 83       	std	Y+4, r25	; 0x04
     94e:	8b 83       	std	Y+3, r24	; 0x03
     950:	eb 81       	ldd	r30, Y+3	; 0x03
     952:	fc 81       	ldd	r31, Y+4	; 0x04
     954:	02 80       	ldd	r0, Z+2	; 0x02
     956:	f3 81       	ldd	r31, Z+3	; 0x03
     958:	e0 2d       	mov	r30, r0
     95a:	20 81       	ld	r18, Z
     95c:	31 81       	ldd	r19, Z+1	; 0x01
     95e:	89 81       	ldd	r24, Y+1	; 0x01
     960:	9a 81       	ldd	r25, Y+2	; 0x02
     962:	82 17       	cp	r24, r18
     964:	93 07       	cpc	r25, r19
     966:	70 f7       	brcc	.-36     	; 0x944 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     968:	eb 81       	ldd	r30, Y+3	; 0x03
     96a:	fc 81       	ldd	r31, Y+4	; 0x04
     96c:	82 81       	ldd	r24, Z+2	; 0x02
     96e:	93 81       	ldd	r25, Z+3	; 0x03
     970:	ef 81       	ldd	r30, Y+7	; 0x07
     972:	f8 85       	ldd	r31, Y+8	; 0x08
     974:	93 83       	std	Z+3, r25	; 0x03
     976:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     978:	ef 81       	ldd	r30, Y+7	; 0x07
     97a:	f8 85       	ldd	r31, Y+8	; 0x08
     97c:	02 80       	ldd	r0, Z+2	; 0x02
     97e:	f3 81       	ldd	r31, Z+3	; 0x03
     980:	e0 2d       	mov	r30, r0
     982:	8f 81       	ldd	r24, Y+7	; 0x07
     984:	98 85       	ldd	r25, Y+8	; 0x08
     986:	95 83       	std	Z+5, r25	; 0x05
     988:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     98a:	ef 81       	ldd	r30, Y+7	; 0x07
     98c:	f8 85       	ldd	r31, Y+8	; 0x08
     98e:	8b 81       	ldd	r24, Y+3	; 0x03
     990:	9c 81       	ldd	r25, Y+4	; 0x04
     992:	95 83       	std	Z+5, r25	; 0x05
     994:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     996:	8f 81       	ldd	r24, Y+7	; 0x07
     998:	98 85       	ldd	r25, Y+8	; 0x08
     99a:	eb 81       	ldd	r30, Y+3	; 0x03
     99c:	fc 81       	ldd	r31, Y+4	; 0x04
     99e:	93 83       	std	Z+3, r25	; 0x03
     9a0:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     9a2:	ef 81       	ldd	r30, Y+7	; 0x07
     9a4:	f8 85       	ldd	r31, Y+8	; 0x08
     9a6:	8d 81       	ldd	r24, Y+5	; 0x05
     9a8:	9e 81       	ldd	r25, Y+6	; 0x06
     9aa:	91 87       	std	Z+9, r25	; 0x09
     9ac:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     9ae:	ed 81       	ldd	r30, Y+5	; 0x05
     9b0:	fe 81       	ldd	r31, Y+6	; 0x06
     9b2:	80 81       	ld	r24, Z
     9b4:	8f 5f       	subi	r24, 0xFF	; 255
     9b6:	ed 81       	ldd	r30, Y+5	; 0x05
     9b8:	fe 81       	ldd	r31, Y+6	; 0x06
     9ba:	80 83       	st	Z, r24
}
     9bc:	28 96       	adiw	r28, 0x08	; 8
     9be:	0f b6       	in	r0, 0x3f	; 63
     9c0:	f8 94       	cli
     9c2:	de bf       	out	0x3e, r29	; 62
     9c4:	0f be       	out	0x3f, r0	; 63
     9c6:	cd bf       	out	0x3d, r28	; 61
     9c8:	cf 91       	pop	r28
     9ca:	df 91       	pop	r29
     9cc:	08 95       	ret

000009ce <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     9ce:	df 93       	push	r29
     9d0:	cf 93       	push	r28
     9d2:	00 d0       	rcall	.+0      	; 0x9d4 <vListRemove+0x6>
     9d4:	00 d0       	rcall	.+0      	; 0x9d6 <vListRemove+0x8>
     9d6:	cd b7       	in	r28, 0x3d	; 61
     9d8:	de b7       	in	r29, 0x3e	; 62
     9da:	9c 83       	std	Y+4, r25	; 0x04
     9dc:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     9de:	eb 81       	ldd	r30, Y+3	; 0x03
     9e0:	fc 81       	ldd	r31, Y+4	; 0x04
     9e2:	a2 81       	ldd	r26, Z+2	; 0x02
     9e4:	b3 81       	ldd	r27, Z+3	; 0x03
     9e6:	eb 81       	ldd	r30, Y+3	; 0x03
     9e8:	fc 81       	ldd	r31, Y+4	; 0x04
     9ea:	84 81       	ldd	r24, Z+4	; 0x04
     9ec:	95 81       	ldd	r25, Z+5	; 0x05
     9ee:	15 96       	adiw	r26, 0x05	; 5
     9f0:	9c 93       	st	X, r25
     9f2:	8e 93       	st	-X, r24
     9f4:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     9f6:	eb 81       	ldd	r30, Y+3	; 0x03
     9f8:	fc 81       	ldd	r31, Y+4	; 0x04
     9fa:	a4 81       	ldd	r26, Z+4	; 0x04
     9fc:	b5 81       	ldd	r27, Z+5	; 0x05
     9fe:	eb 81       	ldd	r30, Y+3	; 0x03
     a00:	fc 81       	ldd	r31, Y+4	; 0x04
     a02:	82 81       	ldd	r24, Z+2	; 0x02
     a04:	93 81       	ldd	r25, Z+3	; 0x03
     a06:	13 96       	adiw	r26, 0x03	; 3
     a08:	9c 93       	st	X, r25
     a0a:	8e 93       	st	-X, r24
     a0c:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     a0e:	eb 81       	ldd	r30, Y+3	; 0x03
     a10:	fc 81       	ldd	r31, Y+4	; 0x04
     a12:	80 85       	ldd	r24, Z+8	; 0x08
     a14:	91 85       	ldd	r25, Z+9	; 0x09
     a16:	9a 83       	std	Y+2, r25	; 0x02
     a18:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     a1a:	e9 81       	ldd	r30, Y+1	; 0x01
     a1c:	fa 81       	ldd	r31, Y+2	; 0x02
     a1e:	21 81       	ldd	r18, Z+1	; 0x01
     a20:	32 81       	ldd	r19, Z+2	; 0x02
     a22:	8b 81       	ldd	r24, Y+3	; 0x03
     a24:	9c 81       	ldd	r25, Y+4	; 0x04
     a26:	28 17       	cp	r18, r24
     a28:	39 07       	cpc	r19, r25
     a2a:	41 f4       	brne	.+16     	; 0xa3c <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     a2c:	eb 81       	ldd	r30, Y+3	; 0x03
     a2e:	fc 81       	ldd	r31, Y+4	; 0x04
     a30:	84 81       	ldd	r24, Z+4	; 0x04
     a32:	95 81       	ldd	r25, Z+5	; 0x05
     a34:	e9 81       	ldd	r30, Y+1	; 0x01
     a36:	fa 81       	ldd	r31, Y+2	; 0x02
     a38:	92 83       	std	Z+2, r25	; 0x02
     a3a:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
     a3c:	eb 81       	ldd	r30, Y+3	; 0x03
     a3e:	fc 81       	ldd	r31, Y+4	; 0x04
     a40:	11 86       	std	Z+9, r1	; 0x09
     a42:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     a44:	e9 81       	ldd	r30, Y+1	; 0x01
     a46:	fa 81       	ldd	r31, Y+2	; 0x02
     a48:	80 81       	ld	r24, Z
     a4a:	81 50       	subi	r24, 0x01	; 1
     a4c:	e9 81       	ldd	r30, Y+1	; 0x01
     a4e:	fa 81       	ldd	r31, Y+2	; 0x02
     a50:	80 83       	st	Z, r24
}
     a52:	0f 90       	pop	r0
     a54:	0f 90       	pop	r0
     a56:	0f 90       	pop	r0
     a58:	0f 90       	pop	r0
     a5a:	cf 91       	pop	r28
     a5c:	df 91       	pop	r29
     a5e:	08 95       	ret

00000a60 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
     a60:	df 93       	push	r29
     a62:	cf 93       	push	r28
     a64:	cd b7       	in	r28, 0x3d	; 61
     a66:	de b7       	in	r29, 0x3e	; 62
     a68:	28 97       	sbiw	r28, 0x08	; 8
     a6a:	0f b6       	in	r0, 0x3f	; 63
     a6c:	f8 94       	cli
     a6e:	de bf       	out	0x3e, r29	; 62
     a70:	0f be       	out	0x3f, r0	; 63
     a72:	cd bf       	out	0x3d, r28	; 61
     a74:	9c 83       	std	Y+4, r25	; 0x04
     a76:	8b 83       	std	Y+3, r24	; 0x03
     a78:	7e 83       	std	Y+6, r23	; 0x06
     a7a:	6d 83       	std	Y+5, r22	; 0x05
     a7c:	58 87       	std	Y+8, r21	; 0x08
     a7e:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     a80:	eb 81       	ldd	r30, Y+3	; 0x03
     a82:	fc 81       	ldd	r31, Y+4	; 0x04
     a84:	81 e1       	ldi	r24, 0x11	; 17
     a86:	80 83       	st	Z, r24
	pxTopOfStack--;
     a88:	8b 81       	ldd	r24, Y+3	; 0x03
     a8a:	9c 81       	ldd	r25, Y+4	; 0x04
     a8c:	01 97       	sbiw	r24, 0x01	; 1
     a8e:	9c 83       	std	Y+4, r25	; 0x04
     a90:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     a92:	eb 81       	ldd	r30, Y+3	; 0x03
     a94:	fc 81       	ldd	r31, Y+4	; 0x04
     a96:	82 e2       	ldi	r24, 0x22	; 34
     a98:	80 83       	st	Z, r24
	pxTopOfStack--;
     a9a:	8b 81       	ldd	r24, Y+3	; 0x03
     a9c:	9c 81       	ldd	r25, Y+4	; 0x04
     a9e:	01 97       	sbiw	r24, 0x01	; 1
     aa0:	9c 83       	std	Y+4, r25	; 0x04
     aa2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     aa4:	eb 81       	ldd	r30, Y+3	; 0x03
     aa6:	fc 81       	ldd	r31, Y+4	; 0x04
     aa8:	83 e3       	ldi	r24, 0x33	; 51
     aaa:	80 83       	st	Z, r24
	pxTopOfStack--;
     aac:	8b 81       	ldd	r24, Y+3	; 0x03
     aae:	9c 81       	ldd	r25, Y+4	; 0x04
     ab0:	01 97       	sbiw	r24, 0x01	; 1
     ab2:	9c 83       	std	Y+4, r25	; 0x04
     ab4:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
     ab6:	8d 81       	ldd	r24, Y+5	; 0x05
     ab8:	9e 81       	ldd	r25, Y+6	; 0x06
     aba:	9a 83       	std	Y+2, r25	; 0x02
     abc:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     abe:	89 81       	ldd	r24, Y+1	; 0x01
     ac0:	eb 81       	ldd	r30, Y+3	; 0x03
     ac2:	fc 81       	ldd	r31, Y+4	; 0x04
     ac4:	80 83       	st	Z, r24
	pxTopOfStack--;
     ac6:	8b 81       	ldd	r24, Y+3	; 0x03
     ac8:	9c 81       	ldd	r25, Y+4	; 0x04
     aca:	01 97       	sbiw	r24, 0x01	; 1
     acc:	9c 83       	std	Y+4, r25	; 0x04
     ace:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     ad0:	89 81       	ldd	r24, Y+1	; 0x01
     ad2:	9a 81       	ldd	r25, Y+2	; 0x02
     ad4:	89 2f       	mov	r24, r25
     ad6:	99 27       	eor	r25, r25
     ad8:	9a 83       	std	Y+2, r25	; 0x02
     ada:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     adc:	89 81       	ldd	r24, Y+1	; 0x01
     ade:	eb 81       	ldd	r30, Y+3	; 0x03
     ae0:	fc 81       	ldd	r31, Y+4	; 0x04
     ae2:	80 83       	st	Z, r24
	pxTopOfStack--;
     ae4:	8b 81       	ldd	r24, Y+3	; 0x03
     ae6:	9c 81       	ldd	r25, Y+4	; 0x04
     ae8:	01 97       	sbiw	r24, 0x01	; 1
     aea:	9c 83       	std	Y+4, r25	; 0x04
     aec:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     aee:	eb 81       	ldd	r30, Y+3	; 0x03
     af0:	fc 81       	ldd	r31, Y+4	; 0x04
     af2:	10 82       	st	Z, r1
	pxTopOfStack--;
     af4:	8b 81       	ldd	r24, Y+3	; 0x03
     af6:	9c 81       	ldd	r25, Y+4	; 0x04
     af8:	01 97       	sbiw	r24, 0x01	; 1
     afa:	9c 83       	std	Y+4, r25	; 0x04
     afc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     afe:	eb 81       	ldd	r30, Y+3	; 0x03
     b00:	fc 81       	ldd	r31, Y+4	; 0x04
     b02:	80 e8       	ldi	r24, 0x80	; 128
     b04:	80 83       	st	Z, r24
	pxTopOfStack--;
     b06:	8b 81       	ldd	r24, Y+3	; 0x03
     b08:	9c 81       	ldd	r25, Y+4	; 0x04
     b0a:	01 97       	sbiw	r24, 0x01	; 1
     b0c:	9c 83       	std	Y+4, r25	; 0x04
     b0e:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     b10:	eb 81       	ldd	r30, Y+3	; 0x03
     b12:	fc 81       	ldd	r31, Y+4	; 0x04
     b14:	10 82       	st	Z, r1
	pxTopOfStack--;
     b16:	8b 81       	ldd	r24, Y+3	; 0x03
     b18:	9c 81       	ldd	r25, Y+4	; 0x04
     b1a:	01 97       	sbiw	r24, 0x01	; 1
     b1c:	9c 83       	std	Y+4, r25	; 0x04
     b1e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     b20:	eb 81       	ldd	r30, Y+3	; 0x03
     b22:	fc 81       	ldd	r31, Y+4	; 0x04
     b24:	82 e0       	ldi	r24, 0x02	; 2
     b26:	80 83       	st	Z, r24
	pxTopOfStack--;
     b28:	8b 81       	ldd	r24, Y+3	; 0x03
     b2a:	9c 81       	ldd	r25, Y+4	; 0x04
     b2c:	01 97       	sbiw	r24, 0x01	; 1
     b2e:	9c 83       	std	Y+4, r25	; 0x04
     b30:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     b32:	eb 81       	ldd	r30, Y+3	; 0x03
     b34:	fc 81       	ldd	r31, Y+4	; 0x04
     b36:	83 e0       	ldi	r24, 0x03	; 3
     b38:	80 83       	st	Z, r24
	pxTopOfStack--;
     b3a:	8b 81       	ldd	r24, Y+3	; 0x03
     b3c:	9c 81       	ldd	r25, Y+4	; 0x04
     b3e:	01 97       	sbiw	r24, 0x01	; 1
     b40:	9c 83       	std	Y+4, r25	; 0x04
     b42:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     b44:	eb 81       	ldd	r30, Y+3	; 0x03
     b46:	fc 81       	ldd	r31, Y+4	; 0x04
     b48:	84 e0       	ldi	r24, 0x04	; 4
     b4a:	80 83       	st	Z, r24
	pxTopOfStack--;
     b4c:	8b 81       	ldd	r24, Y+3	; 0x03
     b4e:	9c 81       	ldd	r25, Y+4	; 0x04
     b50:	01 97       	sbiw	r24, 0x01	; 1
     b52:	9c 83       	std	Y+4, r25	; 0x04
     b54:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     b56:	eb 81       	ldd	r30, Y+3	; 0x03
     b58:	fc 81       	ldd	r31, Y+4	; 0x04
     b5a:	85 e0       	ldi	r24, 0x05	; 5
     b5c:	80 83       	st	Z, r24
	pxTopOfStack--;
     b5e:	8b 81       	ldd	r24, Y+3	; 0x03
     b60:	9c 81       	ldd	r25, Y+4	; 0x04
     b62:	01 97       	sbiw	r24, 0x01	; 1
     b64:	9c 83       	std	Y+4, r25	; 0x04
     b66:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     b68:	eb 81       	ldd	r30, Y+3	; 0x03
     b6a:	fc 81       	ldd	r31, Y+4	; 0x04
     b6c:	86 e0       	ldi	r24, 0x06	; 6
     b6e:	80 83       	st	Z, r24
	pxTopOfStack--;
     b70:	8b 81       	ldd	r24, Y+3	; 0x03
     b72:	9c 81       	ldd	r25, Y+4	; 0x04
     b74:	01 97       	sbiw	r24, 0x01	; 1
     b76:	9c 83       	std	Y+4, r25	; 0x04
     b78:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     b7a:	eb 81       	ldd	r30, Y+3	; 0x03
     b7c:	fc 81       	ldd	r31, Y+4	; 0x04
     b7e:	87 e0       	ldi	r24, 0x07	; 7
     b80:	80 83       	st	Z, r24
	pxTopOfStack--;
     b82:	8b 81       	ldd	r24, Y+3	; 0x03
     b84:	9c 81       	ldd	r25, Y+4	; 0x04
     b86:	01 97       	sbiw	r24, 0x01	; 1
     b88:	9c 83       	std	Y+4, r25	; 0x04
     b8a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     b8c:	eb 81       	ldd	r30, Y+3	; 0x03
     b8e:	fc 81       	ldd	r31, Y+4	; 0x04
     b90:	88 e0       	ldi	r24, 0x08	; 8
     b92:	80 83       	st	Z, r24
	pxTopOfStack--;
     b94:	8b 81       	ldd	r24, Y+3	; 0x03
     b96:	9c 81       	ldd	r25, Y+4	; 0x04
     b98:	01 97       	sbiw	r24, 0x01	; 1
     b9a:	9c 83       	std	Y+4, r25	; 0x04
     b9c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     b9e:	eb 81       	ldd	r30, Y+3	; 0x03
     ba0:	fc 81       	ldd	r31, Y+4	; 0x04
     ba2:	89 e0       	ldi	r24, 0x09	; 9
     ba4:	80 83       	st	Z, r24
	pxTopOfStack--;
     ba6:	8b 81       	ldd	r24, Y+3	; 0x03
     ba8:	9c 81       	ldd	r25, Y+4	; 0x04
     baa:	01 97       	sbiw	r24, 0x01	; 1
     bac:	9c 83       	std	Y+4, r25	; 0x04
     bae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     bb0:	eb 81       	ldd	r30, Y+3	; 0x03
     bb2:	fc 81       	ldd	r31, Y+4	; 0x04
     bb4:	80 e1       	ldi	r24, 0x10	; 16
     bb6:	80 83       	st	Z, r24
	pxTopOfStack--;
     bb8:	8b 81       	ldd	r24, Y+3	; 0x03
     bba:	9c 81       	ldd	r25, Y+4	; 0x04
     bbc:	01 97       	sbiw	r24, 0x01	; 1
     bbe:	9c 83       	std	Y+4, r25	; 0x04
     bc0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     bc2:	eb 81       	ldd	r30, Y+3	; 0x03
     bc4:	fc 81       	ldd	r31, Y+4	; 0x04
     bc6:	81 e1       	ldi	r24, 0x11	; 17
     bc8:	80 83       	st	Z, r24
	pxTopOfStack--;
     bca:	8b 81       	ldd	r24, Y+3	; 0x03
     bcc:	9c 81       	ldd	r25, Y+4	; 0x04
     bce:	01 97       	sbiw	r24, 0x01	; 1
     bd0:	9c 83       	std	Y+4, r25	; 0x04
     bd2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     bd4:	eb 81       	ldd	r30, Y+3	; 0x03
     bd6:	fc 81       	ldd	r31, Y+4	; 0x04
     bd8:	82 e1       	ldi	r24, 0x12	; 18
     bda:	80 83       	st	Z, r24
	pxTopOfStack--;
     bdc:	8b 81       	ldd	r24, Y+3	; 0x03
     bde:	9c 81       	ldd	r25, Y+4	; 0x04
     be0:	01 97       	sbiw	r24, 0x01	; 1
     be2:	9c 83       	std	Y+4, r25	; 0x04
     be4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     be6:	eb 81       	ldd	r30, Y+3	; 0x03
     be8:	fc 81       	ldd	r31, Y+4	; 0x04
     bea:	83 e1       	ldi	r24, 0x13	; 19
     bec:	80 83       	st	Z, r24
	pxTopOfStack--;
     bee:	8b 81       	ldd	r24, Y+3	; 0x03
     bf0:	9c 81       	ldd	r25, Y+4	; 0x04
     bf2:	01 97       	sbiw	r24, 0x01	; 1
     bf4:	9c 83       	std	Y+4, r25	; 0x04
     bf6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     bf8:	eb 81       	ldd	r30, Y+3	; 0x03
     bfa:	fc 81       	ldd	r31, Y+4	; 0x04
     bfc:	84 e1       	ldi	r24, 0x14	; 20
     bfe:	80 83       	st	Z, r24
	pxTopOfStack--;
     c00:	8b 81       	ldd	r24, Y+3	; 0x03
     c02:	9c 81       	ldd	r25, Y+4	; 0x04
     c04:	01 97       	sbiw	r24, 0x01	; 1
     c06:	9c 83       	std	Y+4, r25	; 0x04
     c08:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     c0a:	eb 81       	ldd	r30, Y+3	; 0x03
     c0c:	fc 81       	ldd	r31, Y+4	; 0x04
     c0e:	85 e1       	ldi	r24, 0x15	; 21
     c10:	80 83       	st	Z, r24
	pxTopOfStack--;
     c12:	8b 81       	ldd	r24, Y+3	; 0x03
     c14:	9c 81       	ldd	r25, Y+4	; 0x04
     c16:	01 97       	sbiw	r24, 0x01	; 1
     c18:	9c 83       	std	Y+4, r25	; 0x04
     c1a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     c1c:	eb 81       	ldd	r30, Y+3	; 0x03
     c1e:	fc 81       	ldd	r31, Y+4	; 0x04
     c20:	86 e1       	ldi	r24, 0x16	; 22
     c22:	80 83       	st	Z, r24
	pxTopOfStack--;
     c24:	8b 81       	ldd	r24, Y+3	; 0x03
     c26:	9c 81       	ldd	r25, Y+4	; 0x04
     c28:	01 97       	sbiw	r24, 0x01	; 1
     c2a:	9c 83       	std	Y+4, r25	; 0x04
     c2c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     c2e:	eb 81       	ldd	r30, Y+3	; 0x03
     c30:	fc 81       	ldd	r31, Y+4	; 0x04
     c32:	87 e1       	ldi	r24, 0x17	; 23
     c34:	80 83       	st	Z, r24
	pxTopOfStack--;
     c36:	8b 81       	ldd	r24, Y+3	; 0x03
     c38:	9c 81       	ldd	r25, Y+4	; 0x04
     c3a:	01 97       	sbiw	r24, 0x01	; 1
     c3c:	9c 83       	std	Y+4, r25	; 0x04
     c3e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     c40:	eb 81       	ldd	r30, Y+3	; 0x03
     c42:	fc 81       	ldd	r31, Y+4	; 0x04
     c44:	88 e1       	ldi	r24, 0x18	; 24
     c46:	80 83       	st	Z, r24
	pxTopOfStack--;
     c48:	8b 81       	ldd	r24, Y+3	; 0x03
     c4a:	9c 81       	ldd	r25, Y+4	; 0x04
     c4c:	01 97       	sbiw	r24, 0x01	; 1
     c4e:	9c 83       	std	Y+4, r25	; 0x04
     c50:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     c52:	eb 81       	ldd	r30, Y+3	; 0x03
     c54:	fc 81       	ldd	r31, Y+4	; 0x04
     c56:	89 e1       	ldi	r24, 0x19	; 25
     c58:	80 83       	st	Z, r24
	pxTopOfStack--;
     c5a:	8b 81       	ldd	r24, Y+3	; 0x03
     c5c:	9c 81       	ldd	r25, Y+4	; 0x04
     c5e:	01 97       	sbiw	r24, 0x01	; 1
     c60:	9c 83       	std	Y+4, r25	; 0x04
     c62:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     c64:	eb 81       	ldd	r30, Y+3	; 0x03
     c66:	fc 81       	ldd	r31, Y+4	; 0x04
     c68:	80 e2       	ldi	r24, 0x20	; 32
     c6a:	80 83       	st	Z, r24
	pxTopOfStack--;
     c6c:	8b 81       	ldd	r24, Y+3	; 0x03
     c6e:	9c 81       	ldd	r25, Y+4	; 0x04
     c70:	01 97       	sbiw	r24, 0x01	; 1
     c72:	9c 83       	std	Y+4, r25	; 0x04
     c74:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     c76:	eb 81       	ldd	r30, Y+3	; 0x03
     c78:	fc 81       	ldd	r31, Y+4	; 0x04
     c7a:	81 e2       	ldi	r24, 0x21	; 33
     c7c:	80 83       	st	Z, r24
	pxTopOfStack--;
     c7e:	8b 81       	ldd	r24, Y+3	; 0x03
     c80:	9c 81       	ldd	r25, Y+4	; 0x04
     c82:	01 97       	sbiw	r24, 0x01	; 1
     c84:	9c 83       	std	Y+4, r25	; 0x04
     c86:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     c88:	eb 81       	ldd	r30, Y+3	; 0x03
     c8a:	fc 81       	ldd	r31, Y+4	; 0x04
     c8c:	82 e2       	ldi	r24, 0x22	; 34
     c8e:	80 83       	st	Z, r24
	pxTopOfStack--;
     c90:	8b 81       	ldd	r24, Y+3	; 0x03
     c92:	9c 81       	ldd	r25, Y+4	; 0x04
     c94:	01 97       	sbiw	r24, 0x01	; 1
     c96:	9c 83       	std	Y+4, r25	; 0x04
     c98:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     c9a:	eb 81       	ldd	r30, Y+3	; 0x03
     c9c:	fc 81       	ldd	r31, Y+4	; 0x04
     c9e:	83 e2       	ldi	r24, 0x23	; 35
     ca0:	80 83       	st	Z, r24
	pxTopOfStack--;
     ca2:	8b 81       	ldd	r24, Y+3	; 0x03
     ca4:	9c 81       	ldd	r25, Y+4	; 0x04
     ca6:	01 97       	sbiw	r24, 0x01	; 1
     ca8:	9c 83       	std	Y+4, r25	; 0x04
     caa:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
     cac:	8f 81       	ldd	r24, Y+7	; 0x07
     cae:	98 85       	ldd	r25, Y+8	; 0x08
     cb0:	9a 83       	std	Y+2, r25	; 0x02
     cb2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     cb4:	89 81       	ldd	r24, Y+1	; 0x01
     cb6:	eb 81       	ldd	r30, Y+3	; 0x03
     cb8:	fc 81       	ldd	r31, Y+4	; 0x04
     cba:	80 83       	st	Z, r24
	pxTopOfStack--;
     cbc:	8b 81       	ldd	r24, Y+3	; 0x03
     cbe:	9c 81       	ldd	r25, Y+4	; 0x04
     cc0:	01 97       	sbiw	r24, 0x01	; 1
     cc2:	9c 83       	std	Y+4, r25	; 0x04
     cc4:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     cc6:	89 81       	ldd	r24, Y+1	; 0x01
     cc8:	9a 81       	ldd	r25, Y+2	; 0x02
     cca:	89 2f       	mov	r24, r25
     ccc:	99 27       	eor	r25, r25
     cce:	9a 83       	std	Y+2, r25	; 0x02
     cd0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     cd2:	89 81       	ldd	r24, Y+1	; 0x01
     cd4:	eb 81       	ldd	r30, Y+3	; 0x03
     cd6:	fc 81       	ldd	r31, Y+4	; 0x04
     cd8:	80 83       	st	Z, r24
	pxTopOfStack--;
     cda:	8b 81       	ldd	r24, Y+3	; 0x03
     cdc:	9c 81       	ldd	r25, Y+4	; 0x04
     cde:	01 97       	sbiw	r24, 0x01	; 1
     ce0:	9c 83       	std	Y+4, r25	; 0x04
     ce2:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     ce4:	eb 81       	ldd	r30, Y+3	; 0x03
     ce6:	fc 81       	ldd	r31, Y+4	; 0x04
     ce8:	86 e2       	ldi	r24, 0x26	; 38
     cea:	80 83       	st	Z, r24
	pxTopOfStack--;
     cec:	8b 81       	ldd	r24, Y+3	; 0x03
     cee:	9c 81       	ldd	r25, Y+4	; 0x04
     cf0:	01 97       	sbiw	r24, 0x01	; 1
     cf2:	9c 83       	std	Y+4, r25	; 0x04
     cf4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     cf6:	eb 81       	ldd	r30, Y+3	; 0x03
     cf8:	fc 81       	ldd	r31, Y+4	; 0x04
     cfa:	87 e2       	ldi	r24, 0x27	; 39
     cfc:	80 83       	st	Z, r24
	pxTopOfStack--;
     cfe:	8b 81       	ldd	r24, Y+3	; 0x03
     d00:	9c 81       	ldd	r25, Y+4	; 0x04
     d02:	01 97       	sbiw	r24, 0x01	; 1
     d04:	9c 83       	std	Y+4, r25	; 0x04
     d06:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     d08:	eb 81       	ldd	r30, Y+3	; 0x03
     d0a:	fc 81       	ldd	r31, Y+4	; 0x04
     d0c:	88 e2       	ldi	r24, 0x28	; 40
     d0e:	80 83       	st	Z, r24
	pxTopOfStack--;
     d10:	8b 81       	ldd	r24, Y+3	; 0x03
     d12:	9c 81       	ldd	r25, Y+4	; 0x04
     d14:	01 97       	sbiw	r24, 0x01	; 1
     d16:	9c 83       	std	Y+4, r25	; 0x04
     d18:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     d1a:	eb 81       	ldd	r30, Y+3	; 0x03
     d1c:	fc 81       	ldd	r31, Y+4	; 0x04
     d1e:	89 e2       	ldi	r24, 0x29	; 41
     d20:	80 83       	st	Z, r24
	pxTopOfStack--;
     d22:	8b 81       	ldd	r24, Y+3	; 0x03
     d24:	9c 81       	ldd	r25, Y+4	; 0x04
     d26:	01 97       	sbiw	r24, 0x01	; 1
     d28:	9c 83       	std	Y+4, r25	; 0x04
     d2a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     d2c:	eb 81       	ldd	r30, Y+3	; 0x03
     d2e:	fc 81       	ldd	r31, Y+4	; 0x04
     d30:	80 e3       	ldi	r24, 0x30	; 48
     d32:	80 83       	st	Z, r24
	pxTopOfStack--;
     d34:	8b 81       	ldd	r24, Y+3	; 0x03
     d36:	9c 81       	ldd	r25, Y+4	; 0x04
     d38:	01 97       	sbiw	r24, 0x01	; 1
     d3a:	9c 83       	std	Y+4, r25	; 0x04
     d3c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     d3e:	eb 81       	ldd	r30, Y+3	; 0x03
     d40:	fc 81       	ldd	r31, Y+4	; 0x04
     d42:	81 e3       	ldi	r24, 0x31	; 49
     d44:	80 83       	st	Z, r24
	pxTopOfStack--;
     d46:	8b 81       	ldd	r24, Y+3	; 0x03
     d48:	9c 81       	ldd	r25, Y+4	; 0x04
     d4a:	01 97       	sbiw	r24, 0x01	; 1
     d4c:	9c 83       	std	Y+4, r25	; 0x04
     d4e:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     d50:	8b 81       	ldd	r24, Y+3	; 0x03
     d52:	9c 81       	ldd	r25, Y+4	; 0x04
}
     d54:	28 96       	adiw	r28, 0x08	; 8
     d56:	0f b6       	in	r0, 0x3f	; 63
     d58:	f8 94       	cli
     d5a:	de bf       	out	0x3e, r29	; 62
     d5c:	0f be       	out	0x3f, r0	; 63
     d5e:	cd bf       	out	0x3d, r28	; 61
     d60:	cf 91       	pop	r28
     d62:	df 91       	pop	r29
     d64:	08 95       	ret

00000d66 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
     d66:	df 93       	push	r29
     d68:	cf 93       	push	r28
     d6a:	cd b7       	in	r28, 0x3d	; 61
     d6c:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     d6e:	0e 94 a3 07 	call	0xf46	; 0xf46 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     d72:	a0 91 0c 03 	lds	r26, 0x030C
     d76:	b0 91 0d 03 	lds	r27, 0x030D
     d7a:	cd 91       	ld	r28, X+
     d7c:	cd bf       	out	0x3d, r28	; 61
     d7e:	dd 91       	ld	r29, X+
     d80:	de bf       	out	0x3e, r29	; 62
     d82:	ff 91       	pop	r31
     d84:	ef 91       	pop	r30
     d86:	df 91       	pop	r29
     d88:	cf 91       	pop	r28
     d8a:	bf 91       	pop	r27
     d8c:	af 91       	pop	r26
     d8e:	9f 91       	pop	r25
     d90:	8f 91       	pop	r24
     d92:	7f 91       	pop	r23
     d94:	6f 91       	pop	r22
     d96:	5f 91       	pop	r21
     d98:	4f 91       	pop	r20
     d9a:	3f 91       	pop	r19
     d9c:	2f 91       	pop	r18
     d9e:	1f 91       	pop	r17
     da0:	0f 91       	pop	r16
     da2:	ff 90       	pop	r15
     da4:	ef 90       	pop	r14
     da6:	df 90       	pop	r13
     da8:	cf 90       	pop	r12
     daa:	bf 90       	pop	r11
     dac:	af 90       	pop	r10
     dae:	9f 90       	pop	r9
     db0:	8f 90       	pop	r8
     db2:	7f 90       	pop	r7
     db4:	6f 90       	pop	r6
     db6:	5f 90       	pop	r5
     db8:	4f 90       	pop	r4
     dba:	3f 90       	pop	r3
     dbc:	2f 90       	pop	r2
     dbe:	1f 90       	pop	r1
     dc0:	0f 90       	pop	r0
     dc2:	0f be       	out	0x3f, r0	; 63
     dc4:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     dc6:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     dc8:	81 e0       	ldi	r24, 0x01	; 1
}
     dca:	cf 91       	pop	r28
     dcc:	df 91       	pop	r29
     dce:	08 95       	ret

00000dd0 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     dd0:	df 93       	push	r29
     dd2:	cf 93       	push	r28
     dd4:	cd b7       	in	r28, 0x3d	; 61
     dd6:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     dd8:	cf 91       	pop	r28
     dda:	df 91       	pop	r29
     ddc:	08 95       	ret

00000dde <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     dde:	0f 92       	push	r0
     de0:	0f b6       	in	r0, 0x3f	; 63
     de2:	f8 94       	cli
     de4:	0f 92       	push	r0
     de6:	1f 92       	push	r1
     de8:	11 24       	eor	r1, r1
     dea:	2f 92       	push	r2
     dec:	3f 92       	push	r3
     dee:	4f 92       	push	r4
     df0:	5f 92       	push	r5
     df2:	6f 92       	push	r6
     df4:	7f 92       	push	r7
     df6:	8f 92       	push	r8
     df8:	9f 92       	push	r9
     dfa:	af 92       	push	r10
     dfc:	bf 92       	push	r11
     dfe:	cf 92       	push	r12
     e00:	df 92       	push	r13
     e02:	ef 92       	push	r14
     e04:	ff 92       	push	r15
     e06:	0f 93       	push	r16
     e08:	1f 93       	push	r17
     e0a:	2f 93       	push	r18
     e0c:	3f 93       	push	r19
     e0e:	4f 93       	push	r20
     e10:	5f 93       	push	r21
     e12:	6f 93       	push	r22
     e14:	7f 93       	push	r23
     e16:	8f 93       	push	r24
     e18:	9f 93       	push	r25
     e1a:	af 93       	push	r26
     e1c:	bf 93       	push	r27
     e1e:	cf 93       	push	r28
     e20:	df 93       	push	r29
     e22:	ef 93       	push	r30
     e24:	ff 93       	push	r31
     e26:	a0 91 0c 03 	lds	r26, 0x030C
     e2a:	b0 91 0d 03 	lds	r27, 0x030D
     e2e:	0d b6       	in	r0, 0x3d	; 61
     e30:	0d 92       	st	X+, r0
     e32:	0e b6       	in	r0, 0x3e	; 62
     e34:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     e36:	0e 94 84 10 	call	0x2108	; 0x2108 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     e3a:	a0 91 0c 03 	lds	r26, 0x030C
     e3e:	b0 91 0d 03 	lds	r27, 0x030D
     e42:	cd 91       	ld	r28, X+
     e44:	cd bf       	out	0x3d, r28	; 61
     e46:	dd 91       	ld	r29, X+
     e48:	de bf       	out	0x3e, r29	; 62
     e4a:	ff 91       	pop	r31
     e4c:	ef 91       	pop	r30
     e4e:	df 91       	pop	r29
     e50:	cf 91       	pop	r28
     e52:	bf 91       	pop	r27
     e54:	af 91       	pop	r26
     e56:	9f 91       	pop	r25
     e58:	8f 91       	pop	r24
     e5a:	7f 91       	pop	r23
     e5c:	6f 91       	pop	r22
     e5e:	5f 91       	pop	r21
     e60:	4f 91       	pop	r20
     e62:	3f 91       	pop	r19
     e64:	2f 91       	pop	r18
     e66:	1f 91       	pop	r17
     e68:	0f 91       	pop	r16
     e6a:	ff 90       	pop	r15
     e6c:	ef 90       	pop	r14
     e6e:	df 90       	pop	r13
     e70:	cf 90       	pop	r12
     e72:	bf 90       	pop	r11
     e74:	af 90       	pop	r10
     e76:	9f 90       	pop	r9
     e78:	8f 90       	pop	r8
     e7a:	7f 90       	pop	r7
     e7c:	6f 90       	pop	r6
     e7e:	5f 90       	pop	r5
     e80:	4f 90       	pop	r4
     e82:	3f 90       	pop	r3
     e84:	2f 90       	pop	r2
     e86:	1f 90       	pop	r1
     e88:	0f 90       	pop	r0
     e8a:	0f be       	out	0x3f, r0	; 63
     e8c:	0f 90       	pop	r0

	asm volatile ( "ret" );
     e8e:	08 95       	ret

00000e90 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     e90:	0f 92       	push	r0
     e92:	0f b6       	in	r0, 0x3f	; 63
     e94:	f8 94       	cli
     e96:	0f 92       	push	r0
     e98:	1f 92       	push	r1
     e9a:	11 24       	eor	r1, r1
     e9c:	2f 92       	push	r2
     e9e:	3f 92       	push	r3
     ea0:	4f 92       	push	r4
     ea2:	5f 92       	push	r5
     ea4:	6f 92       	push	r6
     ea6:	7f 92       	push	r7
     ea8:	8f 92       	push	r8
     eaa:	9f 92       	push	r9
     eac:	af 92       	push	r10
     eae:	bf 92       	push	r11
     eb0:	cf 92       	push	r12
     eb2:	df 92       	push	r13
     eb4:	ef 92       	push	r14
     eb6:	ff 92       	push	r15
     eb8:	0f 93       	push	r16
     eba:	1f 93       	push	r17
     ebc:	2f 93       	push	r18
     ebe:	3f 93       	push	r19
     ec0:	4f 93       	push	r20
     ec2:	5f 93       	push	r21
     ec4:	6f 93       	push	r22
     ec6:	7f 93       	push	r23
     ec8:	8f 93       	push	r24
     eca:	9f 93       	push	r25
     ecc:	af 93       	push	r26
     ece:	bf 93       	push	r27
     ed0:	cf 93       	push	r28
     ed2:	df 93       	push	r29
     ed4:	ef 93       	push	r30
     ed6:	ff 93       	push	r31
     ed8:	a0 91 0c 03 	lds	r26, 0x030C
     edc:	b0 91 0d 03 	lds	r27, 0x030D
     ee0:	0d b6       	in	r0, 0x3d	; 61
     ee2:	0d 92       	st	X+, r0
     ee4:	0e b6       	in	r0, 0x3e	; 62
     ee6:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     ee8:	0e 94 af 0f 	call	0x1f5e	; 0x1f5e <vTaskIncrementTick>
	vTaskSwitchContext();
     eec:	0e 94 84 10 	call	0x2108	; 0x2108 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     ef0:	a0 91 0c 03 	lds	r26, 0x030C
     ef4:	b0 91 0d 03 	lds	r27, 0x030D
     ef8:	cd 91       	ld	r28, X+
     efa:	cd bf       	out	0x3d, r28	; 61
     efc:	dd 91       	ld	r29, X+
     efe:	de bf       	out	0x3e, r29	; 62
     f00:	ff 91       	pop	r31
     f02:	ef 91       	pop	r30
     f04:	df 91       	pop	r29
     f06:	cf 91       	pop	r28
     f08:	bf 91       	pop	r27
     f0a:	af 91       	pop	r26
     f0c:	9f 91       	pop	r25
     f0e:	8f 91       	pop	r24
     f10:	7f 91       	pop	r23
     f12:	6f 91       	pop	r22
     f14:	5f 91       	pop	r21
     f16:	4f 91       	pop	r20
     f18:	3f 91       	pop	r19
     f1a:	2f 91       	pop	r18
     f1c:	1f 91       	pop	r17
     f1e:	0f 91       	pop	r16
     f20:	ff 90       	pop	r15
     f22:	ef 90       	pop	r14
     f24:	df 90       	pop	r13
     f26:	cf 90       	pop	r12
     f28:	bf 90       	pop	r11
     f2a:	af 90       	pop	r10
     f2c:	9f 90       	pop	r9
     f2e:	8f 90       	pop	r8
     f30:	7f 90       	pop	r7
     f32:	6f 90       	pop	r6
     f34:	5f 90       	pop	r5
     f36:	4f 90       	pop	r4
     f38:	3f 90       	pop	r3
     f3a:	2f 90       	pop	r2
     f3c:	1f 90       	pop	r1
     f3e:	0f 90       	pop	r0
     f40:	0f be       	out	0x3f, r0	; 63
     f42:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f44:	08 95       	ret

00000f46 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     f46:	df 93       	push	r29
     f48:	cf 93       	push	r28
     f4a:	00 d0       	rcall	.+0      	; 0xf4c <prvSetupTimerInterrupt+0x6>
     f4c:	00 d0       	rcall	.+0      	; 0xf4e <prvSetupTimerInterrupt+0x8>
     f4e:	00 d0       	rcall	.+0      	; 0xf50 <prvSetupTimerInterrupt+0xa>
     f50:	cd b7       	in	r28, 0x3d	; 61
     f52:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     f54:	80 e4       	ldi	r24, 0x40	; 64
     f56:	9f e1       	ldi	r25, 0x1F	; 31
     f58:	a0 e0       	ldi	r26, 0x00	; 0
     f5a:	b0 e0       	ldi	r27, 0x00	; 0
     f5c:	8b 83       	std	Y+3, r24	; 0x03
     f5e:	9c 83       	std	Y+4, r25	; 0x04
     f60:	ad 83       	std	Y+5, r26	; 0x05
     f62:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     f64:	8b 81       	ldd	r24, Y+3	; 0x03
     f66:	9c 81       	ldd	r25, Y+4	; 0x04
     f68:	ad 81       	ldd	r26, Y+5	; 0x05
     f6a:	be 81       	ldd	r27, Y+6	; 0x06
     f6c:	68 94       	set
     f6e:	15 f8       	bld	r1, 5
     f70:	b6 95       	lsr	r27
     f72:	a7 95       	ror	r26
     f74:	97 95       	ror	r25
     f76:	87 95       	ror	r24
     f78:	16 94       	lsr	r1
     f7a:	d1 f7       	brne	.-12     	; 0xf70 <prvSetupTimerInterrupt+0x2a>
     f7c:	8b 83       	std	Y+3, r24	; 0x03
     f7e:	9c 83       	std	Y+4, r25	; 0x04
     f80:	ad 83       	std	Y+5, r26	; 0x05
     f82:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
     f84:	8b 81       	ldd	r24, Y+3	; 0x03
     f86:	9c 81       	ldd	r25, Y+4	; 0x04
     f88:	ad 81       	ldd	r26, Y+5	; 0x05
     f8a:	be 81       	ldd	r27, Y+6	; 0x06
     f8c:	01 97       	sbiw	r24, 0x01	; 1
     f8e:	a1 09       	sbc	r26, r1
     f90:	b1 09       	sbc	r27, r1
     f92:	8b 83       	std	Y+3, r24	; 0x03
     f94:	9c 83       	std	Y+4, r25	; 0x04
     f96:	ad 83       	std	Y+5, r26	; 0x05
     f98:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
     f9a:	8b 81       	ldd	r24, Y+3	; 0x03
     f9c:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
     f9e:	8b 81       	ldd	r24, Y+3	; 0x03
     fa0:	9c 81       	ldd	r25, Y+4	; 0x04
     fa2:	ad 81       	ldd	r26, Y+5	; 0x05
     fa4:	be 81       	ldd	r27, Y+6	; 0x06
     fa6:	89 2f       	mov	r24, r25
     fa8:	9a 2f       	mov	r25, r26
     faa:	ab 2f       	mov	r26, r27
     fac:	bb 27       	eor	r27, r27
     fae:	8b 83       	std	Y+3, r24	; 0x03
     fb0:	9c 83       	std	Y+4, r25	; 0x04
     fb2:	ad 83       	std	Y+5, r26	; 0x05
     fb4:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
     fb6:	8b 81       	ldd	r24, Y+3	; 0x03
     fb8:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
     fba:	eb e4       	ldi	r30, 0x4B	; 75
     fbc:	f0 e0       	ldi	r31, 0x00	; 0
     fbe:	8a 81       	ldd	r24, Y+2	; 0x02
     fc0:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
     fc2:	ea e4       	ldi	r30, 0x4A	; 74
     fc4:	f0 e0       	ldi	r31, 0x00	; 0
     fc6:	89 81       	ldd	r24, Y+1	; 0x01
     fc8:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     fca:	8b e0       	ldi	r24, 0x0B	; 11
     fcc:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
     fce:	ee e4       	ldi	r30, 0x4E	; 78
     fd0:	f0 e0       	ldi	r31, 0x00	; 0
     fd2:	89 81       	ldd	r24, Y+1	; 0x01
     fd4:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     fd6:	e9 e5       	ldi	r30, 0x59	; 89
     fd8:	f0 e0       	ldi	r31, 0x00	; 0
     fda:	80 81       	ld	r24, Z
     fdc:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     fde:	89 81       	ldd	r24, Y+1	; 0x01
     fe0:	80 61       	ori	r24, 0x10	; 16
     fe2:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
     fe4:	e9 e5       	ldi	r30, 0x59	; 89
     fe6:	f0 e0       	ldi	r31, 0x00	; 0
     fe8:	89 81       	ldd	r24, Y+1	; 0x01
     fea:	80 83       	st	Z, r24
}
     fec:	26 96       	adiw	r28, 0x06	; 6
     fee:	0f b6       	in	r0, 0x3f	; 63
     ff0:	f8 94       	cli
     ff2:	de bf       	out	0x3e, r29	; 62
     ff4:	0f be       	out	0x3f, r0	; 63
     ff6:	cd bf       	out	0x3d, r28	; 61
     ff8:	cf 91       	pop	r28
     ffa:	df 91       	pop	r29
     ffc:	08 95       	ret

00000ffe <__vector_7>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
     ffe:	1f 92       	push	r1
    1000:	0f 92       	push	r0
    1002:	0f b6       	in	r0, 0x3f	; 63
    1004:	0f 92       	push	r0
    1006:	11 24       	eor	r1, r1
    1008:	2f 93       	push	r18
    100a:	3f 93       	push	r19
    100c:	4f 93       	push	r20
    100e:	5f 93       	push	r21
    1010:	6f 93       	push	r22
    1012:	7f 93       	push	r23
    1014:	8f 93       	push	r24
    1016:	9f 93       	push	r25
    1018:	af 93       	push	r26
    101a:	bf 93       	push	r27
    101c:	ef 93       	push	r30
    101e:	ff 93       	push	r31
    1020:	df 93       	push	r29
    1022:	cf 93       	push	r28
    1024:	cd b7       	in	r28, 0x3d	; 61
    1026:	de b7       	in	r29, 0x3e	; 62
		vTaskIncrementTick();
    1028:	0e 94 af 0f 	call	0x1f5e	; 0x1f5e <vTaskIncrementTick>
	}
    102c:	cf 91       	pop	r28
    102e:	df 91       	pop	r29
    1030:	ff 91       	pop	r31
    1032:	ef 91       	pop	r30
    1034:	bf 91       	pop	r27
    1036:	af 91       	pop	r26
    1038:	9f 91       	pop	r25
    103a:	8f 91       	pop	r24
    103c:	7f 91       	pop	r23
    103e:	6f 91       	pop	r22
    1040:	5f 91       	pop	r21
    1042:	4f 91       	pop	r20
    1044:	3f 91       	pop	r19
    1046:	2f 91       	pop	r18
    1048:	0f 90       	pop	r0
    104a:	0f be       	out	0x3f, r0	; 63
    104c:	0f 90       	pop	r0
    104e:	1f 90       	pop	r1
    1050:	18 95       	reti

00001052 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    1052:	df 93       	push	r29
    1054:	cf 93       	push	r28
    1056:	cd b7       	in	r28, 0x3d	; 61
    1058:	de b7       	in	r29, 0x3e	; 62
    105a:	28 97       	sbiw	r28, 0x08	; 8
    105c:	0f b6       	in	r0, 0x3f	; 63
    105e:	f8 94       	cli
    1060:	de bf       	out	0x3e, r29	; 62
    1062:	0f be       	out	0x3f, r0	; 63
    1064:	cd bf       	out	0x3d, r28	; 61
    1066:	8f 83       	std	Y+7, r24	; 0x07
    1068:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    106a:	1a 82       	std	Y+2, r1	; 0x02
    106c:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    106e:	8f 81       	ldd	r24, Y+7	; 0x07
    1070:	88 23       	and	r24, r24
    1072:	09 f4       	brne	.+2      	; 0x1076 <xQueueCreate+0x24>
    1074:	8c c0       	rjmp	.+280    	; 0x118e <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1076:	8f e1       	ldi	r24, 0x1F	; 31
    1078:	90 e0       	ldi	r25, 0x00	; 0
    107a:	0e 94 89 03 	call	0x712	; 0x712 <pvPortMalloc>
    107e:	9e 83       	std	Y+6, r25	; 0x06
    1080:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    1082:	8d 81       	ldd	r24, Y+5	; 0x05
    1084:	9e 81       	ldd	r25, Y+6	; 0x06
    1086:	00 97       	sbiw	r24, 0x00	; 0
    1088:	09 f4       	brne	.+2      	; 0x108c <xQueueCreate+0x3a>
    108a:	81 c0       	rjmp	.+258    	; 0x118e <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    108c:	8f 81       	ldd	r24, Y+7	; 0x07
    108e:	28 2f       	mov	r18, r24
    1090:	30 e0       	ldi	r19, 0x00	; 0
    1092:	88 85       	ldd	r24, Y+8	; 0x08
    1094:	88 2f       	mov	r24, r24
    1096:	90 e0       	ldi	r25, 0x00	; 0
    1098:	ac 01       	movw	r20, r24
    109a:	24 9f       	mul	r18, r20
    109c:	c0 01       	movw	r24, r0
    109e:	25 9f       	mul	r18, r21
    10a0:	90 0d       	add	r25, r0
    10a2:	34 9f       	mul	r19, r20
    10a4:	90 0d       	add	r25, r0
    10a6:	11 24       	eor	r1, r1
    10a8:	01 96       	adiw	r24, 0x01	; 1
    10aa:	9c 83       	std	Y+4, r25	; 0x04
    10ac:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    10ae:	8b 81       	ldd	r24, Y+3	; 0x03
    10b0:	9c 81       	ldd	r25, Y+4	; 0x04
    10b2:	0e 94 89 03 	call	0x712	; 0x712 <pvPortMalloc>
    10b6:	ed 81       	ldd	r30, Y+5	; 0x05
    10b8:	fe 81       	ldd	r31, Y+6	; 0x06
    10ba:	91 83       	std	Z+1, r25	; 0x01
    10bc:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    10be:	ed 81       	ldd	r30, Y+5	; 0x05
    10c0:	fe 81       	ldd	r31, Y+6	; 0x06
    10c2:	80 81       	ld	r24, Z
    10c4:	91 81       	ldd	r25, Z+1	; 0x01
    10c6:	00 97       	sbiw	r24, 0x00	; 0
    10c8:	09 f4       	brne	.+2      	; 0x10cc <xQueueCreate+0x7a>
    10ca:	5d c0       	rjmp	.+186    	; 0x1186 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    10cc:	ed 81       	ldd	r30, Y+5	; 0x05
    10ce:	fe 81       	ldd	r31, Y+6	; 0x06
    10d0:	40 81       	ld	r20, Z
    10d2:	51 81       	ldd	r21, Z+1	; 0x01
    10d4:	8f 81       	ldd	r24, Y+7	; 0x07
    10d6:	28 2f       	mov	r18, r24
    10d8:	30 e0       	ldi	r19, 0x00	; 0
    10da:	88 85       	ldd	r24, Y+8	; 0x08
    10dc:	88 2f       	mov	r24, r24
    10de:	90 e0       	ldi	r25, 0x00	; 0
    10e0:	bc 01       	movw	r22, r24
    10e2:	26 9f       	mul	r18, r22
    10e4:	c0 01       	movw	r24, r0
    10e6:	27 9f       	mul	r18, r23
    10e8:	90 0d       	add	r25, r0
    10ea:	36 9f       	mul	r19, r22
    10ec:	90 0d       	add	r25, r0
    10ee:	11 24       	eor	r1, r1
    10f0:	84 0f       	add	r24, r20
    10f2:	95 1f       	adc	r25, r21
    10f4:	ed 81       	ldd	r30, Y+5	; 0x05
    10f6:	fe 81       	ldd	r31, Y+6	; 0x06
    10f8:	93 83       	std	Z+3, r25	; 0x03
    10fa:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    10fc:	ed 81       	ldd	r30, Y+5	; 0x05
    10fe:	fe 81       	ldd	r31, Y+6	; 0x06
    1100:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    1102:	ed 81       	ldd	r30, Y+5	; 0x05
    1104:	fe 81       	ldd	r31, Y+6	; 0x06
    1106:	80 81       	ld	r24, Z
    1108:	91 81       	ldd	r25, Z+1	; 0x01
    110a:	ed 81       	ldd	r30, Y+5	; 0x05
    110c:	fe 81       	ldd	r31, Y+6	; 0x06
    110e:	95 83       	std	Z+5, r25	; 0x05
    1110:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    1112:	ed 81       	ldd	r30, Y+5	; 0x05
    1114:	fe 81       	ldd	r31, Y+6	; 0x06
    1116:	40 81       	ld	r20, Z
    1118:	51 81       	ldd	r21, Z+1	; 0x01
    111a:	8f 81       	ldd	r24, Y+7	; 0x07
    111c:	88 2f       	mov	r24, r24
    111e:	90 e0       	ldi	r25, 0x00	; 0
    1120:	9c 01       	movw	r18, r24
    1122:	21 50       	subi	r18, 0x01	; 1
    1124:	30 40       	sbci	r19, 0x00	; 0
    1126:	88 85       	ldd	r24, Y+8	; 0x08
    1128:	88 2f       	mov	r24, r24
    112a:	90 e0       	ldi	r25, 0x00	; 0
    112c:	bc 01       	movw	r22, r24
    112e:	26 9f       	mul	r18, r22
    1130:	c0 01       	movw	r24, r0
    1132:	27 9f       	mul	r18, r23
    1134:	90 0d       	add	r25, r0
    1136:	36 9f       	mul	r19, r22
    1138:	90 0d       	add	r25, r0
    113a:	11 24       	eor	r1, r1
    113c:	84 0f       	add	r24, r20
    113e:	95 1f       	adc	r25, r21
    1140:	ed 81       	ldd	r30, Y+5	; 0x05
    1142:	fe 81       	ldd	r31, Y+6	; 0x06
    1144:	97 83       	std	Z+7, r25	; 0x07
    1146:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    1148:	ed 81       	ldd	r30, Y+5	; 0x05
    114a:	fe 81       	ldd	r31, Y+6	; 0x06
    114c:	8f 81       	ldd	r24, Y+7	; 0x07
    114e:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1150:	ed 81       	ldd	r30, Y+5	; 0x05
    1152:	fe 81       	ldd	r31, Y+6	; 0x06
    1154:	88 85       	ldd	r24, Y+8	; 0x08
    1156:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    1158:	ed 81       	ldd	r30, Y+5	; 0x05
    115a:	fe 81       	ldd	r31, Y+6	; 0x06
    115c:	8f ef       	ldi	r24, 0xFF	; 255
    115e:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    1160:	ed 81       	ldd	r30, Y+5	; 0x05
    1162:	fe 81       	ldd	r31, Y+6	; 0x06
    1164:	8f ef       	ldi	r24, 0xFF	; 255
    1166:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1168:	8d 81       	ldd	r24, Y+5	; 0x05
    116a:	9e 81       	ldd	r25, Y+6	; 0x06
    116c:	08 96       	adiw	r24, 0x08	; 8
    116e:	0e 94 f5 03 	call	0x7ea	; 0x7ea <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1172:	8d 81       	ldd	r24, Y+5	; 0x05
    1174:	9e 81       	ldd	r25, Y+6	; 0x06
    1176:	41 96       	adiw	r24, 0x11	; 17
    1178:	0e 94 f5 03 	call	0x7ea	; 0x7ea <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    117c:	8d 81       	ldd	r24, Y+5	; 0x05
    117e:	9e 81       	ldd	r25, Y+6	; 0x06
    1180:	9a 83       	std	Y+2, r25	; 0x02
    1182:	89 83       	std	Y+1, r24	; 0x01
    1184:	04 c0       	rjmp	.+8      	; 0x118e <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    1186:	8d 81       	ldd	r24, Y+5	; 0x05
    1188:	9e 81       	ldd	r25, Y+6	; 0x06
    118a:	0e 94 cf 03 	call	0x79e	; 0x79e <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    118e:	89 81       	ldd	r24, Y+1	; 0x01
    1190:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1192:	28 96       	adiw	r28, 0x08	; 8
    1194:	0f b6       	in	r0, 0x3f	; 63
    1196:	f8 94       	cli
    1198:	de bf       	out	0x3e, r29	; 62
    119a:	0f be       	out	0x3f, r0	; 63
    119c:	cd bf       	out	0x3d, r28	; 61
    119e:	cf 91       	pop	r28
    11a0:	df 91       	pop	r29
    11a2:	08 95       	ret

000011a4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    11a4:	df 93       	push	r29
    11a6:	cf 93       	push	r28
    11a8:	cd b7       	in	r28, 0x3d	; 61
    11aa:	de b7       	in	r29, 0x3e	; 62
    11ac:	2c 97       	sbiw	r28, 0x0c	; 12
    11ae:	0f b6       	in	r0, 0x3f	; 63
    11b0:	f8 94       	cli
    11b2:	de bf       	out	0x3e, r29	; 62
    11b4:	0f be       	out	0x3f, r0	; 63
    11b6:	cd bf       	out	0x3d, r28	; 61
    11b8:	9e 83       	std	Y+6, r25	; 0x06
    11ba:	8d 83       	std	Y+5, r24	; 0x05
    11bc:	78 87       	std	Y+8, r23	; 0x08
    11be:	6f 83       	std	Y+7, r22	; 0x07
    11c0:	5a 87       	std	Y+10, r21	; 0x0a
    11c2:	49 87       	std	Y+9, r20	; 0x09
    11c4:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    11c6:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    11c8:	0f b6       	in	r0, 0x3f	; 63
    11ca:	f8 94       	cli
    11cc:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    11ce:	ed 81       	ldd	r30, Y+5	; 0x05
    11d0:	fe 81       	ldd	r31, Y+6	; 0x06
    11d2:	92 8d       	ldd	r25, Z+26	; 0x1a
    11d4:	ed 81       	ldd	r30, Y+5	; 0x05
    11d6:	fe 81       	ldd	r31, Y+6	; 0x06
    11d8:	83 8d       	ldd	r24, Z+27	; 0x1b
    11da:	98 17       	cp	r25, r24
    11dc:	d8 f4       	brcc	.+54     	; 0x1214 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    11de:	8d 81       	ldd	r24, Y+5	; 0x05
    11e0:	9e 81       	ldd	r25, Y+6	; 0x06
    11e2:	2f 81       	ldd	r18, Y+7	; 0x07
    11e4:	38 85       	ldd	r19, Y+8	; 0x08
    11e6:	b9 01       	movw	r22, r18
    11e8:	4b 85       	ldd	r20, Y+11	; 0x0b
    11ea:	0e 94 0d 0b 	call	0x161a	; 0x161a <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    11ee:	ed 81       	ldd	r30, Y+5	; 0x05
    11f0:	fe 81       	ldd	r31, Y+6	; 0x06
    11f2:	81 89       	ldd	r24, Z+17	; 0x11
    11f4:	88 23       	and	r24, r24
    11f6:	49 f0       	breq	.+18     	; 0x120a <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    11f8:	8d 81       	ldd	r24, Y+5	; 0x05
    11fa:	9e 81       	ldd	r25, Y+6	; 0x06
    11fc:	41 96       	adiw	r24, 0x11	; 17
    11fe:	0e 94 20 11 	call	0x2240	; 0x2240 <xTaskRemoveFromEventList>
    1202:	81 30       	cpi	r24, 0x01	; 1
    1204:	11 f4       	brne	.+4      	; 0x120a <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1206:	0e 94 ef 06 	call	0xdde	; 0xdde <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    120a:	0f 90       	pop	r0
    120c:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    120e:	81 e0       	ldi	r24, 0x01	; 1
    1210:	8c 87       	std	Y+12, r24	; 0x0c
    1212:	5c c0       	rjmp	.+184    	; 0x12cc <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1214:	89 85       	ldd	r24, Y+9	; 0x09
    1216:	9a 85       	ldd	r25, Y+10	; 0x0a
    1218:	00 97       	sbiw	r24, 0x00	; 0
    121a:	21 f4       	brne	.+8      	; 0x1224 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    121c:	0f 90       	pop	r0
    121e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1220:	1c 86       	std	Y+12, r1	; 0x0c
    1222:	54 c0       	rjmp	.+168    	; 0x12cc <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    1224:	89 81       	ldd	r24, Y+1	; 0x01
    1226:	88 23       	and	r24, r24
    1228:	31 f4       	brne	.+12     	; 0x1236 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    122a:	ce 01       	movw	r24, r28
    122c:	02 96       	adiw	r24, 0x02	; 2
    122e:	0e 94 88 11 	call	0x2310	; 0x2310 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1232:	81 e0       	ldi	r24, 0x01	; 1
    1234:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1236:	0f 90       	pop	r0
    1238:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    123a:	0e 94 e6 0e 	call	0x1dcc	; 0x1dcc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    123e:	0f b6       	in	r0, 0x3f	; 63
    1240:	f8 94       	cli
    1242:	0f 92       	push	r0
    1244:	ed 81       	ldd	r30, Y+5	; 0x05
    1246:	fe 81       	ldd	r31, Y+6	; 0x06
    1248:	85 8d       	ldd	r24, Z+29	; 0x1d
    124a:	8f 3f       	cpi	r24, 0xFF	; 255
    124c:	19 f4       	brne	.+6      	; 0x1254 <xQueueGenericSend+0xb0>
    124e:	ed 81       	ldd	r30, Y+5	; 0x05
    1250:	fe 81       	ldd	r31, Y+6	; 0x06
    1252:	15 8e       	std	Z+29, r1	; 0x1d
    1254:	ed 81       	ldd	r30, Y+5	; 0x05
    1256:	fe 81       	ldd	r31, Y+6	; 0x06
    1258:	86 8d       	ldd	r24, Z+30	; 0x1e
    125a:	8f 3f       	cpi	r24, 0xFF	; 255
    125c:	19 f4       	brne	.+6      	; 0x1264 <xQueueGenericSend+0xc0>
    125e:	ed 81       	ldd	r30, Y+5	; 0x05
    1260:	fe 81       	ldd	r31, Y+6	; 0x06
    1262:	16 8e       	std	Z+30, r1	; 0x1e
    1264:	0f 90       	pop	r0
    1266:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1268:	ce 01       	movw	r24, r28
    126a:	02 96       	adiw	r24, 0x02	; 2
    126c:	9e 01       	movw	r18, r28
    126e:	27 5f       	subi	r18, 0xF7	; 247
    1270:	3f 4f       	sbci	r19, 0xFF	; 255
    1272:	b9 01       	movw	r22, r18
    1274:	0e 94 a1 11 	call	0x2342	; 0x2342 <xTaskCheckForTimeOut>
    1278:	88 23       	and	r24, r24
    127a:	09 f5       	brne	.+66     	; 0x12be <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    127c:	8d 81       	ldd	r24, Y+5	; 0x05
    127e:	9e 81       	ldd	r25, Y+6	; 0x06
    1280:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <prvIsQueueFull>
    1284:	88 23       	and	r24, r24
    1286:	a1 f0       	breq	.+40     	; 0x12b0 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1288:	8d 81       	ldd	r24, Y+5	; 0x05
    128a:	9e 81       	ldd	r25, Y+6	; 0x06
    128c:	08 96       	adiw	r24, 0x08	; 8
    128e:	29 85       	ldd	r18, Y+9	; 0x09
    1290:	3a 85       	ldd	r19, Y+10	; 0x0a
    1292:	b9 01       	movw	r22, r18
    1294:	0e 94 ea 10 	call	0x21d4	; 0x21d4 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1298:	8d 81       	ldd	r24, Y+5	; 0x05
    129a:	9e 81       	ldd	r25, Y+6	; 0x06
    129c:	0e 94 ea 0b 	call	0x17d4	; 0x17d4 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    12a0:	0e 94 f2 0e 	call	0x1de4	; 0x1de4 <xTaskResumeAll>
    12a4:	88 23       	and	r24, r24
    12a6:	09 f0       	breq	.+2      	; 0x12aa <xQueueGenericSend+0x106>
    12a8:	8f cf       	rjmp	.-226    	; 0x11c8 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    12aa:	0e 94 ef 06 	call	0xdde	; 0xdde <vPortYield>
    12ae:	8c cf       	rjmp	.-232    	; 0x11c8 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    12b0:	8d 81       	ldd	r24, Y+5	; 0x05
    12b2:	9e 81       	ldd	r25, Y+6	; 0x06
    12b4:	0e 94 ea 0b 	call	0x17d4	; 0x17d4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    12b8:	0e 94 f2 0e 	call	0x1de4	; 0x1de4 <xTaskResumeAll>
    12bc:	85 cf       	rjmp	.-246    	; 0x11c8 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    12be:	8d 81       	ldd	r24, Y+5	; 0x05
    12c0:	9e 81       	ldd	r25, Y+6	; 0x06
    12c2:	0e 94 ea 0b 	call	0x17d4	; 0x17d4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    12c6:	0e 94 f2 0e 	call	0x1de4	; 0x1de4 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    12ca:	1c 86       	std	Y+12, r1	; 0x0c
    12cc:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    12ce:	2c 96       	adiw	r28, 0x0c	; 12
    12d0:	0f b6       	in	r0, 0x3f	; 63
    12d2:	f8 94       	cli
    12d4:	de bf       	out	0x3e, r29	; 62
    12d6:	0f be       	out	0x3f, r0	; 63
    12d8:	cd bf       	out	0x3d, r28	; 61
    12da:	cf 91       	pop	r28
    12dc:	df 91       	pop	r29
    12de:	08 95       	ret

000012e0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    12e0:	df 93       	push	r29
    12e2:	cf 93       	push	r28
    12e4:	cd b7       	in	r28, 0x3d	; 61
    12e6:	de b7       	in	r29, 0x3e	; 62
    12e8:	29 97       	sbiw	r28, 0x09	; 9
    12ea:	0f b6       	in	r0, 0x3f	; 63
    12ec:	f8 94       	cli
    12ee:	de bf       	out	0x3e, r29	; 62
    12f0:	0f be       	out	0x3f, r0	; 63
    12f2:	cd bf       	out	0x3d, r28	; 61
    12f4:	9c 83       	std	Y+4, r25	; 0x04
    12f6:	8b 83       	std	Y+3, r24	; 0x03
    12f8:	7e 83       	std	Y+6, r23	; 0x06
    12fa:	6d 83       	std	Y+5, r22	; 0x05
    12fc:	58 87       	std	Y+8, r21	; 0x08
    12fe:	4f 83       	std	Y+7, r20	; 0x07
    1300:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1302:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1304:	eb 81       	ldd	r30, Y+3	; 0x03
    1306:	fc 81       	ldd	r31, Y+4	; 0x04
    1308:	92 8d       	ldd	r25, Z+26	; 0x1a
    130a:	eb 81       	ldd	r30, Y+3	; 0x03
    130c:	fc 81       	ldd	r31, Y+4	; 0x04
    130e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1310:	98 17       	cp	r25, r24
    1312:	40 f5       	brcc	.+80     	; 0x1364 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1314:	8b 81       	ldd	r24, Y+3	; 0x03
    1316:	9c 81       	ldd	r25, Y+4	; 0x04
    1318:	2d 81       	ldd	r18, Y+5	; 0x05
    131a:	3e 81       	ldd	r19, Y+6	; 0x06
    131c:	b9 01       	movw	r22, r18
    131e:	49 85       	ldd	r20, Y+9	; 0x09
    1320:	0e 94 0d 0b 	call	0x161a	; 0x161a <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1324:	eb 81       	ldd	r30, Y+3	; 0x03
    1326:	fc 81       	ldd	r31, Y+4	; 0x04
    1328:	86 8d       	ldd	r24, Z+30	; 0x1e
    132a:	8f 3f       	cpi	r24, 0xFF	; 255
    132c:	89 f4       	brne	.+34     	; 0x1350 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    132e:	eb 81       	ldd	r30, Y+3	; 0x03
    1330:	fc 81       	ldd	r31, Y+4	; 0x04
    1332:	81 89       	ldd	r24, Z+17	; 0x11
    1334:	88 23       	and	r24, r24
    1336:	99 f0       	breq	.+38     	; 0x135e <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1338:	8b 81       	ldd	r24, Y+3	; 0x03
    133a:	9c 81       	ldd	r25, Y+4	; 0x04
    133c:	41 96       	adiw	r24, 0x11	; 17
    133e:	0e 94 20 11 	call	0x2240	; 0x2240 <xTaskRemoveFromEventList>
    1342:	88 23       	and	r24, r24
    1344:	61 f0       	breq	.+24     	; 0x135e <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1346:	ef 81       	ldd	r30, Y+7	; 0x07
    1348:	f8 85       	ldd	r31, Y+8	; 0x08
    134a:	81 e0       	ldi	r24, 0x01	; 1
    134c:	80 83       	st	Z, r24
    134e:	07 c0       	rjmp	.+14     	; 0x135e <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1350:	eb 81       	ldd	r30, Y+3	; 0x03
    1352:	fc 81       	ldd	r31, Y+4	; 0x04
    1354:	86 8d       	ldd	r24, Z+30	; 0x1e
    1356:	8f 5f       	subi	r24, 0xFF	; 255
    1358:	eb 81       	ldd	r30, Y+3	; 0x03
    135a:	fc 81       	ldd	r31, Y+4	; 0x04
    135c:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    135e:	81 e0       	ldi	r24, 0x01	; 1
    1360:	8a 83       	std	Y+2, r24	; 0x02
    1362:	01 c0       	rjmp	.+2      	; 0x1366 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1364:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1366:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1368:	29 96       	adiw	r28, 0x09	; 9
    136a:	0f b6       	in	r0, 0x3f	; 63
    136c:	f8 94       	cli
    136e:	de bf       	out	0x3e, r29	; 62
    1370:	0f be       	out	0x3f, r0	; 63
    1372:	cd bf       	out	0x3d, r28	; 61
    1374:	cf 91       	pop	r28
    1376:	df 91       	pop	r29
    1378:	08 95       	ret

0000137a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    137a:	df 93       	push	r29
    137c:	cf 93       	push	r28
    137e:	cd b7       	in	r28, 0x3d	; 61
    1380:	de b7       	in	r29, 0x3e	; 62
    1382:	2e 97       	sbiw	r28, 0x0e	; 14
    1384:	0f b6       	in	r0, 0x3f	; 63
    1386:	f8 94       	cli
    1388:	de bf       	out	0x3e, r29	; 62
    138a:	0f be       	out	0x3f, r0	; 63
    138c:	cd bf       	out	0x3d, r28	; 61
    138e:	98 87       	std	Y+8, r25	; 0x08
    1390:	8f 83       	std	Y+7, r24	; 0x07
    1392:	7a 87       	std	Y+10, r23	; 0x0a
    1394:	69 87       	std	Y+9, r22	; 0x09
    1396:	5c 87       	std	Y+12, r21	; 0x0c
    1398:	4b 87       	std	Y+11, r20	; 0x0b
    139a:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    139c:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    139e:	0f b6       	in	r0, 0x3f	; 63
    13a0:	f8 94       	cli
    13a2:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    13a4:	ef 81       	ldd	r30, Y+7	; 0x07
    13a6:	f8 85       	ldd	r31, Y+8	; 0x08
    13a8:	82 8d       	ldd	r24, Z+26	; 0x1a
    13aa:	88 23       	and	r24, r24
    13ac:	09 f4       	brne	.+2      	; 0x13b0 <xQueueGenericReceive+0x36>
    13ae:	3f c0       	rjmp	.+126    	; 0x142e <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    13b0:	ef 81       	ldd	r30, Y+7	; 0x07
    13b2:	f8 85       	ldd	r31, Y+8	; 0x08
    13b4:	86 81       	ldd	r24, Z+6	; 0x06
    13b6:	97 81       	ldd	r25, Z+7	; 0x07
    13b8:	9a 83       	std	Y+2, r25	; 0x02
    13ba:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    13bc:	8f 81       	ldd	r24, Y+7	; 0x07
    13be:	98 85       	ldd	r25, Y+8	; 0x08
    13c0:	29 85       	ldd	r18, Y+9	; 0x09
    13c2:	3a 85       	ldd	r19, Y+10	; 0x0a
    13c4:	b9 01       	movw	r22, r18
    13c6:	0e 94 a2 0b 	call	0x1744	; 0x1744 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    13ca:	8d 85       	ldd	r24, Y+13	; 0x0d
    13cc:	88 23       	and	r24, r24
    13ce:	b1 f4       	brne	.+44     	; 0x13fc <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    13d0:	ef 81       	ldd	r30, Y+7	; 0x07
    13d2:	f8 85       	ldd	r31, Y+8	; 0x08
    13d4:	82 8d       	ldd	r24, Z+26	; 0x1a
    13d6:	81 50       	subi	r24, 0x01	; 1
    13d8:	ef 81       	ldd	r30, Y+7	; 0x07
    13da:	f8 85       	ldd	r31, Y+8	; 0x08
    13dc:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    13de:	ef 81       	ldd	r30, Y+7	; 0x07
    13e0:	f8 85       	ldd	r31, Y+8	; 0x08
    13e2:	80 85       	ldd	r24, Z+8	; 0x08
    13e4:	88 23       	and	r24, r24
    13e6:	f1 f0       	breq	.+60     	; 0x1424 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    13e8:	8f 81       	ldd	r24, Y+7	; 0x07
    13ea:	98 85       	ldd	r25, Y+8	; 0x08
    13ec:	08 96       	adiw	r24, 0x08	; 8
    13ee:	0e 94 20 11 	call	0x2240	; 0x2240 <xTaskRemoveFromEventList>
    13f2:	81 30       	cpi	r24, 0x01	; 1
    13f4:	b9 f4       	brne	.+46     	; 0x1424 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    13f6:	0e 94 ef 06 	call	0xdde	; 0xdde <vPortYield>
    13fa:	14 c0       	rjmp	.+40     	; 0x1424 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    13fc:	ef 81       	ldd	r30, Y+7	; 0x07
    13fe:	f8 85       	ldd	r31, Y+8	; 0x08
    1400:	89 81       	ldd	r24, Y+1	; 0x01
    1402:	9a 81       	ldd	r25, Y+2	; 0x02
    1404:	97 83       	std	Z+7, r25	; 0x07
    1406:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1408:	ef 81       	ldd	r30, Y+7	; 0x07
    140a:	f8 85       	ldd	r31, Y+8	; 0x08
    140c:	81 89       	ldd	r24, Z+17	; 0x11
    140e:	88 23       	and	r24, r24
    1410:	49 f0       	breq	.+18     	; 0x1424 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1412:	8f 81       	ldd	r24, Y+7	; 0x07
    1414:	98 85       	ldd	r25, Y+8	; 0x08
    1416:	41 96       	adiw	r24, 0x11	; 17
    1418:	0e 94 20 11 	call	0x2240	; 0x2240 <xTaskRemoveFromEventList>
    141c:	88 23       	and	r24, r24
    141e:	11 f0       	breq	.+4      	; 0x1424 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1420:	0e 94 ef 06 	call	0xdde	; 0xdde <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1424:	0f 90       	pop	r0
    1426:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1428:	81 e0       	ldi	r24, 0x01	; 1
    142a:	8e 87       	std	Y+14, r24	; 0x0e
    142c:	5c c0       	rjmp	.+184    	; 0x14e6 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    142e:	8b 85       	ldd	r24, Y+11	; 0x0b
    1430:	9c 85       	ldd	r25, Y+12	; 0x0c
    1432:	00 97       	sbiw	r24, 0x00	; 0
    1434:	21 f4       	brne	.+8      	; 0x143e <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1436:	0f 90       	pop	r0
    1438:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    143a:	1e 86       	std	Y+14, r1	; 0x0e
    143c:	54 c0       	rjmp	.+168    	; 0x14e6 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    143e:	8b 81       	ldd	r24, Y+3	; 0x03
    1440:	88 23       	and	r24, r24
    1442:	31 f4       	brne	.+12     	; 0x1450 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1444:	ce 01       	movw	r24, r28
    1446:	04 96       	adiw	r24, 0x04	; 4
    1448:	0e 94 88 11 	call	0x2310	; 0x2310 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    144c:	81 e0       	ldi	r24, 0x01	; 1
    144e:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    1450:	0f 90       	pop	r0
    1452:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1454:	0e 94 e6 0e 	call	0x1dcc	; 0x1dcc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1458:	0f b6       	in	r0, 0x3f	; 63
    145a:	f8 94       	cli
    145c:	0f 92       	push	r0
    145e:	ef 81       	ldd	r30, Y+7	; 0x07
    1460:	f8 85       	ldd	r31, Y+8	; 0x08
    1462:	85 8d       	ldd	r24, Z+29	; 0x1d
    1464:	8f 3f       	cpi	r24, 0xFF	; 255
    1466:	19 f4       	brne	.+6      	; 0x146e <xQueueGenericReceive+0xf4>
    1468:	ef 81       	ldd	r30, Y+7	; 0x07
    146a:	f8 85       	ldd	r31, Y+8	; 0x08
    146c:	15 8e       	std	Z+29, r1	; 0x1d
    146e:	ef 81       	ldd	r30, Y+7	; 0x07
    1470:	f8 85       	ldd	r31, Y+8	; 0x08
    1472:	86 8d       	ldd	r24, Z+30	; 0x1e
    1474:	8f 3f       	cpi	r24, 0xFF	; 255
    1476:	19 f4       	brne	.+6      	; 0x147e <xQueueGenericReceive+0x104>
    1478:	ef 81       	ldd	r30, Y+7	; 0x07
    147a:	f8 85       	ldd	r31, Y+8	; 0x08
    147c:	16 8e       	std	Z+30, r1	; 0x1e
    147e:	0f 90       	pop	r0
    1480:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1482:	ce 01       	movw	r24, r28
    1484:	04 96       	adiw	r24, 0x04	; 4
    1486:	9e 01       	movw	r18, r28
    1488:	25 5f       	subi	r18, 0xF5	; 245
    148a:	3f 4f       	sbci	r19, 0xFF	; 255
    148c:	b9 01       	movw	r22, r18
    148e:	0e 94 a1 11 	call	0x2342	; 0x2342 <xTaskCheckForTimeOut>
    1492:	88 23       	and	r24, r24
    1494:	09 f5       	brne	.+66     	; 0x14d8 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1496:	8f 81       	ldd	r24, Y+7	; 0x07
    1498:	98 85       	ldd	r25, Y+8	; 0x08
    149a:	0e 94 3e 0c 	call	0x187c	; 0x187c <prvIsQueueEmpty>
    149e:	88 23       	and	r24, r24
    14a0:	a1 f0       	breq	.+40     	; 0x14ca <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    14a2:	8f 81       	ldd	r24, Y+7	; 0x07
    14a4:	98 85       	ldd	r25, Y+8	; 0x08
    14a6:	41 96       	adiw	r24, 0x11	; 17
    14a8:	2b 85       	ldd	r18, Y+11	; 0x0b
    14aa:	3c 85       	ldd	r19, Y+12	; 0x0c
    14ac:	b9 01       	movw	r22, r18
    14ae:	0e 94 ea 10 	call	0x21d4	; 0x21d4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    14b2:	8f 81       	ldd	r24, Y+7	; 0x07
    14b4:	98 85       	ldd	r25, Y+8	; 0x08
    14b6:	0e 94 ea 0b 	call	0x17d4	; 0x17d4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    14ba:	0e 94 f2 0e 	call	0x1de4	; 0x1de4 <xTaskResumeAll>
    14be:	88 23       	and	r24, r24
    14c0:	09 f0       	breq	.+2      	; 0x14c4 <xQueueGenericReceive+0x14a>
    14c2:	6d cf       	rjmp	.-294    	; 0x139e <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    14c4:	0e 94 ef 06 	call	0xdde	; 0xdde <vPortYield>
    14c8:	6a cf       	rjmp	.-300    	; 0x139e <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    14ca:	8f 81       	ldd	r24, Y+7	; 0x07
    14cc:	98 85       	ldd	r25, Y+8	; 0x08
    14ce:	0e 94 ea 0b 	call	0x17d4	; 0x17d4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    14d2:	0e 94 f2 0e 	call	0x1de4	; 0x1de4 <xTaskResumeAll>
    14d6:	63 cf       	rjmp	.-314    	; 0x139e <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    14d8:	8f 81       	ldd	r24, Y+7	; 0x07
    14da:	98 85       	ldd	r25, Y+8	; 0x08
    14dc:	0e 94 ea 0b 	call	0x17d4	; 0x17d4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    14e0:	0e 94 f2 0e 	call	0x1de4	; 0x1de4 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    14e4:	1e 86       	std	Y+14, r1	; 0x0e
    14e6:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    14e8:	2e 96       	adiw	r28, 0x0e	; 14
    14ea:	0f b6       	in	r0, 0x3f	; 63
    14ec:	f8 94       	cli
    14ee:	de bf       	out	0x3e, r29	; 62
    14f0:	0f be       	out	0x3f, r0	; 63
    14f2:	cd bf       	out	0x3d, r28	; 61
    14f4:	cf 91       	pop	r28
    14f6:	df 91       	pop	r29
    14f8:	08 95       	ret

000014fa <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    14fa:	df 93       	push	r29
    14fc:	cf 93       	push	r28
    14fe:	cd b7       	in	r28, 0x3d	; 61
    1500:	de b7       	in	r29, 0x3e	; 62
    1502:	28 97       	sbiw	r28, 0x08	; 8
    1504:	0f b6       	in	r0, 0x3f	; 63
    1506:	f8 94       	cli
    1508:	de bf       	out	0x3e, r29	; 62
    150a:	0f be       	out	0x3f, r0	; 63
    150c:	cd bf       	out	0x3d, r28	; 61
    150e:	9c 83       	std	Y+4, r25	; 0x04
    1510:	8b 83       	std	Y+3, r24	; 0x03
    1512:	7e 83       	std	Y+6, r23	; 0x06
    1514:	6d 83       	std	Y+5, r22	; 0x05
    1516:	58 87       	std	Y+8, r21	; 0x08
    1518:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    151a:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    151c:	eb 81       	ldd	r30, Y+3	; 0x03
    151e:	fc 81       	ldd	r31, Y+4	; 0x04
    1520:	82 8d       	ldd	r24, Z+26	; 0x1a
    1522:	88 23       	and	r24, r24
    1524:	71 f1       	breq	.+92     	; 0x1582 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1526:	8b 81       	ldd	r24, Y+3	; 0x03
    1528:	9c 81       	ldd	r25, Y+4	; 0x04
    152a:	2d 81       	ldd	r18, Y+5	; 0x05
    152c:	3e 81       	ldd	r19, Y+6	; 0x06
    152e:	b9 01       	movw	r22, r18
    1530:	0e 94 a2 0b 	call	0x1744	; 0x1744 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1534:	eb 81       	ldd	r30, Y+3	; 0x03
    1536:	fc 81       	ldd	r31, Y+4	; 0x04
    1538:	82 8d       	ldd	r24, Z+26	; 0x1a
    153a:	81 50       	subi	r24, 0x01	; 1
    153c:	eb 81       	ldd	r30, Y+3	; 0x03
    153e:	fc 81       	ldd	r31, Y+4	; 0x04
    1540:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1542:	eb 81       	ldd	r30, Y+3	; 0x03
    1544:	fc 81       	ldd	r31, Y+4	; 0x04
    1546:	85 8d       	ldd	r24, Z+29	; 0x1d
    1548:	8f 3f       	cpi	r24, 0xFF	; 255
    154a:	89 f4       	brne	.+34     	; 0x156e <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    154c:	eb 81       	ldd	r30, Y+3	; 0x03
    154e:	fc 81       	ldd	r31, Y+4	; 0x04
    1550:	80 85       	ldd	r24, Z+8	; 0x08
    1552:	88 23       	and	r24, r24
    1554:	99 f0       	breq	.+38     	; 0x157c <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1556:	8b 81       	ldd	r24, Y+3	; 0x03
    1558:	9c 81       	ldd	r25, Y+4	; 0x04
    155a:	08 96       	adiw	r24, 0x08	; 8
    155c:	0e 94 20 11 	call	0x2240	; 0x2240 <xTaskRemoveFromEventList>
    1560:	88 23       	and	r24, r24
    1562:	61 f0       	breq	.+24     	; 0x157c <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    1564:	ef 81       	ldd	r30, Y+7	; 0x07
    1566:	f8 85       	ldd	r31, Y+8	; 0x08
    1568:	81 e0       	ldi	r24, 0x01	; 1
    156a:	80 83       	st	Z, r24
    156c:	07 c0       	rjmp	.+14     	; 0x157c <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    156e:	eb 81       	ldd	r30, Y+3	; 0x03
    1570:	fc 81       	ldd	r31, Y+4	; 0x04
    1572:	85 8d       	ldd	r24, Z+29	; 0x1d
    1574:	8f 5f       	subi	r24, 0xFF	; 255
    1576:	eb 81       	ldd	r30, Y+3	; 0x03
    1578:	fc 81       	ldd	r31, Y+4	; 0x04
    157a:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    157c:	81 e0       	ldi	r24, 0x01	; 1
    157e:	8a 83       	std	Y+2, r24	; 0x02
    1580:	01 c0       	rjmp	.+2      	; 0x1584 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    1582:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1584:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1586:	28 96       	adiw	r28, 0x08	; 8
    1588:	0f b6       	in	r0, 0x3f	; 63
    158a:	f8 94       	cli
    158c:	de bf       	out	0x3e, r29	; 62
    158e:	0f be       	out	0x3f, r0	; 63
    1590:	cd bf       	out	0x3d, r28	; 61
    1592:	cf 91       	pop	r28
    1594:	df 91       	pop	r29
    1596:	08 95       	ret

00001598 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    1598:	df 93       	push	r29
    159a:	cf 93       	push	r28
    159c:	00 d0       	rcall	.+0      	; 0x159e <uxQueueMessagesWaiting+0x6>
    159e:	0f 92       	push	r0
    15a0:	cd b7       	in	r28, 0x3d	; 61
    15a2:	de b7       	in	r29, 0x3e	; 62
    15a4:	9b 83       	std	Y+3, r25	; 0x03
    15a6:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    15a8:	0f b6       	in	r0, 0x3f	; 63
    15aa:	f8 94       	cli
    15ac:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    15ae:	ea 81       	ldd	r30, Y+2	; 0x02
    15b0:	fb 81       	ldd	r31, Y+3	; 0x03
    15b2:	82 8d       	ldd	r24, Z+26	; 0x1a
    15b4:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    15b6:	0f 90       	pop	r0
    15b8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    15ba:	89 81       	ldd	r24, Y+1	; 0x01
}
    15bc:	0f 90       	pop	r0
    15be:	0f 90       	pop	r0
    15c0:	0f 90       	pop	r0
    15c2:	cf 91       	pop	r28
    15c4:	df 91       	pop	r29
    15c6:	08 95       	ret

000015c8 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    15c8:	df 93       	push	r29
    15ca:	cf 93       	push	r28
    15cc:	00 d0       	rcall	.+0      	; 0x15ce <uxQueueMessagesWaitingFromISR+0x6>
    15ce:	0f 92       	push	r0
    15d0:	cd b7       	in	r28, 0x3d	; 61
    15d2:	de b7       	in	r29, 0x3e	; 62
    15d4:	9b 83       	std	Y+3, r25	; 0x03
    15d6:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    15d8:	ea 81       	ldd	r30, Y+2	; 0x02
    15da:	fb 81       	ldd	r31, Y+3	; 0x03
    15dc:	82 8d       	ldd	r24, Z+26	; 0x1a
    15de:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    15e0:	89 81       	ldd	r24, Y+1	; 0x01
}
    15e2:	0f 90       	pop	r0
    15e4:	0f 90       	pop	r0
    15e6:	0f 90       	pop	r0
    15e8:	cf 91       	pop	r28
    15ea:	df 91       	pop	r29
    15ec:	08 95       	ret

000015ee <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    15ee:	df 93       	push	r29
    15f0:	cf 93       	push	r28
    15f2:	00 d0       	rcall	.+0      	; 0x15f4 <vQueueDelete+0x6>
    15f4:	cd b7       	in	r28, 0x3d	; 61
    15f6:	de b7       	in	r29, 0x3e	; 62
    15f8:	9a 83       	std	Y+2, r25	; 0x02
    15fa:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    15fc:	e9 81       	ldd	r30, Y+1	; 0x01
    15fe:	fa 81       	ldd	r31, Y+2	; 0x02
    1600:	80 81       	ld	r24, Z
    1602:	91 81       	ldd	r25, Z+1	; 0x01
    1604:	0e 94 cf 03 	call	0x79e	; 0x79e <vPortFree>
	vPortFree( pxQueue );
    1608:	89 81       	ldd	r24, Y+1	; 0x01
    160a:	9a 81       	ldd	r25, Y+2	; 0x02
    160c:	0e 94 cf 03 	call	0x79e	; 0x79e <vPortFree>
}
    1610:	0f 90       	pop	r0
    1612:	0f 90       	pop	r0
    1614:	cf 91       	pop	r28
    1616:	df 91       	pop	r29
    1618:	08 95       	ret

0000161a <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    161a:	df 93       	push	r29
    161c:	cf 93       	push	r28
    161e:	00 d0       	rcall	.+0      	; 0x1620 <prvCopyDataToQueue+0x6>
    1620:	00 d0       	rcall	.+0      	; 0x1622 <prvCopyDataToQueue+0x8>
    1622:	0f 92       	push	r0
    1624:	cd b7       	in	r28, 0x3d	; 61
    1626:	de b7       	in	r29, 0x3e	; 62
    1628:	9a 83       	std	Y+2, r25	; 0x02
    162a:	89 83       	std	Y+1, r24	; 0x01
    162c:	7c 83       	std	Y+4, r23	; 0x04
    162e:	6b 83       	std	Y+3, r22	; 0x03
    1630:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1632:	e9 81       	ldd	r30, Y+1	; 0x01
    1634:	fa 81       	ldd	r31, Y+2	; 0x02
    1636:	84 8d       	ldd	r24, Z+28	; 0x1c
    1638:	88 23       	and	r24, r24
    163a:	09 f4       	brne	.+2      	; 0x163e <prvCopyDataToQueue+0x24>
    163c:	74 c0       	rjmp	.+232    	; 0x1726 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    163e:	8d 81       	ldd	r24, Y+5	; 0x05
    1640:	88 23       	and	r24, r24
    1642:	99 f5       	brne	.+102    	; 0x16aa <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1644:	e9 81       	ldd	r30, Y+1	; 0x01
    1646:	fa 81       	ldd	r31, Y+2	; 0x02
    1648:	64 81       	ldd	r22, Z+4	; 0x04
    164a:	75 81       	ldd	r23, Z+5	; 0x05
    164c:	e9 81       	ldd	r30, Y+1	; 0x01
    164e:	fa 81       	ldd	r31, Y+2	; 0x02
    1650:	84 8d       	ldd	r24, Z+28	; 0x1c
    1652:	48 2f       	mov	r20, r24
    1654:	50 e0       	ldi	r21, 0x00	; 0
    1656:	2b 81       	ldd	r18, Y+3	; 0x03
    1658:	3c 81       	ldd	r19, Y+4	; 0x04
    165a:	cb 01       	movw	r24, r22
    165c:	b9 01       	movw	r22, r18
    165e:	0e 94 95 13 	call	0x272a	; 0x272a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1662:	e9 81       	ldd	r30, Y+1	; 0x01
    1664:	fa 81       	ldd	r31, Y+2	; 0x02
    1666:	24 81       	ldd	r18, Z+4	; 0x04
    1668:	35 81       	ldd	r19, Z+5	; 0x05
    166a:	e9 81       	ldd	r30, Y+1	; 0x01
    166c:	fa 81       	ldd	r31, Y+2	; 0x02
    166e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1670:	88 2f       	mov	r24, r24
    1672:	90 e0       	ldi	r25, 0x00	; 0
    1674:	82 0f       	add	r24, r18
    1676:	93 1f       	adc	r25, r19
    1678:	e9 81       	ldd	r30, Y+1	; 0x01
    167a:	fa 81       	ldd	r31, Y+2	; 0x02
    167c:	95 83       	std	Z+5, r25	; 0x05
    167e:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1680:	e9 81       	ldd	r30, Y+1	; 0x01
    1682:	fa 81       	ldd	r31, Y+2	; 0x02
    1684:	24 81       	ldd	r18, Z+4	; 0x04
    1686:	35 81       	ldd	r19, Z+5	; 0x05
    1688:	e9 81       	ldd	r30, Y+1	; 0x01
    168a:	fa 81       	ldd	r31, Y+2	; 0x02
    168c:	82 81       	ldd	r24, Z+2	; 0x02
    168e:	93 81       	ldd	r25, Z+3	; 0x03
    1690:	28 17       	cp	r18, r24
    1692:	39 07       	cpc	r19, r25
    1694:	08 f4       	brcc	.+2      	; 0x1698 <prvCopyDataToQueue+0x7e>
    1696:	47 c0       	rjmp	.+142    	; 0x1726 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1698:	e9 81       	ldd	r30, Y+1	; 0x01
    169a:	fa 81       	ldd	r31, Y+2	; 0x02
    169c:	80 81       	ld	r24, Z
    169e:	91 81       	ldd	r25, Z+1	; 0x01
    16a0:	e9 81       	ldd	r30, Y+1	; 0x01
    16a2:	fa 81       	ldd	r31, Y+2	; 0x02
    16a4:	95 83       	std	Z+5, r25	; 0x05
    16a6:	84 83       	std	Z+4, r24	; 0x04
    16a8:	3e c0       	rjmp	.+124    	; 0x1726 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    16aa:	e9 81       	ldd	r30, Y+1	; 0x01
    16ac:	fa 81       	ldd	r31, Y+2	; 0x02
    16ae:	66 81       	ldd	r22, Z+6	; 0x06
    16b0:	77 81       	ldd	r23, Z+7	; 0x07
    16b2:	e9 81       	ldd	r30, Y+1	; 0x01
    16b4:	fa 81       	ldd	r31, Y+2	; 0x02
    16b6:	84 8d       	ldd	r24, Z+28	; 0x1c
    16b8:	48 2f       	mov	r20, r24
    16ba:	50 e0       	ldi	r21, 0x00	; 0
    16bc:	2b 81       	ldd	r18, Y+3	; 0x03
    16be:	3c 81       	ldd	r19, Y+4	; 0x04
    16c0:	cb 01       	movw	r24, r22
    16c2:	b9 01       	movw	r22, r18
    16c4:	0e 94 95 13 	call	0x272a	; 0x272a <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    16c8:	e9 81       	ldd	r30, Y+1	; 0x01
    16ca:	fa 81       	ldd	r31, Y+2	; 0x02
    16cc:	26 81       	ldd	r18, Z+6	; 0x06
    16ce:	37 81       	ldd	r19, Z+7	; 0x07
    16d0:	e9 81       	ldd	r30, Y+1	; 0x01
    16d2:	fa 81       	ldd	r31, Y+2	; 0x02
    16d4:	84 8d       	ldd	r24, Z+28	; 0x1c
    16d6:	88 2f       	mov	r24, r24
    16d8:	90 e0       	ldi	r25, 0x00	; 0
    16da:	90 95       	com	r25
    16dc:	81 95       	neg	r24
    16de:	9f 4f       	sbci	r25, 0xFF	; 255
    16e0:	82 0f       	add	r24, r18
    16e2:	93 1f       	adc	r25, r19
    16e4:	e9 81       	ldd	r30, Y+1	; 0x01
    16e6:	fa 81       	ldd	r31, Y+2	; 0x02
    16e8:	97 83       	std	Z+7, r25	; 0x07
    16ea:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    16ec:	e9 81       	ldd	r30, Y+1	; 0x01
    16ee:	fa 81       	ldd	r31, Y+2	; 0x02
    16f0:	26 81       	ldd	r18, Z+6	; 0x06
    16f2:	37 81       	ldd	r19, Z+7	; 0x07
    16f4:	e9 81       	ldd	r30, Y+1	; 0x01
    16f6:	fa 81       	ldd	r31, Y+2	; 0x02
    16f8:	80 81       	ld	r24, Z
    16fa:	91 81       	ldd	r25, Z+1	; 0x01
    16fc:	28 17       	cp	r18, r24
    16fe:	39 07       	cpc	r19, r25
    1700:	90 f4       	brcc	.+36     	; 0x1726 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1702:	e9 81       	ldd	r30, Y+1	; 0x01
    1704:	fa 81       	ldd	r31, Y+2	; 0x02
    1706:	22 81       	ldd	r18, Z+2	; 0x02
    1708:	33 81       	ldd	r19, Z+3	; 0x03
    170a:	e9 81       	ldd	r30, Y+1	; 0x01
    170c:	fa 81       	ldd	r31, Y+2	; 0x02
    170e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1710:	88 2f       	mov	r24, r24
    1712:	90 e0       	ldi	r25, 0x00	; 0
    1714:	90 95       	com	r25
    1716:	81 95       	neg	r24
    1718:	9f 4f       	sbci	r25, 0xFF	; 255
    171a:	82 0f       	add	r24, r18
    171c:	93 1f       	adc	r25, r19
    171e:	e9 81       	ldd	r30, Y+1	; 0x01
    1720:	fa 81       	ldd	r31, Y+2	; 0x02
    1722:	97 83       	std	Z+7, r25	; 0x07
    1724:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1726:	e9 81       	ldd	r30, Y+1	; 0x01
    1728:	fa 81       	ldd	r31, Y+2	; 0x02
    172a:	82 8d       	ldd	r24, Z+26	; 0x1a
    172c:	8f 5f       	subi	r24, 0xFF	; 255
    172e:	e9 81       	ldd	r30, Y+1	; 0x01
    1730:	fa 81       	ldd	r31, Y+2	; 0x02
    1732:	82 8f       	std	Z+26, r24	; 0x1a
}
    1734:	0f 90       	pop	r0
    1736:	0f 90       	pop	r0
    1738:	0f 90       	pop	r0
    173a:	0f 90       	pop	r0
    173c:	0f 90       	pop	r0
    173e:	cf 91       	pop	r28
    1740:	df 91       	pop	r29
    1742:	08 95       	ret

00001744 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    1744:	df 93       	push	r29
    1746:	cf 93       	push	r28
    1748:	00 d0       	rcall	.+0      	; 0x174a <prvCopyDataFromQueue+0x6>
    174a:	00 d0       	rcall	.+0      	; 0x174c <prvCopyDataFromQueue+0x8>
    174c:	cd b7       	in	r28, 0x3d	; 61
    174e:	de b7       	in	r29, 0x3e	; 62
    1750:	9a 83       	std	Y+2, r25	; 0x02
    1752:	89 83       	std	Y+1, r24	; 0x01
    1754:	7c 83       	std	Y+4, r23	; 0x04
    1756:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1758:	e9 81       	ldd	r30, Y+1	; 0x01
    175a:	fa 81       	ldd	r31, Y+2	; 0x02
    175c:	80 81       	ld	r24, Z
    175e:	91 81       	ldd	r25, Z+1	; 0x01
    1760:	00 97       	sbiw	r24, 0x00	; 0
    1762:	89 f1       	breq	.+98     	; 0x17c6 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1764:	e9 81       	ldd	r30, Y+1	; 0x01
    1766:	fa 81       	ldd	r31, Y+2	; 0x02
    1768:	26 81       	ldd	r18, Z+6	; 0x06
    176a:	37 81       	ldd	r19, Z+7	; 0x07
    176c:	e9 81       	ldd	r30, Y+1	; 0x01
    176e:	fa 81       	ldd	r31, Y+2	; 0x02
    1770:	84 8d       	ldd	r24, Z+28	; 0x1c
    1772:	88 2f       	mov	r24, r24
    1774:	90 e0       	ldi	r25, 0x00	; 0
    1776:	82 0f       	add	r24, r18
    1778:	93 1f       	adc	r25, r19
    177a:	e9 81       	ldd	r30, Y+1	; 0x01
    177c:	fa 81       	ldd	r31, Y+2	; 0x02
    177e:	97 83       	std	Z+7, r25	; 0x07
    1780:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1782:	e9 81       	ldd	r30, Y+1	; 0x01
    1784:	fa 81       	ldd	r31, Y+2	; 0x02
    1786:	26 81       	ldd	r18, Z+6	; 0x06
    1788:	37 81       	ldd	r19, Z+7	; 0x07
    178a:	e9 81       	ldd	r30, Y+1	; 0x01
    178c:	fa 81       	ldd	r31, Y+2	; 0x02
    178e:	82 81       	ldd	r24, Z+2	; 0x02
    1790:	93 81       	ldd	r25, Z+3	; 0x03
    1792:	28 17       	cp	r18, r24
    1794:	39 07       	cpc	r19, r25
    1796:	40 f0       	brcs	.+16     	; 0x17a8 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1798:	e9 81       	ldd	r30, Y+1	; 0x01
    179a:	fa 81       	ldd	r31, Y+2	; 0x02
    179c:	80 81       	ld	r24, Z
    179e:	91 81       	ldd	r25, Z+1	; 0x01
    17a0:	e9 81       	ldd	r30, Y+1	; 0x01
    17a2:	fa 81       	ldd	r31, Y+2	; 0x02
    17a4:	97 83       	std	Z+7, r25	; 0x07
    17a6:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    17a8:	e9 81       	ldd	r30, Y+1	; 0x01
    17aa:	fa 81       	ldd	r31, Y+2	; 0x02
    17ac:	46 81       	ldd	r20, Z+6	; 0x06
    17ae:	57 81       	ldd	r21, Z+7	; 0x07
    17b0:	e9 81       	ldd	r30, Y+1	; 0x01
    17b2:	fa 81       	ldd	r31, Y+2	; 0x02
    17b4:	84 8d       	ldd	r24, Z+28	; 0x1c
    17b6:	28 2f       	mov	r18, r24
    17b8:	30 e0       	ldi	r19, 0x00	; 0
    17ba:	8b 81       	ldd	r24, Y+3	; 0x03
    17bc:	9c 81       	ldd	r25, Y+4	; 0x04
    17be:	ba 01       	movw	r22, r20
    17c0:	a9 01       	movw	r20, r18
    17c2:	0e 94 95 13 	call	0x272a	; 0x272a <memcpy>
	}
}
    17c6:	0f 90       	pop	r0
    17c8:	0f 90       	pop	r0
    17ca:	0f 90       	pop	r0
    17cc:	0f 90       	pop	r0
    17ce:	cf 91       	pop	r28
    17d0:	df 91       	pop	r29
    17d2:	08 95       	ret

000017d4 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    17d4:	df 93       	push	r29
    17d6:	cf 93       	push	r28
    17d8:	00 d0       	rcall	.+0      	; 0x17da <prvUnlockQueue+0x6>
    17da:	cd b7       	in	r28, 0x3d	; 61
    17dc:	de b7       	in	r29, 0x3e	; 62
    17de:	9a 83       	std	Y+2, r25	; 0x02
    17e0:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    17e2:	0f b6       	in	r0, 0x3f	; 63
    17e4:	f8 94       	cli
    17e6:	0f 92       	push	r0
    17e8:	15 c0       	rjmp	.+42     	; 0x1814 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17ea:	e9 81       	ldd	r30, Y+1	; 0x01
    17ec:	fa 81       	ldd	r31, Y+2	; 0x02
    17ee:	81 89       	ldd	r24, Z+17	; 0x11
    17f0:	88 23       	and	r24, r24
    17f2:	a9 f0       	breq	.+42     	; 0x181e <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    17f4:	89 81       	ldd	r24, Y+1	; 0x01
    17f6:	9a 81       	ldd	r25, Y+2	; 0x02
    17f8:	41 96       	adiw	r24, 0x11	; 17
    17fa:	0e 94 20 11 	call	0x2240	; 0x2240 <xTaskRemoveFromEventList>
    17fe:	88 23       	and	r24, r24
    1800:	11 f0       	breq	.+4      	; 0x1806 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    1802:	0e 94 fe 11 	call	0x23fc	; 0x23fc <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    1806:	e9 81       	ldd	r30, Y+1	; 0x01
    1808:	fa 81       	ldd	r31, Y+2	; 0x02
    180a:	86 8d       	ldd	r24, Z+30	; 0x1e
    180c:	81 50       	subi	r24, 0x01	; 1
    180e:	e9 81       	ldd	r30, Y+1	; 0x01
    1810:	fa 81       	ldd	r31, Y+2	; 0x02
    1812:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1814:	e9 81       	ldd	r30, Y+1	; 0x01
    1816:	fa 81       	ldd	r31, Y+2	; 0x02
    1818:	86 8d       	ldd	r24, Z+30	; 0x1e
    181a:	18 16       	cp	r1, r24
    181c:	34 f3       	brlt	.-52     	; 0x17ea <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    181e:	e9 81       	ldd	r30, Y+1	; 0x01
    1820:	fa 81       	ldd	r31, Y+2	; 0x02
    1822:	8f ef       	ldi	r24, 0xFF	; 255
    1824:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1826:	0f 90       	pop	r0
    1828:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    182a:	0f b6       	in	r0, 0x3f	; 63
    182c:	f8 94       	cli
    182e:	0f 92       	push	r0
    1830:	15 c0       	rjmp	.+42     	; 0x185c <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1832:	e9 81       	ldd	r30, Y+1	; 0x01
    1834:	fa 81       	ldd	r31, Y+2	; 0x02
    1836:	80 85       	ldd	r24, Z+8	; 0x08
    1838:	88 23       	and	r24, r24
    183a:	a9 f0       	breq	.+42     	; 0x1866 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    183c:	89 81       	ldd	r24, Y+1	; 0x01
    183e:	9a 81       	ldd	r25, Y+2	; 0x02
    1840:	08 96       	adiw	r24, 0x08	; 8
    1842:	0e 94 20 11 	call	0x2240	; 0x2240 <xTaskRemoveFromEventList>
    1846:	88 23       	and	r24, r24
    1848:	11 f0       	breq	.+4      	; 0x184e <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    184a:	0e 94 fe 11 	call	0x23fc	; 0x23fc <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    184e:	e9 81       	ldd	r30, Y+1	; 0x01
    1850:	fa 81       	ldd	r31, Y+2	; 0x02
    1852:	85 8d       	ldd	r24, Z+29	; 0x1d
    1854:	81 50       	subi	r24, 0x01	; 1
    1856:	e9 81       	ldd	r30, Y+1	; 0x01
    1858:	fa 81       	ldd	r31, Y+2	; 0x02
    185a:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    185c:	e9 81       	ldd	r30, Y+1	; 0x01
    185e:	fa 81       	ldd	r31, Y+2	; 0x02
    1860:	85 8d       	ldd	r24, Z+29	; 0x1d
    1862:	18 16       	cp	r1, r24
    1864:	34 f3       	brlt	.-52     	; 0x1832 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1866:	e9 81       	ldd	r30, Y+1	; 0x01
    1868:	fa 81       	ldd	r31, Y+2	; 0x02
    186a:	8f ef       	ldi	r24, 0xFF	; 255
    186c:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    186e:	0f 90       	pop	r0
    1870:	0f be       	out	0x3f, r0	; 63
}
    1872:	0f 90       	pop	r0
    1874:	0f 90       	pop	r0
    1876:	cf 91       	pop	r28
    1878:	df 91       	pop	r29
    187a:	08 95       	ret

0000187c <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    187c:	df 93       	push	r29
    187e:	cf 93       	push	r28
    1880:	00 d0       	rcall	.+0      	; 0x1882 <prvIsQueueEmpty+0x6>
    1882:	0f 92       	push	r0
    1884:	cd b7       	in	r28, 0x3d	; 61
    1886:	de b7       	in	r29, 0x3e	; 62
    1888:	9b 83       	std	Y+3, r25	; 0x03
    188a:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    188c:	0f b6       	in	r0, 0x3f	; 63
    188e:	f8 94       	cli
    1890:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1892:	ea 81       	ldd	r30, Y+2	; 0x02
    1894:	fb 81       	ldd	r31, Y+3	; 0x03
    1896:	82 8d       	ldd	r24, Z+26	; 0x1a
    1898:	19 82       	std	Y+1, r1	; 0x01
    189a:	88 23       	and	r24, r24
    189c:	11 f4       	brne	.+4      	; 0x18a2 <prvIsQueueEmpty+0x26>
    189e:	81 e0       	ldi	r24, 0x01	; 1
    18a0:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    18a2:	0f 90       	pop	r0
    18a4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    18a6:	89 81       	ldd	r24, Y+1	; 0x01
}
    18a8:	0f 90       	pop	r0
    18aa:	0f 90       	pop	r0
    18ac:	0f 90       	pop	r0
    18ae:	cf 91       	pop	r28
    18b0:	df 91       	pop	r29
    18b2:	08 95       	ret

000018b4 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    18b4:	df 93       	push	r29
    18b6:	cf 93       	push	r28
    18b8:	00 d0       	rcall	.+0      	; 0x18ba <xQueueIsQueueEmptyFromISR+0x6>
    18ba:	0f 92       	push	r0
    18bc:	cd b7       	in	r28, 0x3d	; 61
    18be:	de b7       	in	r29, 0x3e	; 62
    18c0:	9b 83       	std	Y+3, r25	; 0x03
    18c2:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    18c4:	ea 81       	ldd	r30, Y+2	; 0x02
    18c6:	fb 81       	ldd	r31, Y+3	; 0x03
    18c8:	82 8d       	ldd	r24, Z+26	; 0x1a
    18ca:	19 82       	std	Y+1, r1	; 0x01
    18cc:	88 23       	and	r24, r24
    18ce:	11 f4       	brne	.+4      	; 0x18d4 <xQueueIsQueueEmptyFromISR+0x20>
    18d0:	81 e0       	ldi	r24, 0x01	; 1
    18d2:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    18d4:	89 81       	ldd	r24, Y+1	; 0x01
}
    18d6:	0f 90       	pop	r0
    18d8:	0f 90       	pop	r0
    18da:	0f 90       	pop	r0
    18dc:	cf 91       	pop	r28
    18de:	df 91       	pop	r29
    18e0:	08 95       	ret

000018e2 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    18e2:	df 93       	push	r29
    18e4:	cf 93       	push	r28
    18e6:	00 d0       	rcall	.+0      	; 0x18e8 <prvIsQueueFull+0x6>
    18e8:	0f 92       	push	r0
    18ea:	cd b7       	in	r28, 0x3d	; 61
    18ec:	de b7       	in	r29, 0x3e	; 62
    18ee:	9b 83       	std	Y+3, r25	; 0x03
    18f0:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    18f2:	0f b6       	in	r0, 0x3f	; 63
    18f4:	f8 94       	cli
    18f6:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    18f8:	ea 81       	ldd	r30, Y+2	; 0x02
    18fa:	fb 81       	ldd	r31, Y+3	; 0x03
    18fc:	92 8d       	ldd	r25, Z+26	; 0x1a
    18fe:	ea 81       	ldd	r30, Y+2	; 0x02
    1900:	fb 81       	ldd	r31, Y+3	; 0x03
    1902:	83 8d       	ldd	r24, Z+27	; 0x1b
    1904:	19 82       	std	Y+1, r1	; 0x01
    1906:	98 17       	cp	r25, r24
    1908:	11 f4       	brne	.+4      	; 0x190e <prvIsQueueFull+0x2c>
    190a:	81 e0       	ldi	r24, 0x01	; 1
    190c:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    190e:	0f 90       	pop	r0
    1910:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1912:	89 81       	ldd	r24, Y+1	; 0x01
}
    1914:	0f 90       	pop	r0
    1916:	0f 90       	pop	r0
    1918:	0f 90       	pop	r0
    191a:	cf 91       	pop	r28
    191c:	df 91       	pop	r29
    191e:	08 95       	ret

00001920 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    1920:	df 93       	push	r29
    1922:	cf 93       	push	r28
    1924:	00 d0       	rcall	.+0      	; 0x1926 <xQueueIsQueueFullFromISR+0x6>
    1926:	0f 92       	push	r0
    1928:	cd b7       	in	r28, 0x3d	; 61
    192a:	de b7       	in	r29, 0x3e	; 62
    192c:	9b 83       	std	Y+3, r25	; 0x03
    192e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1930:	ea 81       	ldd	r30, Y+2	; 0x02
    1932:	fb 81       	ldd	r31, Y+3	; 0x03
    1934:	92 8d       	ldd	r25, Z+26	; 0x1a
    1936:	ea 81       	ldd	r30, Y+2	; 0x02
    1938:	fb 81       	ldd	r31, Y+3	; 0x03
    193a:	83 8d       	ldd	r24, Z+27	; 0x1b
    193c:	19 82       	std	Y+1, r1	; 0x01
    193e:	98 17       	cp	r25, r24
    1940:	11 f4       	brne	.+4      	; 0x1946 <xQueueIsQueueFullFromISR+0x26>
    1942:	81 e0       	ldi	r24, 0x01	; 1
    1944:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    1946:	89 81       	ldd	r24, Y+1	; 0x01
}
    1948:	0f 90       	pop	r0
    194a:	0f 90       	pop	r0
    194c:	0f 90       	pop	r0
    194e:	cf 91       	pop	r28
    1950:	df 91       	pop	r29
    1952:	08 95       	ret

00001954 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1954:	af 92       	push	r10
    1956:	bf 92       	push	r11
    1958:	cf 92       	push	r12
    195a:	df 92       	push	r13
    195c:	ef 92       	push	r14
    195e:	ff 92       	push	r15
    1960:	0f 93       	push	r16
    1962:	1f 93       	push	r17
    1964:	df 93       	push	r29
    1966:	cf 93       	push	r28
    1968:	cd b7       	in	r28, 0x3d	; 61
    196a:	de b7       	in	r29, 0x3e	; 62
    196c:	64 97       	sbiw	r28, 0x14	; 20
    196e:	0f b6       	in	r0, 0x3f	; 63
    1970:	f8 94       	cli
    1972:	de bf       	out	0x3e, r29	; 62
    1974:	0f be       	out	0x3f, r0	; 63
    1976:	cd bf       	out	0x3d, r28	; 61
    1978:	9f 83       	std	Y+7, r25	; 0x07
    197a:	8e 83       	std	Y+6, r24	; 0x06
    197c:	79 87       	std	Y+9, r23	; 0x09
    197e:	68 87       	std	Y+8, r22	; 0x08
    1980:	5b 87       	std	Y+11, r21	; 0x0b
    1982:	4a 87       	std	Y+10, r20	; 0x0a
    1984:	3d 87       	std	Y+13, r19	; 0x0d
    1986:	2c 87       	std	Y+12, r18	; 0x0c
    1988:	0e 87       	std	Y+14, r16	; 0x0e
    198a:	f8 8a       	std	Y+16, r15	; 0x10
    198c:	ef 86       	std	Y+15, r14	; 0x0f
    198e:	da 8a       	std	Y+18, r13	; 0x12
    1990:	c9 8a       	std	Y+17, r12	; 0x11
    1992:	bc 8a       	std	Y+20, r11	; 0x14
    1994:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    1996:	8a 85       	ldd	r24, Y+10	; 0x0a
    1998:	9b 85       	ldd	r25, Y+11	; 0x0b
    199a:	29 89       	ldd	r18, Y+17	; 0x11
    199c:	3a 89       	ldd	r19, Y+18	; 0x12
    199e:	b9 01       	movw	r22, r18
    19a0:	0e 94 2f 13 	call	0x265e	; 0x265e <prvAllocateTCBAndStack>
    19a4:	9c 83       	std	Y+4, r25	; 0x04
    19a6:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    19a8:	8b 81       	ldd	r24, Y+3	; 0x03
    19aa:	9c 81       	ldd	r25, Y+4	; 0x04
    19ac:	00 97       	sbiw	r24, 0x00	; 0
    19ae:	09 f4       	brne	.+2      	; 0x19b2 <xTaskGenericCreate+0x5e>
    19b0:	99 c0       	rjmp	.+306    	; 0x1ae4 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    19b2:	eb 81       	ldd	r30, Y+3	; 0x03
    19b4:	fc 81       	ldd	r31, Y+4	; 0x04
    19b6:	27 89       	ldd	r18, Z+23	; 0x17
    19b8:	30 8d       	ldd	r19, Z+24	; 0x18
    19ba:	8a 85       	ldd	r24, Y+10	; 0x0a
    19bc:	9b 85       	ldd	r25, Y+11	; 0x0b
    19be:	01 97       	sbiw	r24, 0x01	; 1
    19c0:	82 0f       	add	r24, r18
    19c2:	93 1f       	adc	r25, r19
    19c4:	9a 83       	std	Y+2, r25	; 0x02
    19c6:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    19c8:	8b 81       	ldd	r24, Y+3	; 0x03
    19ca:	9c 81       	ldd	r25, Y+4	; 0x04
    19cc:	28 85       	ldd	r18, Y+8	; 0x08
    19ce:	39 85       	ldd	r19, Y+9	; 0x09
    19d0:	eb 89       	ldd	r30, Y+19	; 0x13
    19d2:	fc 89       	ldd	r31, Y+20	; 0x14
    19d4:	aa 85       	ldd	r26, Y+10	; 0x0a
    19d6:	bb 85       	ldd	r27, Y+11	; 0x0b
    19d8:	b9 01       	movw	r22, r18
    19da:	4e 85       	ldd	r20, Y+14	; 0x0e
    19dc:	9f 01       	movw	r18, r30
    19de:	8d 01       	movw	r16, r26
    19e0:	0e 94 14 12 	call	0x2428	; 0x2428 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    19e4:	89 81       	ldd	r24, Y+1	; 0x01
    19e6:	9a 81       	ldd	r25, Y+2	; 0x02
    19e8:	2e 81       	ldd	r18, Y+6	; 0x06
    19ea:	3f 81       	ldd	r19, Y+7	; 0x07
    19ec:	4c 85       	ldd	r20, Y+12	; 0x0c
    19ee:	5d 85       	ldd	r21, Y+13	; 0x0d
    19f0:	b9 01       	movw	r22, r18
    19f2:	0e 94 30 05 	call	0xa60	; 0xa60 <pxPortInitialiseStack>
    19f6:	eb 81       	ldd	r30, Y+3	; 0x03
    19f8:	fc 81       	ldd	r31, Y+4	; 0x04
    19fa:	91 83       	std	Z+1, r25	; 0x01
    19fc:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    19fe:	8f 85       	ldd	r24, Y+15	; 0x0f
    1a00:	98 89       	ldd	r25, Y+16	; 0x10
    1a02:	00 97       	sbiw	r24, 0x00	; 0
    1a04:	31 f0       	breq	.+12     	; 0x1a12 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1a06:	ef 85       	ldd	r30, Y+15	; 0x0f
    1a08:	f8 89       	ldd	r31, Y+16	; 0x10
    1a0a:	8b 81       	ldd	r24, Y+3	; 0x03
    1a0c:	9c 81       	ldd	r25, Y+4	; 0x04
    1a0e:	91 83       	std	Z+1, r25	; 0x01
    1a10:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    1a12:	0f b6       	in	r0, 0x3f	; 63
    1a14:	f8 94       	cli
    1a16:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1a18:	80 91 0f 03 	lds	r24, 0x030F
    1a1c:	8f 5f       	subi	r24, 0xFF	; 255
    1a1e:	80 93 0f 03 	sts	0x030F, r24
			if( pxCurrentTCB == NULL )
    1a22:	80 91 0c 03 	lds	r24, 0x030C
    1a26:	90 91 0d 03 	lds	r25, 0x030D
    1a2a:	00 97       	sbiw	r24, 0x00	; 0
    1a2c:	69 f4       	brne	.+26     	; 0x1a48 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1a2e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a30:	9c 81       	ldd	r25, Y+4	; 0x04
    1a32:	90 93 0d 03 	sts	0x030D, r25
    1a36:	80 93 0c 03 	sts	0x030C, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    1a3a:	80 91 0f 03 	lds	r24, 0x030F
    1a3e:	81 30       	cpi	r24, 0x01	; 1
    1a40:	a9 f4       	brne	.+42     	; 0x1a6c <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    1a42:	0e 94 6b 12 	call	0x24d6	; 0x24d6 <prvInitialiseTaskLists>
    1a46:	12 c0       	rjmp	.+36     	; 0x1a6c <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1a48:	80 91 14 03 	lds	r24, 0x0314
    1a4c:	88 23       	and	r24, r24
    1a4e:	71 f4       	brne	.+28     	; 0x1a6c <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1a50:	e0 91 0c 03 	lds	r30, 0x030C
    1a54:	f0 91 0d 03 	lds	r31, 0x030D
    1a58:	96 89       	ldd	r25, Z+22	; 0x16
    1a5a:	8e 85       	ldd	r24, Y+14	; 0x0e
    1a5c:	89 17       	cp	r24, r25
    1a5e:	30 f0       	brcs	.+12     	; 0x1a6c <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    1a60:	8b 81       	ldd	r24, Y+3	; 0x03
    1a62:	9c 81       	ldd	r25, Y+4	; 0x04
    1a64:	90 93 0d 03 	sts	0x030D, r25
    1a68:	80 93 0c 03 	sts	0x030C, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1a6c:	eb 81       	ldd	r30, Y+3	; 0x03
    1a6e:	fc 81       	ldd	r31, Y+4	; 0x04
    1a70:	96 89       	ldd	r25, Z+22	; 0x16
    1a72:	80 91 12 03 	lds	r24, 0x0312
    1a76:	89 17       	cp	r24, r25
    1a78:	28 f4       	brcc	.+10     	; 0x1a84 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1a7a:	eb 81       	ldd	r30, Y+3	; 0x03
    1a7c:	fc 81       	ldd	r31, Y+4	; 0x04
    1a7e:	86 89       	ldd	r24, Z+22	; 0x16
    1a80:	80 93 12 03 	sts	0x0312, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1a84:	80 91 19 03 	lds	r24, 0x0319
    1a88:	8f 5f       	subi	r24, 0xFF	; 255
    1a8a:	80 93 19 03 	sts	0x0319, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    1a8e:	eb 81       	ldd	r30, Y+3	; 0x03
    1a90:	fc 81       	ldd	r31, Y+4	; 0x04
    1a92:	96 89       	ldd	r25, Z+22	; 0x16
    1a94:	80 91 13 03 	lds	r24, 0x0313
    1a98:	89 17       	cp	r24, r25
    1a9a:	28 f4       	brcc	.+10     	; 0x1aa6 <xTaskGenericCreate+0x152>
    1a9c:	eb 81       	ldd	r30, Y+3	; 0x03
    1a9e:	fc 81       	ldd	r31, Y+4	; 0x04
    1aa0:	86 89       	ldd	r24, Z+22	; 0x16
    1aa2:	80 93 13 03 	sts	0x0313, r24
    1aa6:	eb 81       	ldd	r30, Y+3	; 0x03
    1aa8:	fc 81       	ldd	r31, Y+4	; 0x04
    1aaa:	86 89       	ldd	r24, Z+22	; 0x16
    1aac:	28 2f       	mov	r18, r24
    1aae:	30 e0       	ldi	r19, 0x00	; 0
    1ab0:	c9 01       	movw	r24, r18
    1ab2:	88 0f       	add	r24, r24
    1ab4:	99 1f       	adc	r25, r25
    1ab6:	88 0f       	add	r24, r24
    1ab8:	99 1f       	adc	r25, r25
    1aba:	88 0f       	add	r24, r24
    1abc:	99 1f       	adc	r25, r25
    1abe:	82 0f       	add	r24, r18
    1ac0:	93 1f       	adc	r25, r19
    1ac2:	ac 01       	movw	r20, r24
    1ac4:	46 5e       	subi	r20, 0xE6	; 230
    1ac6:	5c 4f       	sbci	r21, 0xFC	; 252
    1ac8:	8b 81       	ldd	r24, Y+3	; 0x03
    1aca:	9c 81       	ldd	r25, Y+4	; 0x04
    1acc:	9c 01       	movw	r18, r24
    1ace:	2e 5f       	subi	r18, 0xFE	; 254
    1ad0:	3f 4f       	sbci	r19, 0xFF	; 255
    1ad2:	ca 01       	movw	r24, r20
    1ad4:	b9 01       	movw	r22, r18
    1ad6:	0e 94 2f 04 	call	0x85e	; 0x85e <vListInsertEnd>

			xReturn = pdPASS;
    1ada:	81 e0       	ldi	r24, 0x01	; 1
    1adc:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1ade:	0f 90       	pop	r0
    1ae0:	0f be       	out	0x3f, r0	; 63
    1ae2:	02 c0       	rjmp	.+4      	; 0x1ae8 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1ae4:	8f ef       	ldi	r24, 0xFF	; 255
    1ae6:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    1ae8:	8d 81       	ldd	r24, Y+5	; 0x05
    1aea:	81 30       	cpi	r24, 0x01	; 1
    1aec:	71 f4       	brne	.+28     	; 0x1b0a <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    1aee:	80 91 14 03 	lds	r24, 0x0314
    1af2:	88 23       	and	r24, r24
    1af4:	51 f0       	breq	.+20     	; 0x1b0a <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1af6:	e0 91 0c 03 	lds	r30, 0x030C
    1afa:	f0 91 0d 03 	lds	r31, 0x030D
    1afe:	96 89       	ldd	r25, Z+22	; 0x16
    1b00:	8e 85       	ldd	r24, Y+14	; 0x0e
    1b02:	98 17       	cp	r25, r24
    1b04:	10 f4       	brcc	.+4      	; 0x1b0a <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    1b06:	0e 94 ef 06 	call	0xdde	; 0xdde <vPortYield>
			}
		}
	}

	return xReturn;
    1b0a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1b0c:	64 96       	adiw	r28, 0x14	; 20
    1b0e:	0f b6       	in	r0, 0x3f	; 63
    1b10:	f8 94       	cli
    1b12:	de bf       	out	0x3e, r29	; 62
    1b14:	0f be       	out	0x3f, r0	; 63
    1b16:	cd bf       	out	0x3d, r28	; 61
    1b18:	cf 91       	pop	r28
    1b1a:	df 91       	pop	r29
    1b1c:	1f 91       	pop	r17
    1b1e:	0f 91       	pop	r16
    1b20:	ff 90       	pop	r15
    1b22:	ef 90       	pop	r14
    1b24:	df 90       	pop	r13
    1b26:	cf 90       	pop	r12
    1b28:	bf 90       	pop	r11
    1b2a:	af 90       	pop	r10
    1b2c:	08 95       	ret

00001b2e <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1b2e:	df 93       	push	r29
    1b30:	cf 93       	push	r28
    1b32:	00 d0       	rcall	.+0      	; 0x1b34 <vTaskDelete+0x6>
    1b34:	00 d0       	rcall	.+0      	; 0x1b36 <vTaskDelete+0x8>
    1b36:	00 d0       	rcall	.+0      	; 0x1b38 <vTaskDelete+0xa>
    1b38:	cd b7       	in	r28, 0x3d	; 61
    1b3a:	de b7       	in	r29, 0x3e	; 62
    1b3c:	9c 83       	std	Y+4, r25	; 0x04
    1b3e:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1b40:	0f b6       	in	r0, 0x3f	; 63
    1b42:	f8 94       	cli
    1b44:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1b46:	20 91 0c 03 	lds	r18, 0x030C
    1b4a:	30 91 0d 03 	lds	r19, 0x030D
    1b4e:	8b 81       	ldd	r24, Y+3	; 0x03
    1b50:	9c 81       	ldd	r25, Y+4	; 0x04
    1b52:	82 17       	cp	r24, r18
    1b54:	93 07       	cpc	r25, r19
    1b56:	11 f4       	brne	.+4      	; 0x1b5c <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    1b58:	1c 82       	std	Y+4, r1	; 0x04
    1b5a:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1b5c:	8b 81       	ldd	r24, Y+3	; 0x03
    1b5e:	9c 81       	ldd	r25, Y+4	; 0x04
    1b60:	00 97       	sbiw	r24, 0x00	; 0
    1b62:	39 f4       	brne	.+14     	; 0x1b72 <vTaskDelete+0x44>
    1b64:	80 91 0c 03 	lds	r24, 0x030C
    1b68:	90 91 0d 03 	lds	r25, 0x030D
    1b6c:	9e 83       	std	Y+6, r25	; 0x06
    1b6e:	8d 83       	std	Y+5, r24	; 0x05
    1b70:	04 c0       	rjmp	.+8      	; 0x1b7a <vTaskDelete+0x4c>
    1b72:	8b 81       	ldd	r24, Y+3	; 0x03
    1b74:	9c 81       	ldd	r25, Y+4	; 0x04
    1b76:	9e 83       	std	Y+6, r25	; 0x06
    1b78:	8d 83       	std	Y+5, r24	; 0x05
    1b7a:	8d 81       	ldd	r24, Y+5	; 0x05
    1b7c:	9e 81       	ldd	r25, Y+6	; 0x06
    1b7e:	9a 83       	std	Y+2, r25	; 0x02
    1b80:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1b82:	89 81       	ldd	r24, Y+1	; 0x01
    1b84:	9a 81       	ldd	r25, Y+2	; 0x02
    1b86:	02 96       	adiw	r24, 0x02	; 2
    1b88:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1b8c:	e9 81       	ldd	r30, Y+1	; 0x01
    1b8e:	fa 81       	ldd	r31, Y+2	; 0x02
    1b90:	84 89       	ldd	r24, Z+20	; 0x14
    1b92:	95 89       	ldd	r25, Z+21	; 0x15
    1b94:	00 97       	sbiw	r24, 0x00	; 0
    1b96:	29 f0       	breq	.+10     	; 0x1ba2 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1b98:	89 81       	ldd	r24, Y+1	; 0x01
    1b9a:	9a 81       	ldd	r25, Y+2	; 0x02
    1b9c:	0c 96       	adiw	r24, 0x0c	; 12
    1b9e:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1ba2:	89 81       	ldd	r24, Y+1	; 0x01
    1ba4:	9a 81       	ldd	r25, Y+2	; 0x02
    1ba6:	9c 01       	movw	r18, r24
    1ba8:	2e 5f       	subi	r18, 0xFE	; 254
    1baa:	3f 4f       	sbci	r19, 0xFF	; 255
    1bac:	86 e6       	ldi	r24, 0x66	; 102
    1bae:	93 e0       	ldi	r25, 0x03	; 3
    1bb0:	b9 01       	movw	r22, r18
    1bb2:	0e 94 2f 04 	call	0x85e	; 0x85e <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1bb6:	80 91 0e 03 	lds	r24, 0x030E
    1bba:	8f 5f       	subi	r24, 0xFF	; 255
    1bbc:	80 93 0e 03 	sts	0x030E, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1bc0:	80 91 19 03 	lds	r24, 0x0319
    1bc4:	8f 5f       	subi	r24, 0xFF	; 255
    1bc6:	80 93 19 03 	sts	0x0319, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1bca:	0f 90       	pop	r0
    1bcc:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1bce:	80 91 14 03 	lds	r24, 0x0314
    1bd2:	88 23       	and	r24, r24
    1bd4:	31 f0       	breq	.+12     	; 0x1be2 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1bd6:	8b 81       	ldd	r24, Y+3	; 0x03
    1bd8:	9c 81       	ldd	r25, Y+4	; 0x04
    1bda:	00 97       	sbiw	r24, 0x00	; 0
    1bdc:	11 f4       	brne	.+4      	; 0x1be2 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    1bde:	0e 94 ef 06 	call	0xdde	; 0xdde <vPortYield>
			}
		}
	}
    1be2:	26 96       	adiw	r28, 0x06	; 6
    1be4:	0f b6       	in	r0, 0x3f	; 63
    1be6:	f8 94       	cli
    1be8:	de bf       	out	0x3e, r29	; 62
    1bea:	0f be       	out	0x3f, r0	; 63
    1bec:	cd bf       	out	0x3d, r28	; 61
    1bee:	cf 91       	pop	r28
    1bf0:	df 91       	pop	r29
    1bf2:	08 95       	ret

00001bf4 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1bf4:	df 93       	push	r29
    1bf6:	cf 93       	push	r28
    1bf8:	cd b7       	in	r28, 0x3d	; 61
    1bfa:	de b7       	in	r29, 0x3e	; 62
    1bfc:	28 97       	sbiw	r28, 0x08	; 8
    1bfe:	0f b6       	in	r0, 0x3f	; 63
    1c00:	f8 94       	cli
    1c02:	de bf       	out	0x3e, r29	; 62
    1c04:	0f be       	out	0x3f, r0	; 63
    1c06:	cd bf       	out	0x3d, r28	; 61
    1c08:	9e 83       	std	Y+6, r25	; 0x06
    1c0a:	8d 83       	std	Y+5, r24	; 0x05
    1c0c:	78 87       	std	Y+8, r23	; 0x08
    1c0e:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    1c10:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1c12:	0e 94 e6 0e 	call	0x1dcc	; 0x1dcc <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1c16:	ed 81       	ldd	r30, Y+5	; 0x05
    1c18:	fe 81       	ldd	r31, Y+6	; 0x06
    1c1a:	20 81       	ld	r18, Z
    1c1c:	31 81       	ldd	r19, Z+1	; 0x01
    1c1e:	8f 81       	ldd	r24, Y+7	; 0x07
    1c20:	98 85       	ldd	r25, Y+8	; 0x08
    1c22:	82 0f       	add	r24, r18
    1c24:	93 1f       	adc	r25, r19
    1c26:	9c 83       	std	Y+4, r25	; 0x04
    1c28:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    1c2a:	ed 81       	ldd	r30, Y+5	; 0x05
    1c2c:	fe 81       	ldd	r31, Y+6	; 0x06
    1c2e:	20 81       	ld	r18, Z
    1c30:	31 81       	ldd	r19, Z+1	; 0x01
    1c32:	80 91 10 03 	lds	r24, 0x0310
    1c36:	90 91 11 03 	lds	r25, 0x0311
    1c3a:	82 17       	cp	r24, r18
    1c3c:	93 07       	cpc	r25, r19
    1c3e:	a8 f4       	brcc	.+42     	; 0x1c6a <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1c40:	ed 81       	ldd	r30, Y+5	; 0x05
    1c42:	fe 81       	ldd	r31, Y+6	; 0x06
    1c44:	20 81       	ld	r18, Z
    1c46:	31 81       	ldd	r19, Z+1	; 0x01
    1c48:	8b 81       	ldd	r24, Y+3	; 0x03
    1c4a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c4c:	82 17       	cp	r24, r18
    1c4e:	93 07       	cpc	r25, r19
    1c50:	00 f5       	brcc	.+64     	; 0x1c92 <vTaskDelayUntil+0x9e>
    1c52:	20 91 10 03 	lds	r18, 0x0310
    1c56:	30 91 11 03 	lds	r19, 0x0311
    1c5a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c5c:	9c 81       	ldd	r25, Y+4	; 0x04
    1c5e:	28 17       	cp	r18, r24
    1c60:	39 07       	cpc	r19, r25
    1c62:	b8 f4       	brcc	.+46     	; 0x1c92 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1c64:	81 e0       	ldi	r24, 0x01	; 1
    1c66:	89 83       	std	Y+1, r24	; 0x01
    1c68:	14 c0       	rjmp	.+40     	; 0x1c92 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1c6a:	ed 81       	ldd	r30, Y+5	; 0x05
    1c6c:	fe 81       	ldd	r31, Y+6	; 0x06
    1c6e:	20 81       	ld	r18, Z
    1c70:	31 81       	ldd	r19, Z+1	; 0x01
    1c72:	8b 81       	ldd	r24, Y+3	; 0x03
    1c74:	9c 81       	ldd	r25, Y+4	; 0x04
    1c76:	82 17       	cp	r24, r18
    1c78:	93 07       	cpc	r25, r19
    1c7a:	48 f0       	brcs	.+18     	; 0x1c8e <vTaskDelayUntil+0x9a>
    1c7c:	20 91 10 03 	lds	r18, 0x0310
    1c80:	30 91 11 03 	lds	r19, 0x0311
    1c84:	8b 81       	ldd	r24, Y+3	; 0x03
    1c86:	9c 81       	ldd	r25, Y+4	; 0x04
    1c88:	28 17       	cp	r18, r24
    1c8a:	39 07       	cpc	r19, r25
    1c8c:	10 f4       	brcc	.+4      	; 0x1c92 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1c8e:	81 e0       	ldi	r24, 0x01	; 1
    1c90:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1c92:	ed 81       	ldd	r30, Y+5	; 0x05
    1c94:	fe 81       	ldd	r31, Y+6	; 0x06
    1c96:	8b 81       	ldd	r24, Y+3	; 0x03
    1c98:	9c 81       	ldd	r25, Y+4	; 0x04
    1c9a:	91 83       	std	Z+1, r25	; 0x01
    1c9c:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    1c9e:	89 81       	ldd	r24, Y+1	; 0x01
    1ca0:	88 23       	and	r24, r24
    1ca2:	59 f0       	breq	.+22     	; 0x1cba <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1ca4:	80 91 0c 03 	lds	r24, 0x030C
    1ca8:	90 91 0d 03 	lds	r25, 0x030D
    1cac:	02 96       	adiw	r24, 0x02	; 2
    1cae:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1cb2:	8b 81       	ldd	r24, Y+3	; 0x03
    1cb4:	9c 81       	ldd	r25, Y+4	; 0x04
    1cb6:	0e 94 e6 12 	call	0x25cc	; 0x25cc <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1cba:	0e 94 f2 0e 	call	0x1de4	; 0x1de4 <xTaskResumeAll>
    1cbe:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1cc0:	8a 81       	ldd	r24, Y+2	; 0x02
    1cc2:	88 23       	and	r24, r24
    1cc4:	11 f4       	brne	.+4      	; 0x1cca <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    1cc6:	0e 94 ef 06 	call	0xdde	; 0xdde <vPortYield>
		}
	}
    1cca:	28 96       	adiw	r28, 0x08	; 8
    1ccc:	0f b6       	in	r0, 0x3f	; 63
    1cce:	f8 94       	cli
    1cd0:	de bf       	out	0x3e, r29	; 62
    1cd2:	0f be       	out	0x3f, r0	; 63
    1cd4:	cd bf       	out	0x3d, r28	; 61
    1cd6:	cf 91       	pop	r28
    1cd8:	df 91       	pop	r29
    1cda:	08 95       	ret

00001cdc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1cdc:	df 93       	push	r29
    1cde:	cf 93       	push	r28
    1ce0:	00 d0       	rcall	.+0      	; 0x1ce2 <vTaskDelay+0x6>
    1ce2:	00 d0       	rcall	.+0      	; 0x1ce4 <vTaskDelay+0x8>
    1ce4:	0f 92       	push	r0
    1ce6:	cd b7       	in	r28, 0x3d	; 61
    1ce8:	de b7       	in	r29, 0x3e	; 62
    1cea:	9d 83       	std	Y+5, r25	; 0x05
    1cec:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1cee:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1cf0:	8c 81       	ldd	r24, Y+4	; 0x04
    1cf2:	9d 81       	ldd	r25, Y+5	; 0x05
    1cf4:	00 97       	sbiw	r24, 0x00	; 0
    1cf6:	d1 f0       	breq	.+52     	; 0x1d2c <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    1cf8:	0e 94 e6 0e 	call	0x1dcc	; 0x1dcc <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1cfc:	20 91 10 03 	lds	r18, 0x0310
    1d00:	30 91 11 03 	lds	r19, 0x0311
    1d04:	8c 81       	ldd	r24, Y+4	; 0x04
    1d06:	9d 81       	ldd	r25, Y+5	; 0x05
    1d08:	82 0f       	add	r24, r18
    1d0a:	93 1f       	adc	r25, r19
    1d0c:	9b 83       	std	Y+3, r25	; 0x03
    1d0e:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1d10:	80 91 0c 03 	lds	r24, 0x030C
    1d14:	90 91 0d 03 	lds	r25, 0x030D
    1d18:	02 96       	adiw	r24, 0x02	; 2
    1d1a:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1d1e:	8a 81       	ldd	r24, Y+2	; 0x02
    1d20:	9b 81       	ldd	r25, Y+3	; 0x03
    1d22:	0e 94 e6 12 	call	0x25cc	; 0x25cc <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1d26:	0e 94 f2 0e 	call	0x1de4	; 0x1de4 <xTaskResumeAll>
    1d2a:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1d2c:	89 81       	ldd	r24, Y+1	; 0x01
    1d2e:	88 23       	and	r24, r24
    1d30:	11 f4       	brne	.+4      	; 0x1d36 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    1d32:	0e 94 ef 06 	call	0xdde	; 0xdde <vPortYield>
		}
	}
    1d36:	0f 90       	pop	r0
    1d38:	0f 90       	pop	r0
    1d3a:	0f 90       	pop	r0
    1d3c:	0f 90       	pop	r0
    1d3e:	0f 90       	pop	r0
    1d40:	cf 91       	pop	r28
    1d42:	df 91       	pop	r29
    1d44:	08 95       	ret

00001d46 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1d46:	af 92       	push	r10
    1d48:	bf 92       	push	r11
    1d4a:	cf 92       	push	r12
    1d4c:	df 92       	push	r13
    1d4e:	ef 92       	push	r14
    1d50:	ff 92       	push	r15
    1d52:	0f 93       	push	r16
    1d54:	df 93       	push	r29
    1d56:	cf 93       	push	r28
    1d58:	0f 92       	push	r0
    1d5a:	cd b7       	in	r28, 0x3d	; 61
    1d5c:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    1d5e:	2c e6       	ldi	r18, 0x6C	; 108
    1d60:	30 e0       	ldi	r19, 0x00	; 0
    1d62:	88 e0       	ldi	r24, 0x08	; 8
    1d64:	92 e1       	ldi	r25, 0x12	; 18
    1d66:	b9 01       	movw	r22, r18
    1d68:	45 e5       	ldi	r20, 0x55	; 85
    1d6a:	50 e0       	ldi	r21, 0x00	; 0
    1d6c:	20 e0       	ldi	r18, 0x00	; 0
    1d6e:	30 e0       	ldi	r19, 0x00	; 0
    1d70:	00 e0       	ldi	r16, 0x00	; 0
    1d72:	ee 24       	eor	r14, r14
    1d74:	ff 24       	eor	r15, r15
    1d76:	cc 24       	eor	r12, r12
    1d78:	dd 24       	eor	r13, r13
    1d7a:	aa 24       	eor	r10, r10
    1d7c:	bb 24       	eor	r11, r11
    1d7e:	0e 94 aa 0c 	call	0x1954	; 0x1954 <xTaskGenericCreate>
    1d82:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    1d84:	89 81       	ldd	r24, Y+1	; 0x01
    1d86:	81 30       	cpi	r24, 0x01	; 1
    1d88:	51 f4       	brne	.+20     	; 0x1d9e <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1d8a:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1d8c:	81 e0       	ldi	r24, 0x01	; 1
    1d8e:	80 93 14 03 	sts	0x0314, r24
		xTickCount = ( portTickType ) 0U;
    1d92:	10 92 11 03 	sts	0x0311, r1
    1d96:	10 92 10 03 	sts	0x0310, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1d9a:	0e 94 b3 06 	call	0xd66	; 0xd66 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    1d9e:	0f 90       	pop	r0
    1da0:	cf 91       	pop	r28
    1da2:	df 91       	pop	r29
    1da4:	0f 91       	pop	r16
    1da6:	ff 90       	pop	r15
    1da8:	ef 90       	pop	r14
    1daa:	df 90       	pop	r13
    1dac:	cf 90       	pop	r12
    1dae:	bf 90       	pop	r11
    1db0:	af 90       	pop	r10
    1db2:	08 95       	ret

00001db4 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    1db4:	df 93       	push	r29
    1db6:	cf 93       	push	r28
    1db8:	cd b7       	in	r28, 0x3d	; 61
    1dba:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1dbc:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1dbe:	10 92 14 03 	sts	0x0314, r1
	vPortEndScheduler();
    1dc2:	0e 94 e8 06 	call	0xdd0	; 0xdd0 <vPortEndScheduler>
}
    1dc6:	cf 91       	pop	r28
    1dc8:	df 91       	pop	r29
    1dca:	08 95       	ret

00001dcc <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    1dcc:	df 93       	push	r29
    1dce:	cf 93       	push	r28
    1dd0:	cd b7       	in	r28, 0x3d	; 61
    1dd2:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1dd4:	80 91 15 03 	lds	r24, 0x0315
    1dd8:	8f 5f       	subi	r24, 0xFF	; 255
    1dda:	80 93 15 03 	sts	0x0315, r24
}
    1dde:	cf 91       	pop	r28
    1de0:	df 91       	pop	r29
    1de2:	08 95       	ret

00001de4 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1de4:	df 93       	push	r29
    1de6:	cf 93       	push	r28
    1de8:	00 d0       	rcall	.+0      	; 0x1dea <xTaskResumeAll+0x6>
    1dea:	00 d0       	rcall	.+0      	; 0x1dec <xTaskResumeAll+0x8>
    1dec:	cd b7       	in	r28, 0x3d	; 61
    1dee:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1df0:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1df2:	0f b6       	in	r0, 0x3f	; 63
    1df4:	f8 94       	cli
    1df6:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1df8:	80 91 15 03 	lds	r24, 0x0315
    1dfc:	81 50       	subi	r24, 0x01	; 1
    1dfe:	80 93 15 03 	sts	0x0315, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1e02:	80 91 15 03 	lds	r24, 0x0315
    1e06:	88 23       	and	r24, r24
    1e08:	09 f0       	breq	.+2      	; 0x1e0c <xTaskResumeAll+0x28>
    1e0a:	6a c0       	rjmp	.+212    	; 0x1ee0 <xTaskResumeAll+0xfc>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1e0c:	80 91 0f 03 	lds	r24, 0x030F
    1e10:	88 23       	and	r24, r24
    1e12:	09 f4       	brne	.+2      	; 0x1e16 <xTaskResumeAll+0x32>
    1e14:	65 c0       	rjmp	.+202    	; 0x1ee0 <xTaskResumeAll+0xfc>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    1e16:	19 82       	std	Y+1, r1	; 0x01
    1e18:	41 c0       	rjmp	.+130    	; 0x1e9c <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1e1a:	e0 91 62 03 	lds	r30, 0x0362
    1e1e:	f0 91 63 03 	lds	r31, 0x0363
    1e22:	86 81       	ldd	r24, Z+6	; 0x06
    1e24:	97 81       	ldd	r25, Z+7	; 0x07
    1e26:	9c 83       	std	Y+4, r25	; 0x04
    1e28:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    1e2a:	8b 81       	ldd	r24, Y+3	; 0x03
    1e2c:	9c 81       	ldd	r25, Y+4	; 0x04
    1e2e:	0c 96       	adiw	r24, 0x0c	; 12
    1e30:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1e34:	8b 81       	ldd	r24, Y+3	; 0x03
    1e36:	9c 81       	ldd	r25, Y+4	; 0x04
    1e38:	02 96       	adiw	r24, 0x02	; 2
    1e3a:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1e3e:	eb 81       	ldd	r30, Y+3	; 0x03
    1e40:	fc 81       	ldd	r31, Y+4	; 0x04
    1e42:	96 89       	ldd	r25, Z+22	; 0x16
    1e44:	80 91 13 03 	lds	r24, 0x0313
    1e48:	89 17       	cp	r24, r25
    1e4a:	28 f4       	brcc	.+10     	; 0x1e56 <xTaskResumeAll+0x72>
    1e4c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e4e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e50:	86 89       	ldd	r24, Z+22	; 0x16
    1e52:	80 93 13 03 	sts	0x0313, r24
    1e56:	eb 81       	ldd	r30, Y+3	; 0x03
    1e58:	fc 81       	ldd	r31, Y+4	; 0x04
    1e5a:	86 89       	ldd	r24, Z+22	; 0x16
    1e5c:	28 2f       	mov	r18, r24
    1e5e:	30 e0       	ldi	r19, 0x00	; 0
    1e60:	c9 01       	movw	r24, r18
    1e62:	88 0f       	add	r24, r24
    1e64:	99 1f       	adc	r25, r25
    1e66:	88 0f       	add	r24, r24
    1e68:	99 1f       	adc	r25, r25
    1e6a:	88 0f       	add	r24, r24
    1e6c:	99 1f       	adc	r25, r25
    1e6e:	82 0f       	add	r24, r18
    1e70:	93 1f       	adc	r25, r19
    1e72:	86 5e       	subi	r24, 0xE6	; 230
    1e74:	9c 4f       	sbci	r25, 0xFC	; 252
    1e76:	2b 81       	ldd	r18, Y+3	; 0x03
    1e78:	3c 81       	ldd	r19, Y+4	; 0x04
    1e7a:	2e 5f       	subi	r18, 0xFE	; 254
    1e7c:	3f 4f       	sbci	r19, 0xFF	; 255
    1e7e:	b9 01       	movw	r22, r18
    1e80:	0e 94 2f 04 	call	0x85e	; 0x85e <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1e84:	eb 81       	ldd	r30, Y+3	; 0x03
    1e86:	fc 81       	ldd	r31, Y+4	; 0x04
    1e88:	96 89       	ldd	r25, Z+22	; 0x16
    1e8a:	e0 91 0c 03 	lds	r30, 0x030C
    1e8e:	f0 91 0d 03 	lds	r31, 0x030D
    1e92:	86 89       	ldd	r24, Z+22	; 0x16
    1e94:	98 17       	cp	r25, r24
    1e96:	10 f0       	brcs	.+4      	; 0x1e9c <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    1e98:	81 e0       	ldi	r24, 0x01	; 1
    1e9a:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1e9c:	80 91 5d 03 	lds	r24, 0x035D
    1ea0:	88 23       	and	r24, r24
    1ea2:	09 f0       	breq	.+2      	; 0x1ea6 <xTaskResumeAll+0xc2>
    1ea4:	ba cf       	rjmp	.-140    	; 0x1e1a <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1ea6:	80 91 16 03 	lds	r24, 0x0316
    1eaa:	88 23       	and	r24, r24
    1eac:	61 f0       	breq	.+24     	; 0x1ec6 <xTaskResumeAll+0xe2>
    1eae:	07 c0       	rjmp	.+14     	; 0x1ebe <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    1eb0:	0e 94 af 0f 	call	0x1f5e	; 0x1f5e <vTaskIncrementTick>
						--uxMissedTicks;
    1eb4:	80 91 16 03 	lds	r24, 0x0316
    1eb8:	81 50       	subi	r24, 0x01	; 1
    1eba:	80 93 16 03 	sts	0x0316, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1ebe:	80 91 16 03 	lds	r24, 0x0316
    1ec2:	88 23       	and	r24, r24
    1ec4:	a9 f7       	brne	.-22     	; 0x1eb0 <xTaskResumeAll+0xcc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1ec6:	89 81       	ldd	r24, Y+1	; 0x01
    1ec8:	81 30       	cpi	r24, 0x01	; 1
    1eca:	21 f0       	breq	.+8      	; 0x1ed4 <xTaskResumeAll+0xf0>
    1ecc:	80 91 17 03 	lds	r24, 0x0317
    1ed0:	81 30       	cpi	r24, 0x01	; 1
    1ed2:	31 f4       	brne	.+12     	; 0x1ee0 <xTaskResumeAll+0xfc>
				{
					xAlreadyYielded = pdTRUE;
    1ed4:	81 e0       	ldi	r24, 0x01	; 1
    1ed6:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    1ed8:	10 92 17 03 	sts	0x0317, r1
					portYIELD_WITHIN_API();
    1edc:	0e 94 ef 06 	call	0xdde	; 0xdde <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    1ee0:	0f 90       	pop	r0
    1ee2:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    1ee4:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1ee6:	0f 90       	pop	r0
    1ee8:	0f 90       	pop	r0
    1eea:	0f 90       	pop	r0
    1eec:	0f 90       	pop	r0
    1eee:	cf 91       	pop	r28
    1ef0:	df 91       	pop	r29
    1ef2:	08 95       	ret

00001ef4 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    1ef4:	df 93       	push	r29
    1ef6:	cf 93       	push	r28
    1ef8:	00 d0       	rcall	.+0      	; 0x1efa <xTaskGetTickCount+0x6>
    1efa:	cd b7       	in	r28, 0x3d	; 61
    1efc:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    1efe:	0f b6       	in	r0, 0x3f	; 63
    1f00:	f8 94       	cli
    1f02:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1f04:	80 91 10 03 	lds	r24, 0x0310
    1f08:	90 91 11 03 	lds	r25, 0x0311
    1f0c:	9a 83       	std	Y+2, r25	; 0x02
    1f0e:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    1f10:	0f 90       	pop	r0
    1f12:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    1f14:	89 81       	ldd	r24, Y+1	; 0x01
    1f16:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1f18:	0f 90       	pop	r0
    1f1a:	0f 90       	pop	r0
    1f1c:	cf 91       	pop	r28
    1f1e:	df 91       	pop	r29
    1f20:	08 95       	ret

00001f22 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    1f22:	df 93       	push	r29
    1f24:	cf 93       	push	r28
    1f26:	00 d0       	rcall	.+0      	; 0x1f28 <xTaskGetTickCountFromISR+0x6>
    1f28:	0f 92       	push	r0
    1f2a:	cd b7       	in	r28, 0x3d	; 61
    1f2c:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1f2e:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    1f30:	80 91 10 03 	lds	r24, 0x0310
    1f34:	90 91 11 03 	lds	r25, 0x0311
    1f38:	9b 83       	std	Y+3, r25	; 0x03
    1f3a:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1f3c:	8a 81       	ldd	r24, Y+2	; 0x02
    1f3e:	9b 81       	ldd	r25, Y+3	; 0x03
}
    1f40:	0f 90       	pop	r0
    1f42:	0f 90       	pop	r0
    1f44:	0f 90       	pop	r0
    1f46:	cf 91       	pop	r28
    1f48:	df 91       	pop	r29
    1f4a:	08 95       	ret

00001f4c <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    1f4c:	df 93       	push	r29
    1f4e:	cf 93       	push	r28
    1f50:	cd b7       	in	r28, 0x3d	; 61
    1f52:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1f54:	80 91 0f 03 	lds	r24, 0x030F
}
    1f58:	cf 91       	pop	r28
    1f5a:	df 91       	pop	r29
    1f5c:	08 95       	ret

00001f5e <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1f5e:	df 93       	push	r29
    1f60:	cf 93       	push	r28
    1f62:	00 d0       	rcall	.+0      	; 0x1f64 <vTaskIncrementTick+0x6>
    1f64:	00 d0       	rcall	.+0      	; 0x1f66 <vTaskIncrementTick+0x8>
    1f66:	00 d0       	rcall	.+0      	; 0x1f68 <vTaskIncrementTick+0xa>
    1f68:	cd b7       	in	r28, 0x3d	; 61
    1f6a:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1f6c:	80 91 15 03 	lds	r24, 0x0315
    1f70:	88 23       	and	r24, r24
    1f72:	09 f0       	breq	.+2      	; 0x1f76 <vTaskIncrementTick+0x18>
    1f74:	bb c0       	rjmp	.+374    	; 0x20ec <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    1f76:	80 91 10 03 	lds	r24, 0x0310
    1f7a:	90 91 11 03 	lds	r25, 0x0311
    1f7e:	01 96       	adiw	r24, 0x01	; 1
    1f80:	90 93 11 03 	sts	0x0311, r25
    1f84:	80 93 10 03 	sts	0x0310, r24
		if( xTickCount == ( portTickType ) 0U )
    1f88:	80 91 10 03 	lds	r24, 0x0310
    1f8c:	90 91 11 03 	lds	r25, 0x0311
    1f90:	00 97       	sbiw	r24, 0x00	; 0
    1f92:	d1 f5       	brne	.+116    	; 0x2008 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    1f94:	80 91 59 03 	lds	r24, 0x0359
    1f98:	90 91 5a 03 	lds	r25, 0x035A
    1f9c:	9c 83       	std	Y+4, r25	; 0x04
    1f9e:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1fa0:	80 91 5b 03 	lds	r24, 0x035B
    1fa4:	90 91 5c 03 	lds	r25, 0x035C
    1fa8:	90 93 5a 03 	sts	0x035A, r25
    1fac:	80 93 59 03 	sts	0x0359, r24
			pxOverflowDelayedTaskList = pxTemp;
    1fb0:	8b 81       	ldd	r24, Y+3	; 0x03
    1fb2:	9c 81       	ldd	r25, Y+4	; 0x04
    1fb4:	90 93 5c 03 	sts	0x035C, r25
    1fb8:	80 93 5b 03 	sts	0x035B, r24
			xNumOfOverflows++;
    1fbc:	80 91 18 03 	lds	r24, 0x0318
    1fc0:	8f 5f       	subi	r24, 0xFF	; 255
    1fc2:	80 93 18 03 	sts	0x0318, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1fc6:	e0 91 59 03 	lds	r30, 0x0359
    1fca:	f0 91 5a 03 	lds	r31, 0x035A
    1fce:	80 81       	ld	r24, Z
    1fd0:	88 23       	and	r24, r24
    1fd2:	39 f4       	brne	.+14     	; 0x1fe2 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    1fd4:	8f ef       	ldi	r24, 0xFF	; 255
    1fd6:	9f ef       	ldi	r25, 0xFF	; 255
    1fd8:	90 93 72 00 	sts	0x0072, r25
    1fdc:	80 93 71 00 	sts	0x0071, r24
    1fe0:	13 c0       	rjmp	.+38     	; 0x2008 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1fe2:	e0 91 59 03 	lds	r30, 0x0359
    1fe6:	f0 91 5a 03 	lds	r31, 0x035A
    1fea:	05 80       	ldd	r0, Z+5	; 0x05
    1fec:	f6 81       	ldd	r31, Z+6	; 0x06
    1fee:	e0 2d       	mov	r30, r0
    1ff0:	86 81       	ldd	r24, Z+6	; 0x06
    1ff2:	97 81       	ldd	r25, Z+7	; 0x07
    1ff4:	9e 83       	std	Y+6, r25	; 0x06
    1ff6:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1ff8:	ed 81       	ldd	r30, Y+5	; 0x05
    1ffa:	fe 81       	ldd	r31, Y+6	; 0x06
    1ffc:	82 81       	ldd	r24, Z+2	; 0x02
    1ffe:	93 81       	ldd	r25, Z+3	; 0x03
    2000:	90 93 72 00 	sts	0x0072, r25
    2004:	80 93 71 00 	sts	0x0071, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2008:	20 91 10 03 	lds	r18, 0x0310
    200c:	30 91 11 03 	lds	r19, 0x0311
    2010:	80 91 71 00 	lds	r24, 0x0071
    2014:	90 91 72 00 	lds	r25, 0x0072
    2018:	28 17       	cp	r18, r24
    201a:	39 07       	cpc	r19, r25
    201c:	08 f4       	brcc	.+2      	; 0x2020 <vTaskIncrementTick+0xc2>
    201e:	6b c0       	rjmp	.+214    	; 0x20f6 <vTaskIncrementTick+0x198>
    2020:	e0 91 59 03 	lds	r30, 0x0359
    2024:	f0 91 5a 03 	lds	r31, 0x035A
    2028:	80 81       	ld	r24, Z
    202a:	88 23       	and	r24, r24
    202c:	39 f4       	brne	.+14     	; 0x203c <vTaskIncrementTick+0xde>
    202e:	8f ef       	ldi	r24, 0xFF	; 255
    2030:	9f ef       	ldi	r25, 0xFF	; 255
    2032:	90 93 72 00 	sts	0x0072, r25
    2036:	80 93 71 00 	sts	0x0071, r24
    203a:	5d c0       	rjmp	.+186    	; 0x20f6 <vTaskIncrementTick+0x198>
    203c:	e0 91 59 03 	lds	r30, 0x0359
    2040:	f0 91 5a 03 	lds	r31, 0x035A
    2044:	05 80       	ldd	r0, Z+5	; 0x05
    2046:	f6 81       	ldd	r31, Z+6	; 0x06
    2048:	e0 2d       	mov	r30, r0
    204a:	86 81       	ldd	r24, Z+6	; 0x06
    204c:	97 81       	ldd	r25, Z+7	; 0x07
    204e:	9e 83       	std	Y+6, r25	; 0x06
    2050:	8d 83       	std	Y+5, r24	; 0x05
    2052:	ed 81       	ldd	r30, Y+5	; 0x05
    2054:	fe 81       	ldd	r31, Y+6	; 0x06
    2056:	82 81       	ldd	r24, Z+2	; 0x02
    2058:	93 81       	ldd	r25, Z+3	; 0x03
    205a:	9a 83       	std	Y+2, r25	; 0x02
    205c:	89 83       	std	Y+1, r24	; 0x01
    205e:	20 91 10 03 	lds	r18, 0x0310
    2062:	30 91 11 03 	lds	r19, 0x0311
    2066:	89 81       	ldd	r24, Y+1	; 0x01
    2068:	9a 81       	ldd	r25, Y+2	; 0x02
    206a:	28 17       	cp	r18, r24
    206c:	39 07       	cpc	r19, r25
    206e:	38 f4       	brcc	.+14     	; 0x207e <vTaskIncrementTick+0x120>
    2070:	89 81       	ldd	r24, Y+1	; 0x01
    2072:	9a 81       	ldd	r25, Y+2	; 0x02
    2074:	90 93 72 00 	sts	0x0072, r25
    2078:	80 93 71 00 	sts	0x0071, r24
    207c:	3c c0       	rjmp	.+120    	; 0x20f6 <vTaskIncrementTick+0x198>
    207e:	8d 81       	ldd	r24, Y+5	; 0x05
    2080:	9e 81       	ldd	r25, Y+6	; 0x06
    2082:	02 96       	adiw	r24, 0x02	; 2
    2084:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListRemove>
    2088:	ed 81       	ldd	r30, Y+5	; 0x05
    208a:	fe 81       	ldd	r31, Y+6	; 0x06
    208c:	84 89       	ldd	r24, Z+20	; 0x14
    208e:	95 89       	ldd	r25, Z+21	; 0x15
    2090:	00 97       	sbiw	r24, 0x00	; 0
    2092:	29 f0       	breq	.+10     	; 0x209e <vTaskIncrementTick+0x140>
    2094:	8d 81       	ldd	r24, Y+5	; 0x05
    2096:	9e 81       	ldd	r25, Y+6	; 0x06
    2098:	0c 96       	adiw	r24, 0x0c	; 12
    209a:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListRemove>
    209e:	ed 81       	ldd	r30, Y+5	; 0x05
    20a0:	fe 81       	ldd	r31, Y+6	; 0x06
    20a2:	96 89       	ldd	r25, Z+22	; 0x16
    20a4:	80 91 13 03 	lds	r24, 0x0313
    20a8:	89 17       	cp	r24, r25
    20aa:	28 f4       	brcc	.+10     	; 0x20b6 <vTaskIncrementTick+0x158>
    20ac:	ed 81       	ldd	r30, Y+5	; 0x05
    20ae:	fe 81       	ldd	r31, Y+6	; 0x06
    20b0:	86 89       	ldd	r24, Z+22	; 0x16
    20b2:	80 93 13 03 	sts	0x0313, r24
    20b6:	ed 81       	ldd	r30, Y+5	; 0x05
    20b8:	fe 81       	ldd	r31, Y+6	; 0x06
    20ba:	86 89       	ldd	r24, Z+22	; 0x16
    20bc:	28 2f       	mov	r18, r24
    20be:	30 e0       	ldi	r19, 0x00	; 0
    20c0:	c9 01       	movw	r24, r18
    20c2:	88 0f       	add	r24, r24
    20c4:	99 1f       	adc	r25, r25
    20c6:	88 0f       	add	r24, r24
    20c8:	99 1f       	adc	r25, r25
    20ca:	88 0f       	add	r24, r24
    20cc:	99 1f       	adc	r25, r25
    20ce:	82 0f       	add	r24, r18
    20d0:	93 1f       	adc	r25, r19
    20d2:	ac 01       	movw	r20, r24
    20d4:	46 5e       	subi	r20, 0xE6	; 230
    20d6:	5c 4f       	sbci	r21, 0xFC	; 252
    20d8:	8d 81       	ldd	r24, Y+5	; 0x05
    20da:	9e 81       	ldd	r25, Y+6	; 0x06
    20dc:	9c 01       	movw	r18, r24
    20de:	2e 5f       	subi	r18, 0xFE	; 254
    20e0:	3f 4f       	sbci	r19, 0xFF	; 255
    20e2:	ca 01       	movw	r24, r20
    20e4:	b9 01       	movw	r22, r18
    20e6:	0e 94 2f 04 	call	0x85e	; 0x85e <vListInsertEnd>
    20ea:	9a cf       	rjmp	.-204    	; 0x2020 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    20ec:	80 91 16 03 	lds	r24, 0x0316
    20f0:	8f 5f       	subi	r24, 0xFF	; 255
    20f2:	80 93 16 03 	sts	0x0316, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    20f6:	26 96       	adiw	r28, 0x06	; 6
    20f8:	0f b6       	in	r0, 0x3f	; 63
    20fa:	f8 94       	cli
    20fc:	de bf       	out	0x3e, r29	; 62
    20fe:	0f be       	out	0x3f, r0	; 63
    2100:	cd bf       	out	0x3d, r28	; 61
    2102:	cf 91       	pop	r28
    2104:	df 91       	pop	r29
    2106:	08 95       	ret

00002108 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    2108:	df 93       	push	r29
    210a:	cf 93       	push	r28
    210c:	00 d0       	rcall	.+0      	; 0x210e <vTaskSwitchContext+0x6>
    210e:	cd b7       	in	r28, 0x3d	; 61
    2110:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2112:	80 91 15 03 	lds	r24, 0x0315
    2116:	88 23       	and	r24, r24
    2118:	49 f0       	breq	.+18     	; 0x212c <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    211a:	81 e0       	ldi	r24, 0x01	; 1
    211c:	80 93 17 03 	sts	0x0317, r24
    2120:	54 c0       	rjmp	.+168    	; 0x21ca <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2122:	80 91 13 03 	lds	r24, 0x0313
    2126:	81 50       	subi	r24, 0x01	; 1
    2128:	80 93 13 03 	sts	0x0313, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    212c:	80 91 13 03 	lds	r24, 0x0313
    2130:	28 2f       	mov	r18, r24
    2132:	30 e0       	ldi	r19, 0x00	; 0
    2134:	c9 01       	movw	r24, r18
    2136:	88 0f       	add	r24, r24
    2138:	99 1f       	adc	r25, r25
    213a:	88 0f       	add	r24, r24
    213c:	99 1f       	adc	r25, r25
    213e:	88 0f       	add	r24, r24
    2140:	99 1f       	adc	r25, r25
    2142:	82 0f       	add	r24, r18
    2144:	93 1f       	adc	r25, r19
    2146:	fc 01       	movw	r30, r24
    2148:	e6 5e       	subi	r30, 0xE6	; 230
    214a:	fc 4f       	sbci	r31, 0xFC	; 252
    214c:	80 81       	ld	r24, Z
    214e:	88 23       	and	r24, r24
    2150:	41 f3       	breq	.-48     	; 0x2122 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    2152:	80 91 13 03 	lds	r24, 0x0313
    2156:	28 2f       	mov	r18, r24
    2158:	30 e0       	ldi	r19, 0x00	; 0
    215a:	c9 01       	movw	r24, r18
    215c:	88 0f       	add	r24, r24
    215e:	99 1f       	adc	r25, r25
    2160:	88 0f       	add	r24, r24
    2162:	99 1f       	adc	r25, r25
    2164:	88 0f       	add	r24, r24
    2166:	99 1f       	adc	r25, r25
    2168:	82 0f       	add	r24, r18
    216a:	93 1f       	adc	r25, r19
    216c:	86 5e       	subi	r24, 0xE6	; 230
    216e:	9c 4f       	sbci	r25, 0xFC	; 252
    2170:	9a 83       	std	Y+2, r25	; 0x02
    2172:	89 83       	std	Y+1, r24	; 0x01
    2174:	e9 81       	ldd	r30, Y+1	; 0x01
    2176:	fa 81       	ldd	r31, Y+2	; 0x02
    2178:	01 80       	ldd	r0, Z+1	; 0x01
    217a:	f2 81       	ldd	r31, Z+2	; 0x02
    217c:	e0 2d       	mov	r30, r0
    217e:	82 81       	ldd	r24, Z+2	; 0x02
    2180:	93 81       	ldd	r25, Z+3	; 0x03
    2182:	e9 81       	ldd	r30, Y+1	; 0x01
    2184:	fa 81       	ldd	r31, Y+2	; 0x02
    2186:	92 83       	std	Z+2, r25	; 0x02
    2188:	81 83       	std	Z+1, r24	; 0x01
    218a:	e9 81       	ldd	r30, Y+1	; 0x01
    218c:	fa 81       	ldd	r31, Y+2	; 0x02
    218e:	21 81       	ldd	r18, Z+1	; 0x01
    2190:	32 81       	ldd	r19, Z+2	; 0x02
    2192:	89 81       	ldd	r24, Y+1	; 0x01
    2194:	9a 81       	ldd	r25, Y+2	; 0x02
    2196:	03 96       	adiw	r24, 0x03	; 3
    2198:	28 17       	cp	r18, r24
    219a:	39 07       	cpc	r19, r25
    219c:	59 f4       	brne	.+22     	; 0x21b4 <vTaskSwitchContext+0xac>
    219e:	e9 81       	ldd	r30, Y+1	; 0x01
    21a0:	fa 81       	ldd	r31, Y+2	; 0x02
    21a2:	01 80       	ldd	r0, Z+1	; 0x01
    21a4:	f2 81       	ldd	r31, Z+2	; 0x02
    21a6:	e0 2d       	mov	r30, r0
    21a8:	82 81       	ldd	r24, Z+2	; 0x02
    21aa:	93 81       	ldd	r25, Z+3	; 0x03
    21ac:	e9 81       	ldd	r30, Y+1	; 0x01
    21ae:	fa 81       	ldd	r31, Y+2	; 0x02
    21b0:	92 83       	std	Z+2, r25	; 0x02
    21b2:	81 83       	std	Z+1, r24	; 0x01
    21b4:	e9 81       	ldd	r30, Y+1	; 0x01
    21b6:	fa 81       	ldd	r31, Y+2	; 0x02
    21b8:	01 80       	ldd	r0, Z+1	; 0x01
    21ba:	f2 81       	ldd	r31, Z+2	; 0x02
    21bc:	e0 2d       	mov	r30, r0
    21be:	86 81       	ldd	r24, Z+6	; 0x06
    21c0:	97 81       	ldd	r25, Z+7	; 0x07
    21c2:	90 93 0d 03 	sts	0x030D, r25
    21c6:	80 93 0c 03 	sts	0x030C, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    21ca:	0f 90       	pop	r0
    21cc:	0f 90       	pop	r0
    21ce:	cf 91       	pop	r28
    21d0:	df 91       	pop	r29
    21d2:	08 95       	ret

000021d4 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    21d4:	df 93       	push	r29
    21d6:	cf 93       	push	r28
    21d8:	00 d0       	rcall	.+0      	; 0x21da <vTaskPlaceOnEventList+0x6>
    21da:	00 d0       	rcall	.+0      	; 0x21dc <vTaskPlaceOnEventList+0x8>
    21dc:	00 d0       	rcall	.+0      	; 0x21de <vTaskPlaceOnEventList+0xa>
    21de:	cd b7       	in	r28, 0x3d	; 61
    21e0:	de b7       	in	r29, 0x3e	; 62
    21e2:	9c 83       	std	Y+4, r25	; 0x04
    21e4:	8b 83       	std	Y+3, r24	; 0x03
    21e6:	7e 83       	std	Y+6, r23	; 0x06
    21e8:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    21ea:	4b 81       	ldd	r20, Y+3	; 0x03
    21ec:	5c 81       	ldd	r21, Y+4	; 0x04
    21ee:	80 91 0c 03 	lds	r24, 0x030C
    21f2:	90 91 0d 03 	lds	r25, 0x030D
    21f6:	9c 01       	movw	r18, r24
    21f8:	24 5f       	subi	r18, 0xF4	; 244
    21fa:	3f 4f       	sbci	r19, 0xFF	; 255
    21fc:	ca 01       	movw	r24, r20
    21fe:	b9 01       	movw	r22, r18
    2200:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2204:	80 91 0c 03 	lds	r24, 0x030C
    2208:	90 91 0d 03 	lds	r25, 0x030D
    220c:	02 96       	adiw	r24, 0x02	; 2
    220e:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2212:	20 91 10 03 	lds	r18, 0x0310
    2216:	30 91 11 03 	lds	r19, 0x0311
    221a:	8d 81       	ldd	r24, Y+5	; 0x05
    221c:	9e 81       	ldd	r25, Y+6	; 0x06
    221e:	82 0f       	add	r24, r18
    2220:	93 1f       	adc	r25, r19
    2222:	9a 83       	std	Y+2, r25	; 0x02
    2224:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2226:	89 81       	ldd	r24, Y+1	; 0x01
    2228:	9a 81       	ldd	r25, Y+2	; 0x02
    222a:	0e 94 e6 12 	call	0x25cc	; 0x25cc <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    222e:	26 96       	adiw	r28, 0x06	; 6
    2230:	0f b6       	in	r0, 0x3f	; 63
    2232:	f8 94       	cli
    2234:	de bf       	out	0x3e, r29	; 62
    2236:	0f be       	out	0x3f, r0	; 63
    2238:	cd bf       	out	0x3d, r28	; 61
    223a:	cf 91       	pop	r28
    223c:	df 91       	pop	r29
    223e:	08 95       	ret

00002240 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2240:	df 93       	push	r29
    2242:	cf 93       	push	r28
    2244:	00 d0       	rcall	.+0      	; 0x2246 <xTaskRemoveFromEventList+0x6>
    2246:	00 d0       	rcall	.+0      	; 0x2248 <xTaskRemoveFromEventList+0x8>
    2248:	0f 92       	push	r0
    224a:	cd b7       	in	r28, 0x3d	; 61
    224c:	de b7       	in	r29, 0x3e	; 62
    224e:	9d 83       	std	Y+5, r25	; 0x05
    2250:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2252:	ec 81       	ldd	r30, Y+4	; 0x04
    2254:	fd 81       	ldd	r31, Y+5	; 0x05
    2256:	05 80       	ldd	r0, Z+5	; 0x05
    2258:	f6 81       	ldd	r31, Z+6	; 0x06
    225a:	e0 2d       	mov	r30, r0
    225c:	86 81       	ldd	r24, Z+6	; 0x06
    225e:	97 81       	ldd	r25, Z+7	; 0x07
    2260:	9b 83       	std	Y+3, r25	; 0x03
    2262:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2264:	8a 81       	ldd	r24, Y+2	; 0x02
    2266:	9b 81       	ldd	r25, Y+3	; 0x03
    2268:	0c 96       	adiw	r24, 0x0c	; 12
    226a:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    226e:	80 91 15 03 	lds	r24, 0x0315
    2272:	88 23       	and	r24, r24
    2274:	61 f5       	brne	.+88     	; 0x22ce <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2276:	8a 81       	ldd	r24, Y+2	; 0x02
    2278:	9b 81       	ldd	r25, Y+3	; 0x03
    227a:	02 96       	adiw	r24, 0x02	; 2
    227c:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2280:	ea 81       	ldd	r30, Y+2	; 0x02
    2282:	fb 81       	ldd	r31, Y+3	; 0x03
    2284:	96 89       	ldd	r25, Z+22	; 0x16
    2286:	80 91 13 03 	lds	r24, 0x0313
    228a:	89 17       	cp	r24, r25
    228c:	28 f4       	brcc	.+10     	; 0x2298 <xTaskRemoveFromEventList+0x58>
    228e:	ea 81       	ldd	r30, Y+2	; 0x02
    2290:	fb 81       	ldd	r31, Y+3	; 0x03
    2292:	86 89       	ldd	r24, Z+22	; 0x16
    2294:	80 93 13 03 	sts	0x0313, r24
    2298:	ea 81       	ldd	r30, Y+2	; 0x02
    229a:	fb 81       	ldd	r31, Y+3	; 0x03
    229c:	86 89       	ldd	r24, Z+22	; 0x16
    229e:	28 2f       	mov	r18, r24
    22a0:	30 e0       	ldi	r19, 0x00	; 0
    22a2:	c9 01       	movw	r24, r18
    22a4:	88 0f       	add	r24, r24
    22a6:	99 1f       	adc	r25, r25
    22a8:	88 0f       	add	r24, r24
    22aa:	99 1f       	adc	r25, r25
    22ac:	88 0f       	add	r24, r24
    22ae:	99 1f       	adc	r25, r25
    22b0:	82 0f       	add	r24, r18
    22b2:	93 1f       	adc	r25, r19
    22b4:	ac 01       	movw	r20, r24
    22b6:	46 5e       	subi	r20, 0xE6	; 230
    22b8:	5c 4f       	sbci	r21, 0xFC	; 252
    22ba:	8a 81       	ldd	r24, Y+2	; 0x02
    22bc:	9b 81       	ldd	r25, Y+3	; 0x03
    22be:	9c 01       	movw	r18, r24
    22c0:	2e 5f       	subi	r18, 0xFE	; 254
    22c2:	3f 4f       	sbci	r19, 0xFF	; 255
    22c4:	ca 01       	movw	r24, r20
    22c6:	b9 01       	movw	r22, r18
    22c8:	0e 94 2f 04 	call	0x85e	; 0x85e <vListInsertEnd>
    22cc:	0a c0       	rjmp	.+20     	; 0x22e2 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    22ce:	8a 81       	ldd	r24, Y+2	; 0x02
    22d0:	9b 81       	ldd	r25, Y+3	; 0x03
    22d2:	9c 01       	movw	r18, r24
    22d4:	24 5f       	subi	r18, 0xF4	; 244
    22d6:	3f 4f       	sbci	r19, 0xFF	; 255
    22d8:	8d e5       	ldi	r24, 0x5D	; 93
    22da:	93 e0       	ldi	r25, 0x03	; 3
    22dc:	b9 01       	movw	r22, r18
    22de:	0e 94 2f 04 	call	0x85e	; 0x85e <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    22e2:	ea 81       	ldd	r30, Y+2	; 0x02
    22e4:	fb 81       	ldd	r31, Y+3	; 0x03
    22e6:	96 89       	ldd	r25, Z+22	; 0x16
    22e8:	e0 91 0c 03 	lds	r30, 0x030C
    22ec:	f0 91 0d 03 	lds	r31, 0x030D
    22f0:	86 89       	ldd	r24, Z+22	; 0x16
    22f2:	98 17       	cp	r25, r24
    22f4:	18 f0       	brcs	.+6      	; 0x22fc <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    22f6:	81 e0       	ldi	r24, 0x01	; 1
    22f8:	89 83       	std	Y+1, r24	; 0x01
    22fa:	01 c0       	rjmp	.+2      	; 0x22fe <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    22fc:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    22fe:	89 81       	ldd	r24, Y+1	; 0x01
}
    2300:	0f 90       	pop	r0
    2302:	0f 90       	pop	r0
    2304:	0f 90       	pop	r0
    2306:	0f 90       	pop	r0
    2308:	0f 90       	pop	r0
    230a:	cf 91       	pop	r28
    230c:	df 91       	pop	r29
    230e:	08 95       	ret

00002310 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2310:	df 93       	push	r29
    2312:	cf 93       	push	r28
    2314:	00 d0       	rcall	.+0      	; 0x2316 <vTaskSetTimeOutState+0x6>
    2316:	cd b7       	in	r28, 0x3d	; 61
    2318:	de b7       	in	r29, 0x3e	; 62
    231a:	9a 83       	std	Y+2, r25	; 0x02
    231c:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    231e:	80 91 18 03 	lds	r24, 0x0318
    2322:	e9 81       	ldd	r30, Y+1	; 0x01
    2324:	fa 81       	ldd	r31, Y+2	; 0x02
    2326:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2328:	80 91 10 03 	lds	r24, 0x0310
    232c:	90 91 11 03 	lds	r25, 0x0311
    2330:	e9 81       	ldd	r30, Y+1	; 0x01
    2332:	fa 81       	ldd	r31, Y+2	; 0x02
    2334:	92 83       	std	Z+2, r25	; 0x02
    2336:	81 83       	std	Z+1, r24	; 0x01
}
    2338:	0f 90       	pop	r0
    233a:	0f 90       	pop	r0
    233c:	cf 91       	pop	r28
    233e:	df 91       	pop	r29
    2340:	08 95       	ret

00002342 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    2342:	df 93       	push	r29
    2344:	cf 93       	push	r28
    2346:	00 d0       	rcall	.+0      	; 0x2348 <xTaskCheckForTimeOut+0x6>
    2348:	00 d0       	rcall	.+0      	; 0x234a <xTaskCheckForTimeOut+0x8>
    234a:	0f 92       	push	r0
    234c:	cd b7       	in	r28, 0x3d	; 61
    234e:	de b7       	in	r29, 0x3e	; 62
    2350:	9b 83       	std	Y+3, r25	; 0x03
    2352:	8a 83       	std	Y+2, r24	; 0x02
    2354:	7d 83       	std	Y+5, r23	; 0x05
    2356:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2358:	0f b6       	in	r0, 0x3f	; 63
    235a:	f8 94       	cli
    235c:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    235e:	ea 81       	ldd	r30, Y+2	; 0x02
    2360:	fb 81       	ldd	r31, Y+3	; 0x03
    2362:	90 81       	ld	r25, Z
    2364:	80 91 18 03 	lds	r24, 0x0318
    2368:	98 17       	cp	r25, r24
    236a:	71 f0       	breq	.+28     	; 0x2388 <xTaskCheckForTimeOut+0x46>
    236c:	ea 81       	ldd	r30, Y+2	; 0x02
    236e:	fb 81       	ldd	r31, Y+3	; 0x03
    2370:	21 81       	ldd	r18, Z+1	; 0x01
    2372:	32 81       	ldd	r19, Z+2	; 0x02
    2374:	80 91 10 03 	lds	r24, 0x0310
    2378:	90 91 11 03 	lds	r25, 0x0311
    237c:	82 17       	cp	r24, r18
    237e:	93 07       	cpc	r25, r19
    2380:	18 f0       	brcs	.+6      	; 0x2388 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2382:	81 e0       	ldi	r24, 0x01	; 1
    2384:	89 83       	std	Y+1, r24	; 0x01
    2386:	2f c0       	rjmp	.+94     	; 0x23e6 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    2388:	20 91 10 03 	lds	r18, 0x0310
    238c:	30 91 11 03 	lds	r19, 0x0311
    2390:	ea 81       	ldd	r30, Y+2	; 0x02
    2392:	fb 81       	ldd	r31, Y+3	; 0x03
    2394:	81 81       	ldd	r24, Z+1	; 0x01
    2396:	92 81       	ldd	r25, Z+2	; 0x02
    2398:	28 1b       	sub	r18, r24
    239a:	39 0b       	sbc	r19, r25
    239c:	ec 81       	ldd	r30, Y+4	; 0x04
    239e:	fd 81       	ldd	r31, Y+5	; 0x05
    23a0:	80 81       	ld	r24, Z
    23a2:	91 81       	ldd	r25, Z+1	; 0x01
    23a4:	28 17       	cp	r18, r24
    23a6:	39 07       	cpc	r19, r25
    23a8:	e0 f4       	brcc	.+56     	; 0x23e2 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    23aa:	ec 81       	ldd	r30, Y+4	; 0x04
    23ac:	fd 81       	ldd	r31, Y+5	; 0x05
    23ae:	40 81       	ld	r20, Z
    23b0:	51 81       	ldd	r21, Z+1	; 0x01
    23b2:	ea 81       	ldd	r30, Y+2	; 0x02
    23b4:	fb 81       	ldd	r31, Y+3	; 0x03
    23b6:	21 81       	ldd	r18, Z+1	; 0x01
    23b8:	32 81       	ldd	r19, Z+2	; 0x02
    23ba:	80 91 10 03 	lds	r24, 0x0310
    23be:	90 91 11 03 	lds	r25, 0x0311
    23c2:	b9 01       	movw	r22, r18
    23c4:	68 1b       	sub	r22, r24
    23c6:	79 0b       	sbc	r23, r25
    23c8:	cb 01       	movw	r24, r22
    23ca:	84 0f       	add	r24, r20
    23cc:	95 1f       	adc	r25, r21
    23ce:	ec 81       	ldd	r30, Y+4	; 0x04
    23d0:	fd 81       	ldd	r31, Y+5	; 0x05
    23d2:	91 83       	std	Z+1, r25	; 0x01
    23d4:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    23d6:	8a 81       	ldd	r24, Y+2	; 0x02
    23d8:	9b 81       	ldd	r25, Y+3	; 0x03
    23da:	0e 94 88 11 	call	0x2310	; 0x2310 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    23de:	19 82       	std	Y+1, r1	; 0x01
    23e0:	02 c0       	rjmp	.+4      	; 0x23e6 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    23e2:	81 e0       	ldi	r24, 0x01	; 1
    23e4:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    23e6:	0f 90       	pop	r0
    23e8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    23ea:	89 81       	ldd	r24, Y+1	; 0x01
}
    23ec:	0f 90       	pop	r0
    23ee:	0f 90       	pop	r0
    23f0:	0f 90       	pop	r0
    23f2:	0f 90       	pop	r0
    23f4:	0f 90       	pop	r0
    23f6:	cf 91       	pop	r28
    23f8:	df 91       	pop	r29
    23fa:	08 95       	ret

000023fc <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    23fc:	df 93       	push	r29
    23fe:	cf 93       	push	r28
    2400:	cd b7       	in	r28, 0x3d	; 61
    2402:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    2404:	81 e0       	ldi	r24, 0x01	; 1
    2406:	80 93 17 03 	sts	0x0317, r24
}
    240a:	cf 91       	pop	r28
    240c:	df 91       	pop	r29
    240e:	08 95       	ret

00002410 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2410:	df 93       	push	r29
    2412:	cf 93       	push	r28
    2414:	00 d0       	rcall	.+0      	; 0x2416 <prvIdleTask+0x6>
    2416:	cd b7       	in	r28, 0x3d	; 61
    2418:	de b7       	in	r29, 0x3e	; 62
    241a:	9a 83       	std	Y+2, r25	; 0x02
    241c:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    241e:	0e 94 a8 12 	call	0x2550	; 0x2550 <prvCheckTasksWaitingTermination>
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
    2422:	0e 94 ef 06 	call	0xdde	; 0xdde <vPortYield>
    2426:	fb cf       	rjmp	.-10     	; 0x241e <prvIdleTask+0xe>

00002428 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    2428:	0f 93       	push	r16
    242a:	1f 93       	push	r17
    242c:	df 93       	push	r29
    242e:	cf 93       	push	r28
    2430:	cd b7       	in	r28, 0x3d	; 61
    2432:	de b7       	in	r29, 0x3e	; 62
    2434:	29 97       	sbiw	r28, 0x09	; 9
    2436:	0f b6       	in	r0, 0x3f	; 63
    2438:	f8 94       	cli
    243a:	de bf       	out	0x3e, r29	; 62
    243c:	0f be       	out	0x3f, r0	; 63
    243e:	cd bf       	out	0x3d, r28	; 61
    2440:	9a 83       	std	Y+2, r25	; 0x02
    2442:	89 83       	std	Y+1, r24	; 0x01
    2444:	7c 83       	std	Y+4, r23	; 0x04
    2446:	6b 83       	std	Y+3, r22	; 0x03
    2448:	4d 83       	std	Y+5, r20	; 0x05
    244a:	3f 83       	std	Y+7, r19	; 0x07
    244c:	2e 83       	std	Y+6, r18	; 0x06
    244e:	19 87       	std	Y+9, r17	; 0x09
    2450:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2452:	89 81       	ldd	r24, Y+1	; 0x01
    2454:	9a 81       	ldd	r25, Y+2	; 0x02
    2456:	49 96       	adiw	r24, 0x19	; 25
    2458:	2b 81       	ldd	r18, Y+3	; 0x03
    245a:	3c 81       	ldd	r19, Y+4	; 0x04
    245c:	b9 01       	movw	r22, r18
    245e:	48 e0       	ldi	r20, 0x08	; 8
    2460:	50 e0       	ldi	r21, 0x00	; 0
    2462:	0e 94 a5 13 	call	0x274a	; 0x274a <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    2466:	e9 81       	ldd	r30, Y+1	; 0x01
    2468:	fa 81       	ldd	r31, Y+2	; 0x02
    246a:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    246c:	8d 81       	ldd	r24, Y+5	; 0x05
    246e:	85 30       	cpi	r24, 0x05	; 5
    2470:	10 f0       	brcs	.+4      	; 0x2476 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    2472:	84 e0       	ldi	r24, 0x04	; 4
    2474:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    2476:	e9 81       	ldd	r30, Y+1	; 0x01
    2478:	fa 81       	ldd	r31, Y+2	; 0x02
    247a:	8d 81       	ldd	r24, Y+5	; 0x05
    247c:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    247e:	89 81       	ldd	r24, Y+1	; 0x01
    2480:	9a 81       	ldd	r25, Y+2	; 0x02
    2482:	02 96       	adiw	r24, 0x02	; 2
    2484:	0e 94 1f 04 	call	0x83e	; 0x83e <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2488:	89 81       	ldd	r24, Y+1	; 0x01
    248a:	9a 81       	ldd	r25, Y+2	; 0x02
    248c:	0c 96       	adiw	r24, 0x0c	; 12
    248e:	0e 94 1f 04 	call	0x83e	; 0x83e <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2492:	e9 81       	ldd	r30, Y+1	; 0x01
    2494:	fa 81       	ldd	r31, Y+2	; 0x02
    2496:	89 81       	ldd	r24, Y+1	; 0x01
    2498:	9a 81       	ldd	r25, Y+2	; 0x02
    249a:	91 87       	std	Z+9, r25	; 0x09
    249c:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    249e:	8d 81       	ldd	r24, Y+5	; 0x05
    24a0:	28 2f       	mov	r18, r24
    24a2:	30 e0       	ldi	r19, 0x00	; 0
    24a4:	85 e0       	ldi	r24, 0x05	; 5
    24a6:	90 e0       	ldi	r25, 0x00	; 0
    24a8:	82 1b       	sub	r24, r18
    24aa:	93 0b       	sbc	r25, r19
    24ac:	e9 81       	ldd	r30, Y+1	; 0x01
    24ae:	fa 81       	ldd	r31, Y+2	; 0x02
    24b0:	95 87       	std	Z+13, r25	; 0x0d
    24b2:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    24b4:	e9 81       	ldd	r30, Y+1	; 0x01
    24b6:	fa 81       	ldd	r31, Y+2	; 0x02
    24b8:	89 81       	ldd	r24, Y+1	; 0x01
    24ba:	9a 81       	ldd	r25, Y+2	; 0x02
    24bc:	93 8b       	std	Z+19, r25	; 0x13
    24be:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    24c0:	29 96       	adiw	r28, 0x09	; 9
    24c2:	0f b6       	in	r0, 0x3f	; 63
    24c4:	f8 94       	cli
    24c6:	de bf       	out	0x3e, r29	; 62
    24c8:	0f be       	out	0x3f, r0	; 63
    24ca:	cd bf       	out	0x3d, r28	; 61
    24cc:	cf 91       	pop	r28
    24ce:	df 91       	pop	r29
    24d0:	1f 91       	pop	r17
    24d2:	0f 91       	pop	r16
    24d4:	08 95       	ret

000024d6 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    24d6:	df 93       	push	r29
    24d8:	cf 93       	push	r28
    24da:	0f 92       	push	r0
    24dc:	cd b7       	in	r28, 0x3d	; 61
    24de:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    24e0:	19 82       	std	Y+1, r1	; 0x01
    24e2:	13 c0       	rjmp	.+38     	; 0x250a <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    24e4:	89 81       	ldd	r24, Y+1	; 0x01
    24e6:	28 2f       	mov	r18, r24
    24e8:	30 e0       	ldi	r19, 0x00	; 0
    24ea:	c9 01       	movw	r24, r18
    24ec:	88 0f       	add	r24, r24
    24ee:	99 1f       	adc	r25, r25
    24f0:	88 0f       	add	r24, r24
    24f2:	99 1f       	adc	r25, r25
    24f4:	88 0f       	add	r24, r24
    24f6:	99 1f       	adc	r25, r25
    24f8:	82 0f       	add	r24, r18
    24fa:	93 1f       	adc	r25, r19
    24fc:	86 5e       	subi	r24, 0xE6	; 230
    24fe:	9c 4f       	sbci	r25, 0xFC	; 252
    2500:	0e 94 f5 03 	call	0x7ea	; 0x7ea <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2504:	89 81       	ldd	r24, Y+1	; 0x01
    2506:	8f 5f       	subi	r24, 0xFF	; 255
    2508:	89 83       	std	Y+1, r24	; 0x01
    250a:	89 81       	ldd	r24, Y+1	; 0x01
    250c:	85 30       	cpi	r24, 0x05	; 5
    250e:	50 f3       	brcs	.-44     	; 0x24e4 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2510:	87 e4       	ldi	r24, 0x47	; 71
    2512:	93 e0       	ldi	r25, 0x03	; 3
    2514:	0e 94 f5 03 	call	0x7ea	; 0x7ea <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2518:	80 e5       	ldi	r24, 0x50	; 80
    251a:	93 e0       	ldi	r25, 0x03	; 3
    251c:	0e 94 f5 03 	call	0x7ea	; 0x7ea <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    2520:	8d e5       	ldi	r24, 0x5D	; 93
    2522:	93 e0       	ldi	r25, 0x03	; 3
    2524:	0e 94 f5 03 	call	0x7ea	; 0x7ea <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    2528:	86 e6       	ldi	r24, 0x66	; 102
    252a:	93 e0       	ldi	r25, 0x03	; 3
    252c:	0e 94 f5 03 	call	0x7ea	; 0x7ea <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2530:	87 e4       	ldi	r24, 0x47	; 71
    2532:	93 e0       	ldi	r25, 0x03	; 3
    2534:	90 93 5a 03 	sts	0x035A, r25
    2538:	80 93 59 03 	sts	0x0359, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    253c:	80 e5       	ldi	r24, 0x50	; 80
    253e:	93 e0       	ldi	r25, 0x03	; 3
    2540:	90 93 5c 03 	sts	0x035C, r25
    2544:	80 93 5b 03 	sts	0x035B, r24
}
    2548:	0f 90       	pop	r0
    254a:	cf 91       	pop	r28
    254c:	df 91       	pop	r29
    254e:	08 95       	ret

00002550 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    2550:	df 93       	push	r29
    2552:	cf 93       	push	r28
    2554:	00 d0       	rcall	.+0      	; 0x2556 <prvCheckTasksWaitingTermination+0x6>
    2556:	0f 92       	push	r0
    2558:	cd b7       	in	r28, 0x3d	; 61
    255a:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    255c:	80 91 0e 03 	lds	r24, 0x030E
    2560:	88 23       	and	r24, r24
    2562:	71 f1       	breq	.+92     	; 0x25c0 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    2564:	0e 94 e6 0e 	call	0x1dcc	; 0x1dcc <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2568:	80 91 66 03 	lds	r24, 0x0366
    256c:	1b 82       	std	Y+3, r1	; 0x03
    256e:	88 23       	and	r24, r24
    2570:	11 f4       	brne	.+4      	; 0x2576 <prvCheckTasksWaitingTermination+0x26>
    2572:	81 e0       	ldi	r24, 0x01	; 1
    2574:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    2576:	0e 94 f2 0e 	call	0x1de4	; 0x1de4 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    257a:	8b 81       	ldd	r24, Y+3	; 0x03
    257c:	88 23       	and	r24, r24
    257e:	01 f5       	brne	.+64     	; 0x25c0 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    2580:	0f b6       	in	r0, 0x3f	; 63
    2582:	f8 94       	cli
    2584:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    2586:	e0 91 6b 03 	lds	r30, 0x036B
    258a:	f0 91 6c 03 	lds	r31, 0x036C
    258e:	86 81       	ldd	r24, Z+6	; 0x06
    2590:	97 81       	ldd	r25, Z+7	; 0x07
    2592:	9a 83       	std	Y+2, r25	; 0x02
    2594:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    2596:	89 81       	ldd	r24, Y+1	; 0x01
    2598:	9a 81       	ldd	r25, Y+2	; 0x02
    259a:	02 96       	adiw	r24, 0x02	; 2
    259c:	0e 94 e7 04 	call	0x9ce	; 0x9ce <vListRemove>
					--uxCurrentNumberOfTasks;
    25a0:	80 91 0f 03 	lds	r24, 0x030F
    25a4:	81 50       	subi	r24, 0x01	; 1
    25a6:	80 93 0f 03 	sts	0x030F, r24
					--uxTasksDeleted;
    25aa:	80 91 0e 03 	lds	r24, 0x030E
    25ae:	81 50       	subi	r24, 0x01	; 1
    25b0:	80 93 0e 03 	sts	0x030E, r24
				}
				taskEXIT_CRITICAL();
    25b4:	0f 90       	pop	r0
    25b6:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    25b8:	89 81       	ldd	r24, Y+1	; 0x01
    25ba:	9a 81       	ldd	r25, Y+2	; 0x02
    25bc:	0e 94 7f 13 	call	0x26fe	; 0x26fe <prvDeleteTCB>
			}
		}
	}
	#endif
}
    25c0:	0f 90       	pop	r0
    25c2:	0f 90       	pop	r0
    25c4:	0f 90       	pop	r0
    25c6:	cf 91       	pop	r28
    25c8:	df 91       	pop	r29
    25ca:	08 95       	ret

000025cc <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    25cc:	df 93       	push	r29
    25ce:	cf 93       	push	r28
    25d0:	00 d0       	rcall	.+0      	; 0x25d2 <prvAddCurrentTaskToDelayedList+0x6>
    25d2:	cd b7       	in	r28, 0x3d	; 61
    25d4:	de b7       	in	r29, 0x3e	; 62
    25d6:	9a 83       	std	Y+2, r25	; 0x02
    25d8:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    25da:	e0 91 0c 03 	lds	r30, 0x030C
    25de:	f0 91 0d 03 	lds	r31, 0x030D
    25e2:	89 81       	ldd	r24, Y+1	; 0x01
    25e4:	9a 81       	ldd	r25, Y+2	; 0x02
    25e6:	93 83       	std	Z+3, r25	; 0x03
    25e8:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    25ea:	20 91 10 03 	lds	r18, 0x0310
    25ee:	30 91 11 03 	lds	r19, 0x0311
    25f2:	89 81       	ldd	r24, Y+1	; 0x01
    25f4:	9a 81       	ldd	r25, Y+2	; 0x02
    25f6:	82 17       	cp	r24, r18
    25f8:	93 07       	cpc	r25, r19
    25fa:	70 f4       	brcc	.+28     	; 0x2618 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    25fc:	80 91 5b 03 	lds	r24, 0x035B
    2600:	90 91 5c 03 	lds	r25, 0x035C
    2604:	20 91 0c 03 	lds	r18, 0x030C
    2608:	30 91 0d 03 	lds	r19, 0x030D
    260c:	2e 5f       	subi	r18, 0xFE	; 254
    260e:	3f 4f       	sbci	r19, 0xFF	; 255
    2610:	b9 01       	movw	r22, r18
    2612:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <vListInsert>
    2616:	1e c0       	rjmp	.+60     	; 0x2654 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2618:	40 91 59 03 	lds	r20, 0x0359
    261c:	50 91 5a 03 	lds	r21, 0x035A
    2620:	80 91 0c 03 	lds	r24, 0x030C
    2624:	90 91 0d 03 	lds	r25, 0x030D
    2628:	9c 01       	movw	r18, r24
    262a:	2e 5f       	subi	r18, 0xFE	; 254
    262c:	3f 4f       	sbci	r19, 0xFF	; 255
    262e:	ca 01       	movw	r24, r20
    2630:	b9 01       	movw	r22, r18
    2632:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    2636:	20 91 71 00 	lds	r18, 0x0071
    263a:	30 91 72 00 	lds	r19, 0x0072
    263e:	89 81       	ldd	r24, Y+1	; 0x01
    2640:	9a 81       	ldd	r25, Y+2	; 0x02
    2642:	82 17       	cp	r24, r18
    2644:	93 07       	cpc	r25, r19
    2646:	30 f4       	brcc	.+12     	; 0x2654 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    2648:	89 81       	ldd	r24, Y+1	; 0x01
    264a:	9a 81       	ldd	r25, Y+2	; 0x02
    264c:	90 93 72 00 	sts	0x0072, r25
    2650:	80 93 71 00 	sts	0x0071, r24
		}
	}
}
    2654:	0f 90       	pop	r0
    2656:	0f 90       	pop	r0
    2658:	cf 91       	pop	r28
    265a:	df 91       	pop	r29
    265c:	08 95       	ret

0000265e <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    265e:	df 93       	push	r29
    2660:	cf 93       	push	r28
    2662:	cd b7       	in	r28, 0x3d	; 61
    2664:	de b7       	in	r29, 0x3e	; 62
    2666:	28 97       	sbiw	r28, 0x08	; 8
    2668:	0f b6       	in	r0, 0x3f	; 63
    266a:	f8 94       	cli
    266c:	de bf       	out	0x3e, r29	; 62
    266e:	0f be       	out	0x3f, r0	; 63
    2670:	cd bf       	out	0x3d, r28	; 61
    2672:	9c 83       	std	Y+4, r25	; 0x04
    2674:	8b 83       	std	Y+3, r24	; 0x03
    2676:	7e 83       	std	Y+6, r23	; 0x06
    2678:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    267a:	81 e2       	ldi	r24, 0x21	; 33
    267c:	90 e0       	ldi	r25, 0x00	; 0
    267e:	0e 94 89 03 	call	0x712	; 0x712 <pvPortMalloc>
    2682:	9a 83       	std	Y+2, r25	; 0x02
    2684:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    2686:	89 81       	ldd	r24, Y+1	; 0x01
    2688:	9a 81       	ldd	r25, Y+2	; 0x02
    268a:	00 97       	sbiw	r24, 0x00	; 0
    268c:	69 f1       	breq	.+90     	; 0x26e8 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    268e:	8d 81       	ldd	r24, Y+5	; 0x05
    2690:	9e 81       	ldd	r25, Y+6	; 0x06
    2692:	00 97       	sbiw	r24, 0x00	; 0
    2694:	39 f4       	brne	.+14     	; 0x26a4 <prvAllocateTCBAndStack+0x46>
    2696:	8b 81       	ldd	r24, Y+3	; 0x03
    2698:	9c 81       	ldd	r25, Y+4	; 0x04
    269a:	0e 94 89 03 	call	0x712	; 0x712 <pvPortMalloc>
    269e:	98 87       	std	Y+8, r25	; 0x08
    26a0:	8f 83       	std	Y+7, r24	; 0x07
    26a2:	04 c0       	rjmp	.+8      	; 0x26ac <prvAllocateTCBAndStack+0x4e>
    26a4:	8d 81       	ldd	r24, Y+5	; 0x05
    26a6:	9e 81       	ldd	r25, Y+6	; 0x06
    26a8:	98 87       	std	Y+8, r25	; 0x08
    26aa:	8f 83       	std	Y+7, r24	; 0x07
    26ac:	e9 81       	ldd	r30, Y+1	; 0x01
    26ae:	fa 81       	ldd	r31, Y+2	; 0x02
    26b0:	8f 81       	ldd	r24, Y+7	; 0x07
    26b2:	98 85       	ldd	r25, Y+8	; 0x08
    26b4:	90 8f       	std	Z+24, r25	; 0x18
    26b6:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    26b8:	e9 81       	ldd	r30, Y+1	; 0x01
    26ba:	fa 81       	ldd	r31, Y+2	; 0x02
    26bc:	87 89       	ldd	r24, Z+23	; 0x17
    26be:	90 8d       	ldd	r25, Z+24	; 0x18
    26c0:	00 97       	sbiw	r24, 0x00	; 0
    26c2:	39 f4       	brne	.+14     	; 0x26d2 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    26c4:	89 81       	ldd	r24, Y+1	; 0x01
    26c6:	9a 81       	ldd	r25, Y+2	; 0x02
    26c8:	0e 94 cf 03 	call	0x79e	; 0x79e <vPortFree>
			pxNewTCB = NULL;
    26cc:	1a 82       	std	Y+2, r1	; 0x02
    26ce:	19 82       	std	Y+1, r1	; 0x01
    26d0:	0b c0       	rjmp	.+22     	; 0x26e8 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    26d2:	e9 81       	ldd	r30, Y+1	; 0x01
    26d4:	fa 81       	ldd	r31, Y+2	; 0x02
    26d6:	87 89       	ldd	r24, Z+23	; 0x17
    26d8:	90 8d       	ldd	r25, Z+24	; 0x18
    26da:	2b 81       	ldd	r18, Y+3	; 0x03
    26dc:	3c 81       	ldd	r19, Y+4	; 0x04
    26de:	65 ea       	ldi	r22, 0xA5	; 165
    26e0:	70 e0       	ldi	r23, 0x00	; 0
    26e2:	a9 01       	movw	r20, r18
    26e4:	0e 94 9e 13 	call	0x273c	; 0x273c <memset>
		}
	}

	return pxNewTCB;
    26e8:	89 81       	ldd	r24, Y+1	; 0x01
    26ea:	9a 81       	ldd	r25, Y+2	; 0x02
}
    26ec:	28 96       	adiw	r28, 0x08	; 8
    26ee:	0f b6       	in	r0, 0x3f	; 63
    26f0:	f8 94       	cli
    26f2:	de bf       	out	0x3e, r29	; 62
    26f4:	0f be       	out	0x3f, r0	; 63
    26f6:	cd bf       	out	0x3d, r28	; 61
    26f8:	cf 91       	pop	r28
    26fa:	df 91       	pop	r29
    26fc:	08 95       	ret

000026fe <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    26fe:	df 93       	push	r29
    2700:	cf 93       	push	r28
    2702:	00 d0       	rcall	.+0      	; 0x2704 <prvDeleteTCB+0x6>
    2704:	cd b7       	in	r28, 0x3d	; 61
    2706:	de b7       	in	r29, 0x3e	; 62
    2708:	9a 83       	std	Y+2, r25	; 0x02
    270a:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    270c:	e9 81       	ldd	r30, Y+1	; 0x01
    270e:	fa 81       	ldd	r31, Y+2	; 0x02
    2710:	87 89       	ldd	r24, Z+23	; 0x17
    2712:	90 8d       	ldd	r25, Z+24	; 0x18
    2714:	0e 94 cf 03 	call	0x79e	; 0x79e <vPortFree>
		vPortFree( pxTCB );
    2718:	89 81       	ldd	r24, Y+1	; 0x01
    271a:	9a 81       	ldd	r25, Y+2	; 0x02
    271c:	0e 94 cf 03 	call	0x79e	; 0x79e <vPortFree>
	}
    2720:	0f 90       	pop	r0
    2722:	0f 90       	pop	r0
    2724:	cf 91       	pop	r28
    2726:	df 91       	pop	r29
    2728:	08 95       	ret

0000272a <memcpy>:
    272a:	fb 01       	movw	r30, r22
    272c:	dc 01       	movw	r26, r24
    272e:	02 c0       	rjmp	.+4      	; 0x2734 <memcpy+0xa>
    2730:	01 90       	ld	r0, Z+
    2732:	0d 92       	st	X+, r0
    2734:	41 50       	subi	r20, 0x01	; 1
    2736:	50 40       	sbci	r21, 0x00	; 0
    2738:	d8 f7       	brcc	.-10     	; 0x2730 <memcpy+0x6>
    273a:	08 95       	ret

0000273c <memset>:
    273c:	dc 01       	movw	r26, r24
    273e:	01 c0       	rjmp	.+2      	; 0x2742 <memset+0x6>
    2740:	6d 93       	st	X+, r22
    2742:	41 50       	subi	r20, 0x01	; 1
    2744:	50 40       	sbci	r21, 0x00	; 0
    2746:	e0 f7       	brcc	.-8      	; 0x2740 <memset+0x4>
    2748:	08 95       	ret

0000274a <strncpy>:
    274a:	fb 01       	movw	r30, r22
    274c:	dc 01       	movw	r26, r24
    274e:	41 50       	subi	r20, 0x01	; 1
    2750:	50 40       	sbci	r21, 0x00	; 0
    2752:	48 f0       	brcs	.+18     	; 0x2766 <strncpy+0x1c>
    2754:	01 90       	ld	r0, Z+
    2756:	0d 92       	st	X+, r0
    2758:	00 20       	and	r0, r0
    275a:	c9 f7       	brne	.-14     	; 0x274e <strncpy+0x4>
    275c:	01 c0       	rjmp	.+2      	; 0x2760 <strncpy+0x16>
    275e:	1d 92       	st	X+, r1
    2760:	41 50       	subi	r20, 0x01	; 1
    2762:	50 40       	sbci	r21, 0x00	; 0
    2764:	e0 f7       	brcc	.-8      	; 0x275e <strncpy+0x14>
    2766:	08 95       	ret

00002768 <_exit>:
    2768:	f8 94       	cli

0000276a <__stop_program>:
    276a:	ff cf       	rjmp	.-2      	; 0x276a <__stop_program>
