
RTOS_Task6_ProtectMewithaFlag.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000027d8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000001a  00800060  000027d8  0000286c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002f8  0080007a  0080007a  00002886  2**0
                  ALLOC
  3 .stab         000045f0  00000000  00000000  00002888  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002b38  00000000  00000000  00006e78  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 5c 08 	jmp	0x10b8	; 0x10b8 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 ed       	ldi	r30, 0xD8	; 216
      68:	f7 e2       	ldi	r31, 0x27	; 39
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	aa 37       	cpi	r26, 0x7A	; 122
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	aa e7       	ldi	r26, 0x7A	; 122
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a2 37       	cpi	r26, 0x72	; 114
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 49 00 	call	0x92	; 0x92 <main>
      8a:	0c 94 ea 13 	jmp	0x27d4	; 0x27d4 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <main>:
      92:	af 92       	push	r10
      94:	bf 92       	push	r11
      96:	cf 92       	push	r12
      98:	df 92       	push	r13
      9a:	ef 92       	push	r14
      9c:	ff 92       	push	r15
      9e:	0f 93       	push	r16
      a0:	df 93       	push	r29
      a2:	cf 93       	push	r28
      a4:	00 d0       	rcall	.+0      	; 0xa6 <main+0x14>
      a6:	00 d0       	rcall	.+0      	; 0xa8 <main+0x16>
      a8:	cd b7       	in	r28, 0x3d	; 61
      aa:	de b7       	in	r29, 0x3e	; 62
      ac:	1a 82       	std	Y+2, r1	; 0x02
      ae:	19 82       	std	Y+1, r1	; 0x01
      b0:	20 e6       	ldi	r18, 0x60	; 96
      b2:	30 e0       	ldi	r19, 0x00	; 0
      b4:	86 ea       	ldi	r24, 0xA6	; 166
      b6:	90 e0       	ldi	r25, 0x00	; 0
      b8:	b9 01       	movw	r22, r18
      ba:	45 e5       	ldi	r20, 0x55	; 85
      bc:	50 e0       	ldi	r21, 0x00	; 0
      be:	20 e0       	ldi	r18, 0x00	; 0
      c0:	30 e0       	ldi	r19, 0x00	; 0
      c2:	01 e0       	ldi	r16, 0x01	; 1
      c4:	fe 01       	movw	r30, r28
      c6:	31 96       	adiw	r30, 0x01	; 1
      c8:	7f 01       	movw	r14, r30
      ca:	cc 24       	eor	r12, r12
      cc:	dd 24       	eor	r13, r13
      ce:	aa 24       	eor	r10, r10
      d0:	bb 24       	eor	r11, r11
      d2:	0e 94 e0 0c 	call	0x19c0	; 0x19c0 <xTaskGenericCreate>
      d6:	1c 82       	std	Y+4, r1	; 0x04
      d8:	1b 82       	std	Y+3, r1	; 0x03
      da:	2c e6       	ldi	r18, 0x6C	; 108
      dc:	30 e0       	ldi	r19, 0x00	; 0
      de:	88 ed       	ldi	r24, 0xD8	; 216
      e0:	90 e0       	ldi	r25, 0x00	; 0
      e2:	fe 01       	movw	r30, r28
      e4:	33 96       	adiw	r30, 0x03	; 3
      e6:	b9 01       	movw	r22, r18
      e8:	45 e5       	ldi	r20, 0x55	; 85
      ea:	50 e0       	ldi	r21, 0x00	; 0
      ec:	20 e0       	ldi	r18, 0x00	; 0
      ee:	30 e0       	ldi	r19, 0x00	; 0
      f0:	02 e0       	ldi	r16, 0x02	; 2
      f2:	7f 01       	movw	r14, r30
      f4:	cc 24       	eor	r12, r12
      f6:	dd 24       	eor	r13, r13
      f8:	aa 24       	eor	r10, r10
      fa:	bb 24       	eor	r11, r11
      fc:	0e 94 e0 0c 	call	0x19c0	; 0x19c0 <xTaskGenericCreate>
     100:	0e 94 94 00 	call	0x128	; 0x128 <init>
     104:	0e 94 d9 0e 	call	0x1db2	; 0x1db2 <vTaskStartScheduler>
     108:	80 e0       	ldi	r24, 0x00	; 0
     10a:	90 e0       	ldi	r25, 0x00	; 0
     10c:	0f 90       	pop	r0
     10e:	0f 90       	pop	r0
     110:	0f 90       	pop	r0
     112:	0f 90       	pop	r0
     114:	cf 91       	pop	r28
     116:	df 91       	pop	r29
     118:	0f 91       	pop	r16
     11a:	ff 90       	pop	r15
     11c:	ef 90       	pop	r14
     11e:	df 90       	pop	r13
     120:	cf 90       	pop	r12
     122:	bf 90       	pop	r11
     124:	af 90       	pop	r10
     126:	08 95       	ret

00000128 <init>:

	/*Never Enter Here */
	return 0;
}

void init(void){
     128:	df 93       	push	r29
     12a:	cf 93       	push	r28
     12c:	cd b7       	in	r28, 0x3d	; 61
     12e:	de b7       	in	r29, 0x3e	; 62

	DDRB = 0xFF;
     130:	e7 e3       	ldi	r30, 0x37	; 55
     132:	f0 e0       	ldi	r31, 0x00	; 0
     134:	8f ef       	ldi	r24, 0xFF	; 255
     136:	80 83       	st	Z, r24

	DDRC = 0x00;
     138:	e4 e3       	ldi	r30, 0x34	; 52
     13a:	f0 e0       	ldi	r31, 0x00	; 0
     13c:	10 82       	st	Z, r1

	PORTC = 0xFF;
     13e:	e5 e3       	ldi	r30, 0x35	; 53
     140:	f0 e0       	ldi	r31, 0x00	; 0
     142:	8f ef       	ldi	r24, 0xFF	; 255
     144:	80 83       	st	Z, r24

}
     146:	cf 91       	pop	r28
     148:	df 91       	pop	r29
     14a:	08 95       	ret

0000014c <PushButton>:
 void PushButton(void * pvparam){
     14c:	df 93       	push	r29
     14e:	cf 93       	push	r28
     150:	00 d0       	rcall	.+0      	; 0x152 <PushButton+0x6>
     152:	00 d0       	rcall	.+0      	; 0x154 <PushButton+0x8>
     154:	00 d0       	rcall	.+0      	; 0x156 <PushButton+0xa>
     156:	cd b7       	in	r28, 0x3d	; 61
     158:	de b7       	in	r29, 0x3e	; 62
     15a:	9e 83       	std	Y+6, r25	; 0x06
     15c:	8d 83       	std	Y+5, r24	; 0x05
	 portTickType Freq = 50;
     15e:	82 e3       	ldi	r24, 0x32	; 50
     160:	90 e0       	ldi	r25, 0x00	; 0
     162:	9a 83       	std	Y+2, r25	; 0x02
     164:	89 83       	std	Y+1, r24	; 0x01
	 portTickType Start = xTaskGetTickCount();
     166:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <xTaskGetTickCount>
     16a:	9c 83       	std	Y+4, r25	; 0x04
     16c:	8b 83       	std	Y+3, r24	; 0x03
	 while (1){
		 /* if the Push Button is Pressed */
		 if ((PINC & 0x01) == 0){
     16e:	e3 e3       	ldi	r30, 0x33	; 51
     170:	f0 e0       	ldi	r31, 0x00	; 0
     172:	80 81       	ld	r24, Z
     174:	88 2f       	mov	r24, r24
     176:	90 e0       	ldi	r25, 0x00	; 0
     178:	81 70       	andi	r24, 0x01	; 1
     17a:	90 70       	andi	r25, 0x00	; 0
     17c:	00 97       	sbiw	r24, 0x00	; 0
     17e:	81 f4       	brne	.+32     	; 0x1a0 <PushButton+0x54>

			 /* If the Resource No One is Using so Raise a Flag to Use it **/
			 if(ButtonStateFlag == 0){
     180:	80 91 7a 00 	lds	r24, 0x007A
     184:	88 23       	and	r24, r24
     186:	41 f4       	brne	.+16     	; 0x198 <PushButton+0x4c>
				 /*Raise the Flag */
				 ButtonStateFlag = 1;
     188:	81 e0       	ldi	r24, 0x01	; 1
     18a:	80 93 7a 00 	sts	0x007A, r24

				 /*Change the State **/
				 ButtonState = 0;
     18e:	10 92 76 00 	sts	0x0076, r1

				 /*Release the Flag */
				 ButtonStateFlag = 0;
     192:	10 92 7a 00 	sts	0x007A, r1
     196:	04 c0       	rjmp	.+8      	; 0x1a0 <PushButton+0x54>
			 }
			 /*Else Delay 10 Tick till the Resource is Free **/
			 else {
				 vTaskDelay(10);
     198:	8a e0       	ldi	r24, 0x0A	; 10
     19a:	90 e0       	ldi	r25, 0x00	; 0
     19c:	0e 94 a4 0e 	call	0x1d48	; 0x1d48 <vTaskDelay>
			 }

		 }

		 /*Make the Task Periodic with Period 50 Tick */
		 vTaskDelayUntil(&Start,Freq);
     1a0:	ce 01       	movw	r24, r28
     1a2:	03 96       	adiw	r24, 0x03	; 3
     1a4:	29 81       	ldd	r18, Y+1	; 0x01
     1a6:	3a 81       	ldd	r19, Y+2	; 0x02
     1a8:	b9 01       	movw	r22, r18
     1aa:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <vTaskDelayUntil>
     1ae:	df cf       	rjmp	.-66     	; 0x16e <PushButton+0x22>

000001b0 <Led>:
	 }

 }


 void Led(void * pvparam){
     1b0:	df 93       	push	r29
     1b2:	cf 93       	push	r28
     1b4:	00 d0       	rcall	.+0      	; 0x1b6 <Led+0x6>
     1b6:	00 d0       	rcall	.+0      	; 0x1b8 <Led+0x8>
     1b8:	00 d0       	rcall	.+0      	; 0x1ba <Led+0xa>
     1ba:	cd b7       	in	r28, 0x3d	; 61
     1bc:	de b7       	in	r29, 0x3e	; 62
     1be:	9e 83       	std	Y+6, r25	; 0x06
     1c0:	8d 83       	std	Y+5, r24	; 0x05
	 portTickType Freq = 50;
     1c2:	82 e3       	ldi	r24, 0x32	; 50
     1c4:	90 e0       	ldi	r25, 0x00	; 0
     1c6:	9a 83       	std	Y+2, r25	; 0x02
     1c8:	89 83       	std	Y+1, r24	; 0x01
	 portTickType Start = xTaskGetTickCount();
     1ca:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <xTaskGetTickCount>
     1ce:	9c 83       	std	Y+4, r25	; 0x04
     1d0:	8b 83       	std	Y+3, r24	; 0x03
	 while (1){
		 /* if the Push Button is Pressed */


		 /* If the Resource No One is Using so Raise a Flag to Use it **/
		 if(ButtonStateFlag == 0){
     1d2:	80 91 7a 00 	lds	r24, 0x007A
     1d6:	88 23       	and	r24, r24
     1d8:	a9 f4       	brne	.+42     	; 0x204 <Led+0x54>

			 /*Raise the Flag */
			 ButtonStateFlag = 1;
     1da:	81 e0       	ldi	r24, 0x01	; 1
     1dc:	80 93 7a 00 	sts	0x007A, r24

			 if (ButtonState == 0){
     1e0:	80 91 76 00 	lds	r24, 0x0076
     1e4:	88 23       	and	r24, r24
     1e6:	59 f4       	brne	.+22     	; 0x1fe <Led+0x4e>
				 PORTB ^= 0x01;
     1e8:	a8 e3       	ldi	r26, 0x38	; 56
     1ea:	b0 e0       	ldi	r27, 0x00	; 0
     1ec:	e8 e3       	ldi	r30, 0x38	; 56
     1ee:	f0 e0       	ldi	r31, 0x00	; 0
     1f0:	90 81       	ld	r25, Z
     1f2:	81 e0       	ldi	r24, 0x01	; 1
     1f4:	89 27       	eor	r24, r25
     1f6:	8c 93       	st	X, r24
				 ButtonState = 1;
     1f8:	81 e0       	ldi	r24, 0x01	; 1
     1fa:	80 93 76 00 	sts	0x0076, r24
			 }

			 /*Release the Flag */
			 ButtonStateFlag = 0;
     1fe:	10 92 7a 00 	sts	0x007A, r1
     202:	04 c0       	rjmp	.+8      	; 0x20c <Led+0x5c>
		 }
		 /*Else Delay 10 Tick till the Resource is Free **/
		 else {
			 vTaskDelay(10);
     204:	8a e0       	ldi	r24, 0x0A	; 10
     206:	90 e0       	ldi	r25, 0x00	; 0
     208:	0e 94 a4 0e 	call	0x1d48	; 0x1d48 <vTaskDelay>
		 }

		 /*Make the Task Periodic with Period 50 Tick */
		 vTaskDelayUntil(&Start,Freq);
     20c:	ce 01       	movw	r24, r28
     20e:	03 96       	adiw	r24, 0x03	; 3
     210:	29 81       	ldd	r18, Y+1	; 0x01
     212:	3a 81       	ldd	r19, Y+2	; 0x02
     214:	b9 01       	movw	r22, r18
     216:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <vTaskDelayUntil>
     21a:	db cf       	rjmp	.-74     	; 0x1d2 <Led+0x22>

0000021c <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     21c:	df 93       	push	r29
     21e:	cf 93       	push	r28
     220:	cd b7       	in	r28, 0x3d	; 61
     222:	de b7       	in	r29, 0x3e	; 62
     224:	27 97       	sbiw	r28, 0x07	; 7
     226:	0f b6       	in	r0, 0x3f	; 63
     228:	f8 94       	cli
     22a:	de bf       	out	0x3e, r29	; 62
     22c:	0f be       	out	0x3f, r0	; 63
     22e:	cd bf       	out	0x3d, r28	; 61
     230:	9d 83       	std	Y+5, r25	; 0x05
     232:	8c 83       	std	Y+4, r24	; 0x04
     234:	6e 83       	std	Y+6, r22	; 0x06
     236:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     238:	8a e1       	ldi	r24, 0x1A	; 26
     23a:	90 e0       	ldi	r25, 0x00	; 0
     23c:	0e 94 e6 03 	call	0x7cc	; 0x7cc <pvPortMalloc>
     240:	9a 83       	std	Y+2, r25	; 0x02
     242:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     244:	89 81       	ldd	r24, Y+1	; 0x01
     246:	9a 81       	ldd	r25, Y+2	; 0x02
     248:	00 97       	sbiw	r24, 0x00	; 0
     24a:	09 f4       	brne	.+2      	; 0x24e <xCoRoutineCreate+0x32>
     24c:	6f c0       	rjmp	.+222    	; 0x32c <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     24e:	80 91 7b 00 	lds	r24, 0x007B
     252:	90 91 7c 00 	lds	r25, 0x007C
     256:	00 97       	sbiw	r24, 0x00	; 0
     258:	41 f4       	brne	.+16     	; 0x26a <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     25a:	89 81       	ldd	r24, Y+1	; 0x01
     25c:	9a 81       	ldd	r25, Y+2	; 0x02
     25e:	90 93 7c 00 	sts	0x007C, r25
     262:	80 93 7b 00 	sts	0x007B, r24
			prvInitialiseCoRoutineLists();
     266:	0e 94 75 03 	call	0x6ea	; 0x6ea <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     26a:	8e 81       	ldd	r24, Y+6	; 0x06
     26c:	82 30       	cpi	r24, 0x02	; 2
     26e:	10 f0       	brcs	.+4      	; 0x274 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     270:	81 e0       	ldi	r24, 0x01	; 1
     272:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     274:	e9 81       	ldd	r30, Y+1	; 0x01
     276:	fa 81       	ldd	r31, Y+2	; 0x02
     278:	11 8e       	std	Z+25, r1	; 0x19
     27a:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     27c:	e9 81       	ldd	r30, Y+1	; 0x01
     27e:	fa 81       	ldd	r31, Y+2	; 0x02
     280:	8e 81       	ldd	r24, Y+6	; 0x06
     282:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     284:	e9 81       	ldd	r30, Y+1	; 0x01
     286:	fa 81       	ldd	r31, Y+2	; 0x02
     288:	8f 81       	ldd	r24, Y+7	; 0x07
     28a:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     28c:	e9 81       	ldd	r30, Y+1	; 0x01
     28e:	fa 81       	ldd	r31, Y+2	; 0x02
     290:	8c 81       	ldd	r24, Y+4	; 0x04
     292:	9d 81       	ldd	r25, Y+5	; 0x05
     294:	91 83       	std	Z+1, r25	; 0x01
     296:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     298:	89 81       	ldd	r24, Y+1	; 0x01
     29a:	9a 81       	ldd	r25, Y+2	; 0x02
     29c:	02 96       	adiw	r24, 0x02	; 2
     29e:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     2a2:	89 81       	ldd	r24, Y+1	; 0x01
     2a4:	9a 81       	ldd	r25, Y+2	; 0x02
     2a6:	0c 96       	adiw	r24, 0x0c	; 12
     2a8:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     2ac:	e9 81       	ldd	r30, Y+1	; 0x01
     2ae:	fa 81       	ldd	r31, Y+2	; 0x02
     2b0:	89 81       	ldd	r24, Y+1	; 0x01
     2b2:	9a 81       	ldd	r25, Y+2	; 0x02
     2b4:	91 87       	std	Z+9, r25	; 0x09
     2b6:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     2b8:	e9 81       	ldd	r30, Y+1	; 0x01
     2ba:	fa 81       	ldd	r31, Y+2	; 0x02
     2bc:	89 81       	ldd	r24, Y+1	; 0x01
     2be:	9a 81       	ldd	r25, Y+2	; 0x02
     2c0:	93 8b       	std	Z+19, r25	; 0x13
     2c2:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     2c4:	8e 81       	ldd	r24, Y+6	; 0x06
     2c6:	28 2f       	mov	r18, r24
     2c8:	30 e0       	ldi	r19, 0x00	; 0
     2ca:	85 e0       	ldi	r24, 0x05	; 5
     2cc:	90 e0       	ldi	r25, 0x00	; 0
     2ce:	82 1b       	sub	r24, r18
     2d0:	93 0b       	sbc	r25, r19
     2d2:	e9 81       	ldd	r30, Y+1	; 0x01
     2d4:	fa 81       	ldd	r31, Y+2	; 0x02
     2d6:	95 87       	std	Z+13, r25	; 0x0d
     2d8:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     2da:	e9 81       	ldd	r30, Y+1	; 0x01
     2dc:	fa 81       	ldd	r31, Y+2	; 0x02
     2de:	96 89       	ldd	r25, Z+22	; 0x16
     2e0:	80 91 7d 00 	lds	r24, 0x007D
     2e4:	89 17       	cp	r24, r25
     2e6:	28 f4       	brcc	.+10     	; 0x2f2 <xCoRoutineCreate+0xd6>
     2e8:	e9 81       	ldd	r30, Y+1	; 0x01
     2ea:	fa 81       	ldd	r31, Y+2	; 0x02
     2ec:	86 89       	ldd	r24, Z+22	; 0x16
     2ee:	80 93 7d 00 	sts	0x007D, r24
     2f2:	e9 81       	ldd	r30, Y+1	; 0x01
     2f4:	fa 81       	ldd	r31, Y+2	; 0x02
     2f6:	86 89       	ldd	r24, Z+22	; 0x16
     2f8:	28 2f       	mov	r18, r24
     2fa:	30 e0       	ldi	r19, 0x00	; 0
     2fc:	c9 01       	movw	r24, r18
     2fe:	88 0f       	add	r24, r24
     300:	99 1f       	adc	r25, r25
     302:	88 0f       	add	r24, r24
     304:	99 1f       	adc	r25, r25
     306:	88 0f       	add	r24, r24
     308:	99 1f       	adc	r25, r25
     30a:	82 0f       	add	r24, r18
     30c:	93 1f       	adc	r25, r19
     30e:	ac 01       	movw	r20, r24
     310:	4c 57       	subi	r20, 0x7C	; 124
     312:	5f 4f       	sbci	r21, 0xFF	; 255
     314:	89 81       	ldd	r24, Y+1	; 0x01
     316:	9a 81       	ldd	r25, Y+2	; 0x02
     318:	9c 01       	movw	r18, r24
     31a:	2e 5f       	subi	r18, 0xFE	; 254
     31c:	3f 4f       	sbci	r19, 0xFF	; 255
     31e:	ca 01       	movw	r24, r20
     320:	b9 01       	movw	r22, r18
     322:	0e 94 8c 04 	call	0x918	; 0x918 <vListInsertEnd>

		xReturn = pdPASS;
     326:	81 e0       	ldi	r24, 0x01	; 1
     328:	8b 83       	std	Y+3, r24	; 0x03
     32a:	02 c0       	rjmp	.+4      	; 0x330 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     32c:	8f ef       	ldi	r24, 0xFF	; 255
     32e:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     330:	8b 81       	ldd	r24, Y+3	; 0x03
}
     332:	27 96       	adiw	r28, 0x07	; 7
     334:	0f b6       	in	r0, 0x3f	; 63
     336:	f8 94       	cli
     338:	de bf       	out	0x3e, r29	; 62
     33a:	0f be       	out	0x3f, r0	; 63
     33c:	cd bf       	out	0x3d, r28	; 61
     33e:	cf 91       	pop	r28
     340:	df 91       	pop	r29
     342:	08 95       	ret

00000344 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     344:	df 93       	push	r29
     346:	cf 93       	push	r28
     348:	00 d0       	rcall	.+0      	; 0x34a <vCoRoutineAddToDelayedList+0x6>
     34a:	00 d0       	rcall	.+0      	; 0x34c <vCoRoutineAddToDelayedList+0x8>
     34c:	00 d0       	rcall	.+0      	; 0x34e <vCoRoutineAddToDelayedList+0xa>
     34e:	cd b7       	in	r28, 0x3d	; 61
     350:	de b7       	in	r29, 0x3e	; 62
     352:	9c 83       	std	Y+4, r25	; 0x04
     354:	8b 83       	std	Y+3, r24	; 0x03
     356:	7e 83       	std	Y+6, r23	; 0x06
     358:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     35a:	20 91 7e 00 	lds	r18, 0x007E
     35e:	30 91 7f 00 	lds	r19, 0x007F
     362:	8b 81       	ldd	r24, Y+3	; 0x03
     364:	9c 81       	ldd	r25, Y+4	; 0x04
     366:	82 0f       	add	r24, r18
     368:	93 1f       	adc	r25, r19
     36a:	9a 83       	std	Y+2, r25	; 0x02
     36c:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     36e:	80 91 7b 00 	lds	r24, 0x007B
     372:	90 91 7c 00 	lds	r25, 0x007C
     376:	02 96       	adiw	r24, 0x02	; 2
     378:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     37c:	e0 91 7b 00 	lds	r30, 0x007B
     380:	f0 91 7c 00 	lds	r31, 0x007C
     384:	89 81       	ldd	r24, Y+1	; 0x01
     386:	9a 81       	ldd	r25, Y+2	; 0x02
     388:	93 83       	std	Z+3, r25	; 0x03
     38a:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     38c:	20 91 7e 00 	lds	r18, 0x007E
     390:	30 91 7f 00 	lds	r19, 0x007F
     394:	89 81       	ldd	r24, Y+1	; 0x01
     396:	9a 81       	ldd	r25, Y+2	; 0x02
     398:	82 17       	cp	r24, r18
     39a:	93 07       	cpc	r25, r19
     39c:	70 f4       	brcc	.+28     	; 0x3ba <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     39e:	80 91 aa 00 	lds	r24, 0x00AA
     3a2:	90 91 ab 00 	lds	r25, 0x00AB
     3a6:	20 91 7b 00 	lds	r18, 0x007B
     3aa:	30 91 7c 00 	lds	r19, 0x007C
     3ae:	2e 5f       	subi	r18, 0xFE	; 254
     3b0:	3f 4f       	sbci	r19, 0xFF	; 255
     3b2:	b9 01       	movw	r22, r18
     3b4:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <vListInsert>
     3b8:	0d c0       	rjmp	.+26     	; 0x3d4 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     3ba:	80 91 a8 00 	lds	r24, 0x00A8
     3be:	90 91 a9 00 	lds	r25, 0x00A9
     3c2:	20 91 7b 00 	lds	r18, 0x007B
     3c6:	30 91 7c 00 	lds	r19, 0x007C
     3ca:	2e 5f       	subi	r18, 0xFE	; 254
     3cc:	3f 4f       	sbci	r19, 0xFF	; 255
     3ce:	b9 01       	movw	r22, r18
     3d0:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <vListInsert>
	}

	if( pxEventList )
     3d4:	8d 81       	ldd	r24, Y+5	; 0x05
     3d6:	9e 81       	ldd	r25, Y+6	; 0x06
     3d8:	00 97       	sbiw	r24, 0x00	; 0
     3da:	61 f0       	breq	.+24     	; 0x3f4 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     3dc:	80 91 7b 00 	lds	r24, 0x007B
     3e0:	90 91 7c 00 	lds	r25, 0x007C
     3e4:	9c 01       	movw	r18, r24
     3e6:	24 5f       	subi	r18, 0xF4	; 244
     3e8:	3f 4f       	sbci	r19, 0xFF	; 255
     3ea:	8d 81       	ldd	r24, Y+5	; 0x05
     3ec:	9e 81       	ldd	r25, Y+6	; 0x06
     3ee:	b9 01       	movw	r22, r18
     3f0:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <vListInsert>
	}
}
     3f4:	26 96       	adiw	r28, 0x06	; 6
     3f6:	0f b6       	in	r0, 0x3f	; 63
     3f8:	f8 94       	cli
     3fa:	de bf       	out	0x3e, r29	; 62
     3fc:	0f be       	out	0x3f, r0	; 63
     3fe:	cd bf       	out	0x3d, r28	; 61
     400:	cf 91       	pop	r28
     402:	df 91       	pop	r29
     404:	08 95       	ret

00000406 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     406:	df 93       	push	r29
     408:	cf 93       	push	r28
     40a:	00 d0       	rcall	.+0      	; 0x40c <prvCheckPendingReadyList+0x6>
     40c:	cd b7       	in	r28, 0x3d	; 61
     40e:	de b7       	in	r29, 0x3e	; 62
     410:	3a c0       	rjmp	.+116    	; 0x486 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     412:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     414:	e0 91 b1 00 	lds	r30, 0x00B1
     418:	f0 91 b2 00 	lds	r31, 0x00B2
     41c:	86 81       	ldd	r24, Z+6	; 0x06
     41e:	97 81       	ldd	r25, Z+7	; 0x07
     420:	9a 83       	std	Y+2, r25	; 0x02
     422:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     424:	89 81       	ldd	r24, Y+1	; 0x01
     426:	9a 81       	ldd	r25, Y+2	; 0x02
     428:	0c 96       	adiw	r24, 0x0c	; 12
     42a:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     42e:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     430:	89 81       	ldd	r24, Y+1	; 0x01
     432:	9a 81       	ldd	r25, Y+2	; 0x02
     434:	02 96       	adiw	r24, 0x02	; 2
     436:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     43a:	e9 81       	ldd	r30, Y+1	; 0x01
     43c:	fa 81       	ldd	r31, Y+2	; 0x02
     43e:	96 89       	ldd	r25, Z+22	; 0x16
     440:	80 91 7d 00 	lds	r24, 0x007D
     444:	89 17       	cp	r24, r25
     446:	28 f4       	brcc	.+10     	; 0x452 <prvCheckPendingReadyList+0x4c>
     448:	e9 81       	ldd	r30, Y+1	; 0x01
     44a:	fa 81       	ldd	r31, Y+2	; 0x02
     44c:	86 89       	ldd	r24, Z+22	; 0x16
     44e:	80 93 7d 00 	sts	0x007D, r24
     452:	e9 81       	ldd	r30, Y+1	; 0x01
     454:	fa 81       	ldd	r31, Y+2	; 0x02
     456:	86 89       	ldd	r24, Z+22	; 0x16
     458:	28 2f       	mov	r18, r24
     45a:	30 e0       	ldi	r19, 0x00	; 0
     45c:	c9 01       	movw	r24, r18
     45e:	88 0f       	add	r24, r24
     460:	99 1f       	adc	r25, r25
     462:	88 0f       	add	r24, r24
     464:	99 1f       	adc	r25, r25
     466:	88 0f       	add	r24, r24
     468:	99 1f       	adc	r25, r25
     46a:	82 0f       	add	r24, r18
     46c:	93 1f       	adc	r25, r19
     46e:	ac 01       	movw	r20, r24
     470:	4c 57       	subi	r20, 0x7C	; 124
     472:	5f 4f       	sbci	r21, 0xFF	; 255
     474:	89 81       	ldd	r24, Y+1	; 0x01
     476:	9a 81       	ldd	r25, Y+2	; 0x02
     478:	9c 01       	movw	r18, r24
     47a:	2e 5f       	subi	r18, 0xFE	; 254
     47c:	3f 4f       	sbci	r19, 0xFF	; 255
     47e:	ca 01       	movw	r24, r20
     480:	b9 01       	movw	r22, r18
     482:	0e 94 8c 04 	call	0x918	; 0x918 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     486:	80 91 ac 00 	lds	r24, 0x00AC
     48a:	88 23       	and	r24, r24
     48c:	09 f0       	breq	.+2      	; 0x490 <prvCheckPendingReadyList+0x8a>
     48e:	c1 cf       	rjmp	.-126    	; 0x412 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     490:	0f 90       	pop	r0
     492:	0f 90       	pop	r0
     494:	cf 91       	pop	r28
     496:	df 91       	pop	r29
     498:	08 95       	ret

0000049a <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     49a:	df 93       	push	r29
     49c:	cf 93       	push	r28
     49e:	00 d0       	rcall	.+0      	; 0x4a0 <prvCheckDelayedList+0x6>
     4a0:	00 d0       	rcall	.+0      	; 0x4a2 <prvCheckDelayedList+0x8>
     4a2:	cd b7       	in	r28, 0x3d	; 61
     4a4:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     4a6:	0e 94 b2 0f 	call	0x1f64	; 0x1f64 <xTaskGetTickCount>
     4aa:	20 91 80 00 	lds	r18, 0x0080
     4ae:	30 91 81 00 	lds	r19, 0x0081
     4b2:	82 1b       	sub	r24, r18
     4b4:	93 0b       	sbc	r25, r19
     4b6:	90 93 83 00 	sts	0x0083, r25
     4ba:	80 93 82 00 	sts	0x0082, r24
     4be:	85 c0       	rjmp	.+266    	; 0x5ca <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     4c0:	80 91 7e 00 	lds	r24, 0x007E
     4c4:	90 91 7f 00 	lds	r25, 0x007F
     4c8:	01 96       	adiw	r24, 0x01	; 1
     4ca:	90 93 7f 00 	sts	0x007F, r25
     4ce:	80 93 7e 00 	sts	0x007E, r24
		xPassedTicks--;
     4d2:	80 91 82 00 	lds	r24, 0x0082
     4d6:	90 91 83 00 	lds	r25, 0x0083
     4da:	01 97       	sbiw	r24, 0x01	; 1
     4dc:	90 93 83 00 	sts	0x0083, r25
     4e0:	80 93 82 00 	sts	0x0082, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     4e4:	80 91 7e 00 	lds	r24, 0x007E
     4e8:	90 91 7f 00 	lds	r25, 0x007F
     4ec:	00 97       	sbiw	r24, 0x00	; 0
     4ee:	09 f0       	breq	.+2      	; 0x4f2 <prvCheckDelayedList+0x58>
     4f0:	64 c0       	rjmp	.+200    	; 0x5ba <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     4f2:	80 91 a8 00 	lds	r24, 0x00A8
     4f6:	90 91 a9 00 	lds	r25, 0x00A9
     4fa:	9a 83       	std	Y+2, r25	; 0x02
     4fc:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     4fe:	80 91 aa 00 	lds	r24, 0x00AA
     502:	90 91 ab 00 	lds	r25, 0x00AB
     506:	90 93 a9 00 	sts	0x00A9, r25
     50a:	80 93 a8 00 	sts	0x00A8, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     50e:	89 81       	ldd	r24, Y+1	; 0x01
     510:	9a 81       	ldd	r25, Y+2	; 0x02
     512:	90 93 ab 00 	sts	0x00AB, r25
     516:	80 93 aa 00 	sts	0x00AA, r24
     51a:	4f c0       	rjmp	.+158    	; 0x5ba <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     51c:	e0 91 a8 00 	lds	r30, 0x00A8
     520:	f0 91 a9 00 	lds	r31, 0x00A9
     524:	05 80       	ldd	r0, Z+5	; 0x05
     526:	f6 81       	ldd	r31, Z+6	; 0x06
     528:	e0 2d       	mov	r30, r0
     52a:	86 81       	ldd	r24, Z+6	; 0x06
     52c:	97 81       	ldd	r25, Z+7	; 0x07
     52e:	9c 83       	std	Y+4, r25	; 0x04
     530:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     532:	eb 81       	ldd	r30, Y+3	; 0x03
     534:	fc 81       	ldd	r31, Y+4	; 0x04
     536:	22 81       	ldd	r18, Z+2	; 0x02
     538:	33 81       	ldd	r19, Z+3	; 0x03
     53a:	80 91 7e 00 	lds	r24, 0x007E
     53e:	90 91 7f 00 	lds	r25, 0x007F
     542:	82 17       	cp	r24, r18
     544:	93 07       	cpc	r25, r19
     546:	08 f4       	brcc	.+2      	; 0x54a <prvCheckDelayedList+0xb0>
     548:	40 c0       	rjmp	.+128    	; 0x5ca <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     54a:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     54c:	8b 81       	ldd	r24, Y+3	; 0x03
     54e:	9c 81       	ldd	r25, Y+4	; 0x04
     550:	02 96       	adiw	r24, 0x02	; 2
     552:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     556:	eb 81       	ldd	r30, Y+3	; 0x03
     558:	fc 81       	ldd	r31, Y+4	; 0x04
     55a:	84 89       	ldd	r24, Z+20	; 0x14
     55c:	95 89       	ldd	r25, Z+21	; 0x15
     55e:	00 97       	sbiw	r24, 0x00	; 0
     560:	29 f0       	breq	.+10     	; 0x56c <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     562:	8b 81       	ldd	r24, Y+3	; 0x03
     564:	9c 81       	ldd	r25, Y+4	; 0x04
     566:	0c 96       	adiw	r24, 0x0c	; 12
     568:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     56c:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     56e:	eb 81       	ldd	r30, Y+3	; 0x03
     570:	fc 81       	ldd	r31, Y+4	; 0x04
     572:	96 89       	ldd	r25, Z+22	; 0x16
     574:	80 91 7d 00 	lds	r24, 0x007D
     578:	89 17       	cp	r24, r25
     57a:	28 f4       	brcc	.+10     	; 0x586 <prvCheckDelayedList+0xec>
     57c:	eb 81       	ldd	r30, Y+3	; 0x03
     57e:	fc 81       	ldd	r31, Y+4	; 0x04
     580:	86 89       	ldd	r24, Z+22	; 0x16
     582:	80 93 7d 00 	sts	0x007D, r24
     586:	eb 81       	ldd	r30, Y+3	; 0x03
     588:	fc 81       	ldd	r31, Y+4	; 0x04
     58a:	86 89       	ldd	r24, Z+22	; 0x16
     58c:	28 2f       	mov	r18, r24
     58e:	30 e0       	ldi	r19, 0x00	; 0
     590:	c9 01       	movw	r24, r18
     592:	88 0f       	add	r24, r24
     594:	99 1f       	adc	r25, r25
     596:	88 0f       	add	r24, r24
     598:	99 1f       	adc	r25, r25
     59a:	88 0f       	add	r24, r24
     59c:	99 1f       	adc	r25, r25
     59e:	82 0f       	add	r24, r18
     5a0:	93 1f       	adc	r25, r19
     5a2:	ac 01       	movw	r20, r24
     5a4:	4c 57       	subi	r20, 0x7C	; 124
     5a6:	5f 4f       	sbci	r21, 0xFF	; 255
     5a8:	8b 81       	ldd	r24, Y+3	; 0x03
     5aa:	9c 81       	ldd	r25, Y+4	; 0x04
     5ac:	9c 01       	movw	r18, r24
     5ae:	2e 5f       	subi	r18, 0xFE	; 254
     5b0:	3f 4f       	sbci	r19, 0xFF	; 255
     5b2:	ca 01       	movw	r24, r20
     5b4:	b9 01       	movw	r22, r18
     5b6:	0e 94 8c 04 	call	0x918	; 0x918 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     5ba:	e0 91 a8 00 	lds	r30, 0x00A8
     5be:	f0 91 a9 00 	lds	r31, 0x00A9
     5c2:	80 81       	ld	r24, Z
     5c4:	88 23       	and	r24, r24
     5c6:	09 f0       	breq	.+2      	; 0x5ca <prvCheckDelayedList+0x130>
     5c8:	a9 cf       	rjmp	.-174    	; 0x51c <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     5ca:	80 91 82 00 	lds	r24, 0x0082
     5ce:	90 91 83 00 	lds	r25, 0x0083
     5d2:	00 97       	sbiw	r24, 0x00	; 0
     5d4:	09 f0       	breq	.+2      	; 0x5d8 <prvCheckDelayedList+0x13e>
     5d6:	74 cf       	rjmp	.-280    	; 0x4c0 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     5d8:	80 91 7e 00 	lds	r24, 0x007E
     5dc:	90 91 7f 00 	lds	r25, 0x007F
     5e0:	90 93 81 00 	sts	0x0081, r25
     5e4:	80 93 80 00 	sts	0x0080, r24
}
     5e8:	0f 90       	pop	r0
     5ea:	0f 90       	pop	r0
     5ec:	0f 90       	pop	r0
     5ee:	0f 90       	pop	r0
     5f0:	cf 91       	pop	r28
     5f2:	df 91       	pop	r29
     5f4:	08 95       	ret

000005f6 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     5f6:	df 93       	push	r29
     5f8:	cf 93       	push	r28
     5fa:	00 d0       	rcall	.+0      	; 0x5fc <vCoRoutineSchedule+0x6>
     5fc:	cd b7       	in	r28, 0x3d	; 61
     5fe:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     600:	0e 94 03 02 	call	0x406	; 0x406 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     604:	0e 94 4d 02 	call	0x49a	; 0x49a <prvCheckDelayedList>
     608:	0a c0       	rjmp	.+20     	; 0x61e <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     60a:	80 91 7d 00 	lds	r24, 0x007D
     60e:	88 23       	and	r24, r24
     610:	09 f4       	brne	.+2      	; 0x614 <vCoRoutineSchedule+0x1e>
     612:	66 c0       	rjmp	.+204    	; 0x6e0 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     614:	80 91 7d 00 	lds	r24, 0x007D
     618:	81 50       	subi	r24, 0x01	; 1
     61a:	80 93 7d 00 	sts	0x007D, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     61e:	80 91 7d 00 	lds	r24, 0x007D
     622:	28 2f       	mov	r18, r24
     624:	30 e0       	ldi	r19, 0x00	; 0
     626:	c9 01       	movw	r24, r18
     628:	88 0f       	add	r24, r24
     62a:	99 1f       	adc	r25, r25
     62c:	88 0f       	add	r24, r24
     62e:	99 1f       	adc	r25, r25
     630:	88 0f       	add	r24, r24
     632:	99 1f       	adc	r25, r25
     634:	82 0f       	add	r24, r18
     636:	93 1f       	adc	r25, r19
     638:	fc 01       	movw	r30, r24
     63a:	ec 57       	subi	r30, 0x7C	; 124
     63c:	ff 4f       	sbci	r31, 0xFF	; 255
     63e:	80 81       	ld	r24, Z
     640:	88 23       	and	r24, r24
     642:	19 f3       	breq	.-58     	; 0x60a <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     644:	80 91 7d 00 	lds	r24, 0x007D
     648:	28 2f       	mov	r18, r24
     64a:	30 e0       	ldi	r19, 0x00	; 0
     64c:	c9 01       	movw	r24, r18
     64e:	88 0f       	add	r24, r24
     650:	99 1f       	adc	r25, r25
     652:	88 0f       	add	r24, r24
     654:	99 1f       	adc	r25, r25
     656:	88 0f       	add	r24, r24
     658:	99 1f       	adc	r25, r25
     65a:	82 0f       	add	r24, r18
     65c:	93 1f       	adc	r25, r19
     65e:	8c 57       	subi	r24, 0x7C	; 124
     660:	9f 4f       	sbci	r25, 0xFF	; 255
     662:	9a 83       	std	Y+2, r25	; 0x02
     664:	89 83       	std	Y+1, r24	; 0x01
     666:	e9 81       	ldd	r30, Y+1	; 0x01
     668:	fa 81       	ldd	r31, Y+2	; 0x02
     66a:	01 80       	ldd	r0, Z+1	; 0x01
     66c:	f2 81       	ldd	r31, Z+2	; 0x02
     66e:	e0 2d       	mov	r30, r0
     670:	82 81       	ldd	r24, Z+2	; 0x02
     672:	93 81       	ldd	r25, Z+3	; 0x03
     674:	e9 81       	ldd	r30, Y+1	; 0x01
     676:	fa 81       	ldd	r31, Y+2	; 0x02
     678:	92 83       	std	Z+2, r25	; 0x02
     67a:	81 83       	std	Z+1, r24	; 0x01
     67c:	e9 81       	ldd	r30, Y+1	; 0x01
     67e:	fa 81       	ldd	r31, Y+2	; 0x02
     680:	21 81       	ldd	r18, Z+1	; 0x01
     682:	32 81       	ldd	r19, Z+2	; 0x02
     684:	89 81       	ldd	r24, Y+1	; 0x01
     686:	9a 81       	ldd	r25, Y+2	; 0x02
     688:	03 96       	adiw	r24, 0x03	; 3
     68a:	28 17       	cp	r18, r24
     68c:	39 07       	cpc	r19, r25
     68e:	59 f4       	brne	.+22     	; 0x6a6 <vCoRoutineSchedule+0xb0>
     690:	e9 81       	ldd	r30, Y+1	; 0x01
     692:	fa 81       	ldd	r31, Y+2	; 0x02
     694:	01 80       	ldd	r0, Z+1	; 0x01
     696:	f2 81       	ldd	r31, Z+2	; 0x02
     698:	e0 2d       	mov	r30, r0
     69a:	82 81       	ldd	r24, Z+2	; 0x02
     69c:	93 81       	ldd	r25, Z+3	; 0x03
     69e:	e9 81       	ldd	r30, Y+1	; 0x01
     6a0:	fa 81       	ldd	r31, Y+2	; 0x02
     6a2:	92 83       	std	Z+2, r25	; 0x02
     6a4:	81 83       	std	Z+1, r24	; 0x01
     6a6:	e9 81       	ldd	r30, Y+1	; 0x01
     6a8:	fa 81       	ldd	r31, Y+2	; 0x02
     6aa:	01 80       	ldd	r0, Z+1	; 0x01
     6ac:	f2 81       	ldd	r31, Z+2	; 0x02
     6ae:	e0 2d       	mov	r30, r0
     6b0:	86 81       	ldd	r24, Z+6	; 0x06
     6b2:	97 81       	ldd	r25, Z+7	; 0x07
     6b4:	90 93 7c 00 	sts	0x007C, r25
     6b8:	80 93 7b 00 	sts	0x007B, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     6bc:	e0 91 7b 00 	lds	r30, 0x007B
     6c0:	f0 91 7c 00 	lds	r31, 0x007C
     6c4:	40 81       	ld	r20, Z
     6c6:	51 81       	ldd	r21, Z+1	; 0x01
     6c8:	80 91 7b 00 	lds	r24, 0x007B
     6cc:	90 91 7c 00 	lds	r25, 0x007C
     6d0:	e0 91 7b 00 	lds	r30, 0x007B
     6d4:	f0 91 7c 00 	lds	r31, 0x007C
     6d8:	27 89       	ldd	r18, Z+23	; 0x17
     6da:	62 2f       	mov	r22, r18
     6dc:	fa 01       	movw	r30, r20
     6de:	09 95       	icall

	return;
}
     6e0:	0f 90       	pop	r0
     6e2:	0f 90       	pop	r0
     6e4:	cf 91       	pop	r28
     6e6:	df 91       	pop	r29
     6e8:	08 95       	ret

000006ea <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     6ea:	df 93       	push	r29
     6ec:	cf 93       	push	r28
     6ee:	0f 92       	push	r0
     6f0:	cd b7       	in	r28, 0x3d	; 61
     6f2:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     6f4:	19 82       	std	Y+1, r1	; 0x01
     6f6:	13 c0       	rjmp	.+38     	; 0x71e <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     6f8:	89 81       	ldd	r24, Y+1	; 0x01
     6fa:	28 2f       	mov	r18, r24
     6fc:	30 e0       	ldi	r19, 0x00	; 0
     6fe:	c9 01       	movw	r24, r18
     700:	88 0f       	add	r24, r24
     702:	99 1f       	adc	r25, r25
     704:	88 0f       	add	r24, r24
     706:	99 1f       	adc	r25, r25
     708:	88 0f       	add	r24, r24
     70a:	99 1f       	adc	r25, r25
     70c:	82 0f       	add	r24, r18
     70e:	93 1f       	adc	r25, r19
     710:	8c 57       	subi	r24, 0x7C	; 124
     712:	9f 4f       	sbci	r25, 0xFF	; 255
     714:	0e 94 52 04 	call	0x8a4	; 0x8a4 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     718:	89 81       	ldd	r24, Y+1	; 0x01
     71a:	8f 5f       	subi	r24, 0xFF	; 255
     71c:	89 83       	std	Y+1, r24	; 0x01
     71e:	89 81       	ldd	r24, Y+1	; 0x01
     720:	82 30       	cpi	r24, 0x02	; 2
     722:	50 f3       	brcs	.-44     	; 0x6f8 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     724:	86 e9       	ldi	r24, 0x96	; 150
     726:	90 e0       	ldi	r25, 0x00	; 0
     728:	0e 94 52 04 	call	0x8a4	; 0x8a4 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     72c:	8f e9       	ldi	r24, 0x9F	; 159
     72e:	90 e0       	ldi	r25, 0x00	; 0
     730:	0e 94 52 04 	call	0x8a4	; 0x8a4 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     734:	8c ea       	ldi	r24, 0xAC	; 172
     736:	90 e0       	ldi	r25, 0x00	; 0
     738:	0e 94 52 04 	call	0x8a4	; 0x8a4 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     73c:	86 e9       	ldi	r24, 0x96	; 150
     73e:	90 e0       	ldi	r25, 0x00	; 0
     740:	90 93 a9 00 	sts	0x00A9, r25
     744:	80 93 a8 00 	sts	0x00A8, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     748:	8f e9       	ldi	r24, 0x9F	; 159
     74a:	90 e0       	ldi	r25, 0x00	; 0
     74c:	90 93 ab 00 	sts	0x00AB, r25
     750:	80 93 aa 00 	sts	0x00AA, r24
}
     754:	0f 90       	pop	r0
     756:	cf 91       	pop	r28
     758:	df 91       	pop	r29
     75a:	08 95       	ret

0000075c <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     75c:	df 93       	push	r29
     75e:	cf 93       	push	r28
     760:	00 d0       	rcall	.+0      	; 0x762 <xCoRoutineRemoveFromEventList+0x6>
     762:	00 d0       	rcall	.+0      	; 0x764 <xCoRoutineRemoveFromEventList+0x8>
     764:	0f 92       	push	r0
     766:	cd b7       	in	r28, 0x3d	; 61
     768:	de b7       	in	r29, 0x3e	; 62
     76a:	9d 83       	std	Y+5, r25	; 0x05
     76c:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     76e:	ec 81       	ldd	r30, Y+4	; 0x04
     770:	fd 81       	ldd	r31, Y+5	; 0x05
     772:	05 80       	ldd	r0, Z+5	; 0x05
     774:	f6 81       	ldd	r31, Z+6	; 0x06
     776:	e0 2d       	mov	r30, r0
     778:	86 81       	ldd	r24, Z+6	; 0x06
     77a:	97 81       	ldd	r25, Z+7	; 0x07
     77c:	9b 83       	std	Y+3, r25	; 0x03
     77e:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     780:	8a 81       	ldd	r24, Y+2	; 0x02
     782:	9b 81       	ldd	r25, Y+3	; 0x03
     784:	0c 96       	adiw	r24, 0x0c	; 12
     786:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     78a:	8a 81       	ldd	r24, Y+2	; 0x02
     78c:	9b 81       	ldd	r25, Y+3	; 0x03
     78e:	9c 01       	movw	r18, r24
     790:	24 5f       	subi	r18, 0xF4	; 244
     792:	3f 4f       	sbci	r19, 0xFF	; 255
     794:	8c ea       	ldi	r24, 0xAC	; 172
     796:	90 e0       	ldi	r25, 0x00	; 0
     798:	b9 01       	movw	r22, r18
     79a:	0e 94 8c 04 	call	0x918	; 0x918 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     79e:	ea 81       	ldd	r30, Y+2	; 0x02
     7a0:	fb 81       	ldd	r31, Y+3	; 0x03
     7a2:	96 89       	ldd	r25, Z+22	; 0x16
     7a4:	e0 91 7b 00 	lds	r30, 0x007B
     7a8:	f0 91 7c 00 	lds	r31, 0x007C
     7ac:	86 89       	ldd	r24, Z+22	; 0x16
     7ae:	98 17       	cp	r25, r24
     7b0:	18 f0       	brcs	.+6      	; 0x7b8 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
     7b2:	81 e0       	ldi	r24, 0x01	; 1
     7b4:	89 83       	std	Y+1, r24	; 0x01
     7b6:	01 c0       	rjmp	.+2      	; 0x7ba <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
     7b8:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
     7ba:	89 81       	ldd	r24, Y+1	; 0x01
}
     7bc:	0f 90       	pop	r0
     7be:	0f 90       	pop	r0
     7c0:	0f 90       	pop	r0
     7c2:	0f 90       	pop	r0
     7c4:	0f 90       	pop	r0
     7c6:	cf 91       	pop	r28
     7c8:	df 91       	pop	r29
     7ca:	08 95       	ret

000007cc <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     7cc:	df 93       	push	r29
     7ce:	cf 93       	push	r28
     7d0:	00 d0       	rcall	.+0      	; 0x7d2 <pvPortMalloc+0x6>
     7d2:	00 d0       	rcall	.+0      	; 0x7d4 <pvPortMalloc+0x8>
     7d4:	cd b7       	in	r28, 0x3d	; 61
     7d6:	de b7       	in	r29, 0x3e	; 62
     7d8:	9c 83       	std	Y+4, r25	; 0x04
     7da:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
     7dc:	1a 82       	std	Y+2, r1	; 0x02
     7de:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     7e0:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     7e4:	80 91 b5 00 	lds	r24, 0x00B5
     7e8:	90 91 b6 00 	lds	r25, 0x00B6
     7ec:	2b 81       	ldd	r18, Y+3	; 0x03
     7ee:	3c 81       	ldd	r19, Y+4	; 0x04
     7f0:	82 0f       	add	r24, r18
     7f2:	93 1f       	adc	r25, r19
     7f4:	22 e0       	ldi	r18, 0x02	; 2
     7f6:	88 35       	cpi	r24, 0x58	; 88
     7f8:	92 07       	cpc	r25, r18
     7fa:	18 f5       	brcc	.+70     	; 0x842 <pvPortMalloc+0x76>
     7fc:	20 91 b5 00 	lds	r18, 0x00B5
     800:	30 91 b6 00 	lds	r19, 0x00B6
     804:	8b 81       	ldd	r24, Y+3	; 0x03
     806:	9c 81       	ldd	r25, Y+4	; 0x04
     808:	28 0f       	add	r18, r24
     80a:	39 1f       	adc	r19, r25
     80c:	80 91 b5 00 	lds	r24, 0x00B5
     810:	90 91 b6 00 	lds	r25, 0x00B6
     814:	82 17       	cp	r24, r18
     816:	93 07       	cpc	r25, r19
     818:	a0 f4       	brcc	.+40     	; 0x842 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     81a:	80 91 b5 00 	lds	r24, 0x00B5
     81e:	90 91 b6 00 	lds	r25, 0x00B6
     822:	89 54       	subi	r24, 0x49	; 73
     824:	9f 4f       	sbci	r25, 0xFF	; 255
     826:	9a 83       	std	Y+2, r25	; 0x02
     828:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
     82a:	20 91 b5 00 	lds	r18, 0x00B5
     82e:	30 91 b6 00 	lds	r19, 0x00B6
     832:	8b 81       	ldd	r24, Y+3	; 0x03
     834:	9c 81       	ldd	r25, Y+4	; 0x04
     836:	82 0f       	add	r24, r18
     838:	93 1f       	adc	r25, r19
     83a:	90 93 b6 00 	sts	0x00B6, r25
     83e:	80 93 b5 00 	sts	0x00B5, r24
		}	
	}
	xTaskResumeAll();
     842:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
     846:	89 81       	ldd	r24, Y+1	; 0x01
     848:	9a 81       	ldd	r25, Y+2	; 0x02
}
     84a:	0f 90       	pop	r0
     84c:	0f 90       	pop	r0
     84e:	0f 90       	pop	r0
     850:	0f 90       	pop	r0
     852:	cf 91       	pop	r28
     854:	df 91       	pop	r29
     856:	08 95       	ret

00000858 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     858:	df 93       	push	r29
     85a:	cf 93       	push	r28
     85c:	00 d0       	rcall	.+0      	; 0x85e <vPortFree+0x6>
     85e:	cd b7       	in	r28, 0x3d	; 61
     860:	de b7       	in	r29, 0x3e	; 62
     862:	9a 83       	std	Y+2, r25	; 0x02
     864:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     866:	0f 90       	pop	r0
     868:	0f 90       	pop	r0
     86a:	cf 91       	pop	r28
     86c:	df 91       	pop	r29
     86e:	08 95       	ret

00000870 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     870:	df 93       	push	r29
     872:	cf 93       	push	r28
     874:	cd b7       	in	r28, 0x3d	; 61
     876:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     878:	10 92 b6 00 	sts	0x00B6, r1
     87c:	10 92 b5 00 	sts	0x00B5, r1
}
     880:	cf 91       	pop	r28
     882:	df 91       	pop	r29
     884:	08 95       	ret

00000886 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     886:	df 93       	push	r29
     888:	cf 93       	push	r28
     88a:	cd b7       	in	r28, 0x3d	; 61
     88c:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     88e:	20 91 b5 00 	lds	r18, 0x00B5
     892:	30 91 b6 00 	lds	r19, 0x00B6
     896:	88 e5       	ldi	r24, 0x58	; 88
     898:	92 e0       	ldi	r25, 0x02	; 2
     89a:	82 1b       	sub	r24, r18
     89c:	93 0b       	sbc	r25, r19
}
     89e:	cf 91       	pop	r28
     8a0:	df 91       	pop	r29
     8a2:	08 95       	ret

000008a4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     8a4:	df 93       	push	r29
     8a6:	cf 93       	push	r28
     8a8:	00 d0       	rcall	.+0      	; 0x8aa <vListInitialise+0x6>
     8aa:	cd b7       	in	r28, 0x3d	; 61
     8ac:	de b7       	in	r29, 0x3e	; 62
     8ae:	9a 83       	std	Y+2, r25	; 0x02
     8b0:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     8b2:	89 81       	ldd	r24, Y+1	; 0x01
     8b4:	9a 81       	ldd	r25, Y+2	; 0x02
     8b6:	03 96       	adiw	r24, 0x03	; 3
     8b8:	e9 81       	ldd	r30, Y+1	; 0x01
     8ba:	fa 81       	ldd	r31, Y+2	; 0x02
     8bc:	92 83       	std	Z+2, r25	; 0x02
     8be:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     8c0:	e9 81       	ldd	r30, Y+1	; 0x01
     8c2:	fa 81       	ldd	r31, Y+2	; 0x02
     8c4:	8f ef       	ldi	r24, 0xFF	; 255
     8c6:	9f ef       	ldi	r25, 0xFF	; 255
     8c8:	94 83       	std	Z+4, r25	; 0x04
     8ca:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     8cc:	89 81       	ldd	r24, Y+1	; 0x01
     8ce:	9a 81       	ldd	r25, Y+2	; 0x02
     8d0:	03 96       	adiw	r24, 0x03	; 3
     8d2:	e9 81       	ldd	r30, Y+1	; 0x01
     8d4:	fa 81       	ldd	r31, Y+2	; 0x02
     8d6:	96 83       	std	Z+6, r25	; 0x06
     8d8:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     8da:	89 81       	ldd	r24, Y+1	; 0x01
     8dc:	9a 81       	ldd	r25, Y+2	; 0x02
     8de:	03 96       	adiw	r24, 0x03	; 3
     8e0:	e9 81       	ldd	r30, Y+1	; 0x01
     8e2:	fa 81       	ldd	r31, Y+2	; 0x02
     8e4:	90 87       	std	Z+8, r25	; 0x08
     8e6:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     8e8:	e9 81       	ldd	r30, Y+1	; 0x01
     8ea:	fa 81       	ldd	r31, Y+2	; 0x02
     8ec:	10 82       	st	Z, r1
}
     8ee:	0f 90       	pop	r0
     8f0:	0f 90       	pop	r0
     8f2:	cf 91       	pop	r28
     8f4:	df 91       	pop	r29
     8f6:	08 95       	ret

000008f8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
     8f8:	df 93       	push	r29
     8fa:	cf 93       	push	r28
     8fc:	00 d0       	rcall	.+0      	; 0x8fe <vListInitialiseItem+0x6>
     8fe:	cd b7       	in	r28, 0x3d	; 61
     900:	de b7       	in	r29, 0x3e	; 62
     902:	9a 83       	std	Y+2, r25	; 0x02
     904:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     906:	e9 81       	ldd	r30, Y+1	; 0x01
     908:	fa 81       	ldd	r31, Y+2	; 0x02
     90a:	11 86       	std	Z+9, r1	; 0x09
     90c:	10 86       	std	Z+8, r1	; 0x08
}
     90e:	0f 90       	pop	r0
     910:	0f 90       	pop	r0
     912:	cf 91       	pop	r28
     914:	df 91       	pop	r29
     916:	08 95       	ret

00000918 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     918:	df 93       	push	r29
     91a:	cf 93       	push	r28
     91c:	00 d0       	rcall	.+0      	; 0x91e <vListInsertEnd+0x6>
     91e:	00 d0       	rcall	.+0      	; 0x920 <vListInsertEnd+0x8>
     920:	00 d0       	rcall	.+0      	; 0x922 <vListInsertEnd+0xa>
     922:	cd b7       	in	r28, 0x3d	; 61
     924:	de b7       	in	r29, 0x3e	; 62
     926:	9c 83       	std	Y+4, r25	; 0x04
     928:	8b 83       	std	Y+3, r24	; 0x03
     92a:	7e 83       	std	Y+6, r23	; 0x06
     92c:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     92e:	eb 81       	ldd	r30, Y+3	; 0x03
     930:	fc 81       	ldd	r31, Y+4	; 0x04
     932:	81 81       	ldd	r24, Z+1	; 0x01
     934:	92 81       	ldd	r25, Z+2	; 0x02
     936:	9a 83       	std	Y+2, r25	; 0x02
     938:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
     93a:	e9 81       	ldd	r30, Y+1	; 0x01
     93c:	fa 81       	ldd	r31, Y+2	; 0x02
     93e:	82 81       	ldd	r24, Z+2	; 0x02
     940:	93 81       	ldd	r25, Z+3	; 0x03
     942:	ed 81       	ldd	r30, Y+5	; 0x05
     944:	fe 81       	ldd	r31, Y+6	; 0x06
     946:	93 83       	std	Z+3, r25	; 0x03
     948:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     94a:	eb 81       	ldd	r30, Y+3	; 0x03
     94c:	fc 81       	ldd	r31, Y+4	; 0x04
     94e:	81 81       	ldd	r24, Z+1	; 0x01
     950:	92 81       	ldd	r25, Z+2	; 0x02
     952:	ed 81       	ldd	r30, Y+5	; 0x05
     954:	fe 81       	ldd	r31, Y+6	; 0x06
     956:	95 83       	std	Z+5, r25	; 0x05
     958:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     95a:	e9 81       	ldd	r30, Y+1	; 0x01
     95c:	fa 81       	ldd	r31, Y+2	; 0x02
     95e:	02 80       	ldd	r0, Z+2	; 0x02
     960:	f3 81       	ldd	r31, Z+3	; 0x03
     962:	e0 2d       	mov	r30, r0
     964:	8d 81       	ldd	r24, Y+5	; 0x05
     966:	9e 81       	ldd	r25, Y+6	; 0x06
     968:	95 83       	std	Z+5, r25	; 0x05
     96a:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     96c:	8d 81       	ldd	r24, Y+5	; 0x05
     96e:	9e 81       	ldd	r25, Y+6	; 0x06
     970:	e9 81       	ldd	r30, Y+1	; 0x01
     972:	fa 81       	ldd	r31, Y+2	; 0x02
     974:	93 83       	std	Z+3, r25	; 0x03
     976:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     978:	8d 81       	ldd	r24, Y+5	; 0x05
     97a:	9e 81       	ldd	r25, Y+6	; 0x06
     97c:	eb 81       	ldd	r30, Y+3	; 0x03
     97e:	fc 81       	ldd	r31, Y+4	; 0x04
     980:	92 83       	std	Z+2, r25	; 0x02
     982:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     984:	ed 81       	ldd	r30, Y+5	; 0x05
     986:	fe 81       	ldd	r31, Y+6	; 0x06
     988:	8b 81       	ldd	r24, Y+3	; 0x03
     98a:	9c 81       	ldd	r25, Y+4	; 0x04
     98c:	91 87       	std	Z+9, r25	; 0x09
     98e:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     990:	eb 81       	ldd	r30, Y+3	; 0x03
     992:	fc 81       	ldd	r31, Y+4	; 0x04
     994:	80 81       	ld	r24, Z
     996:	8f 5f       	subi	r24, 0xFF	; 255
     998:	eb 81       	ldd	r30, Y+3	; 0x03
     99a:	fc 81       	ldd	r31, Y+4	; 0x04
     99c:	80 83       	st	Z, r24
}
     99e:	26 96       	adiw	r28, 0x06	; 6
     9a0:	0f b6       	in	r0, 0x3f	; 63
     9a2:	f8 94       	cli
     9a4:	de bf       	out	0x3e, r29	; 62
     9a6:	0f be       	out	0x3f, r0	; 63
     9a8:	cd bf       	out	0x3d, r28	; 61
     9aa:	cf 91       	pop	r28
     9ac:	df 91       	pop	r29
     9ae:	08 95       	ret

000009b0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     9b0:	df 93       	push	r29
     9b2:	cf 93       	push	r28
     9b4:	cd b7       	in	r28, 0x3d	; 61
     9b6:	de b7       	in	r29, 0x3e	; 62
     9b8:	28 97       	sbiw	r28, 0x08	; 8
     9ba:	0f b6       	in	r0, 0x3f	; 63
     9bc:	f8 94       	cli
     9be:	de bf       	out	0x3e, r29	; 62
     9c0:	0f be       	out	0x3f, r0	; 63
     9c2:	cd bf       	out	0x3d, r28	; 61
     9c4:	9e 83       	std	Y+6, r25	; 0x06
     9c6:	8d 83       	std	Y+5, r24	; 0x05
     9c8:	78 87       	std	Y+8, r23	; 0x08
     9ca:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     9cc:	ef 81       	ldd	r30, Y+7	; 0x07
     9ce:	f8 85       	ldd	r31, Y+8	; 0x08
     9d0:	80 81       	ld	r24, Z
     9d2:	91 81       	ldd	r25, Z+1	; 0x01
     9d4:	9a 83       	std	Y+2, r25	; 0x02
     9d6:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     9d8:	89 81       	ldd	r24, Y+1	; 0x01
     9da:	9a 81       	ldd	r25, Y+2	; 0x02
     9dc:	2f ef       	ldi	r18, 0xFF	; 255
     9de:	8f 3f       	cpi	r24, 0xFF	; 255
     9e0:	92 07       	cpc	r25, r18
     9e2:	39 f4       	brne	.+14     	; 0x9f2 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     9e4:	ed 81       	ldd	r30, Y+5	; 0x05
     9e6:	fe 81       	ldd	r31, Y+6	; 0x06
     9e8:	87 81       	ldd	r24, Z+7	; 0x07
     9ea:	90 85       	ldd	r25, Z+8	; 0x08
     9ec:	9c 83       	std	Y+4, r25	; 0x04
     9ee:	8b 83       	std	Y+3, r24	; 0x03
     9f0:	18 c0       	rjmp	.+48     	; 0xa22 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     9f2:	8d 81       	ldd	r24, Y+5	; 0x05
     9f4:	9e 81       	ldd	r25, Y+6	; 0x06
     9f6:	03 96       	adiw	r24, 0x03	; 3
     9f8:	9c 83       	std	Y+4, r25	; 0x04
     9fa:	8b 83       	std	Y+3, r24	; 0x03
     9fc:	06 c0       	rjmp	.+12     	; 0xa0a <vListInsert+0x5a>
     9fe:	eb 81       	ldd	r30, Y+3	; 0x03
     a00:	fc 81       	ldd	r31, Y+4	; 0x04
     a02:	82 81       	ldd	r24, Z+2	; 0x02
     a04:	93 81       	ldd	r25, Z+3	; 0x03
     a06:	9c 83       	std	Y+4, r25	; 0x04
     a08:	8b 83       	std	Y+3, r24	; 0x03
     a0a:	eb 81       	ldd	r30, Y+3	; 0x03
     a0c:	fc 81       	ldd	r31, Y+4	; 0x04
     a0e:	02 80       	ldd	r0, Z+2	; 0x02
     a10:	f3 81       	ldd	r31, Z+3	; 0x03
     a12:	e0 2d       	mov	r30, r0
     a14:	20 81       	ld	r18, Z
     a16:	31 81       	ldd	r19, Z+1	; 0x01
     a18:	89 81       	ldd	r24, Y+1	; 0x01
     a1a:	9a 81       	ldd	r25, Y+2	; 0x02
     a1c:	82 17       	cp	r24, r18
     a1e:	93 07       	cpc	r25, r19
     a20:	70 f7       	brcc	.-36     	; 0x9fe <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     a22:	eb 81       	ldd	r30, Y+3	; 0x03
     a24:	fc 81       	ldd	r31, Y+4	; 0x04
     a26:	82 81       	ldd	r24, Z+2	; 0x02
     a28:	93 81       	ldd	r25, Z+3	; 0x03
     a2a:	ef 81       	ldd	r30, Y+7	; 0x07
     a2c:	f8 85       	ldd	r31, Y+8	; 0x08
     a2e:	93 83       	std	Z+3, r25	; 0x03
     a30:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     a32:	ef 81       	ldd	r30, Y+7	; 0x07
     a34:	f8 85       	ldd	r31, Y+8	; 0x08
     a36:	02 80       	ldd	r0, Z+2	; 0x02
     a38:	f3 81       	ldd	r31, Z+3	; 0x03
     a3a:	e0 2d       	mov	r30, r0
     a3c:	8f 81       	ldd	r24, Y+7	; 0x07
     a3e:	98 85       	ldd	r25, Y+8	; 0x08
     a40:	95 83       	std	Z+5, r25	; 0x05
     a42:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     a44:	ef 81       	ldd	r30, Y+7	; 0x07
     a46:	f8 85       	ldd	r31, Y+8	; 0x08
     a48:	8b 81       	ldd	r24, Y+3	; 0x03
     a4a:	9c 81       	ldd	r25, Y+4	; 0x04
     a4c:	95 83       	std	Z+5, r25	; 0x05
     a4e:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     a50:	8f 81       	ldd	r24, Y+7	; 0x07
     a52:	98 85       	ldd	r25, Y+8	; 0x08
     a54:	eb 81       	ldd	r30, Y+3	; 0x03
     a56:	fc 81       	ldd	r31, Y+4	; 0x04
     a58:	93 83       	std	Z+3, r25	; 0x03
     a5a:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     a5c:	ef 81       	ldd	r30, Y+7	; 0x07
     a5e:	f8 85       	ldd	r31, Y+8	; 0x08
     a60:	8d 81       	ldd	r24, Y+5	; 0x05
     a62:	9e 81       	ldd	r25, Y+6	; 0x06
     a64:	91 87       	std	Z+9, r25	; 0x09
     a66:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     a68:	ed 81       	ldd	r30, Y+5	; 0x05
     a6a:	fe 81       	ldd	r31, Y+6	; 0x06
     a6c:	80 81       	ld	r24, Z
     a6e:	8f 5f       	subi	r24, 0xFF	; 255
     a70:	ed 81       	ldd	r30, Y+5	; 0x05
     a72:	fe 81       	ldd	r31, Y+6	; 0x06
     a74:	80 83       	st	Z, r24
}
     a76:	28 96       	adiw	r28, 0x08	; 8
     a78:	0f b6       	in	r0, 0x3f	; 63
     a7a:	f8 94       	cli
     a7c:	de bf       	out	0x3e, r29	; 62
     a7e:	0f be       	out	0x3f, r0	; 63
     a80:	cd bf       	out	0x3d, r28	; 61
     a82:	cf 91       	pop	r28
     a84:	df 91       	pop	r29
     a86:	08 95       	ret

00000a88 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     a88:	df 93       	push	r29
     a8a:	cf 93       	push	r28
     a8c:	00 d0       	rcall	.+0      	; 0xa8e <vListRemove+0x6>
     a8e:	00 d0       	rcall	.+0      	; 0xa90 <vListRemove+0x8>
     a90:	cd b7       	in	r28, 0x3d	; 61
     a92:	de b7       	in	r29, 0x3e	; 62
     a94:	9c 83       	std	Y+4, r25	; 0x04
     a96:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     a98:	eb 81       	ldd	r30, Y+3	; 0x03
     a9a:	fc 81       	ldd	r31, Y+4	; 0x04
     a9c:	a2 81       	ldd	r26, Z+2	; 0x02
     a9e:	b3 81       	ldd	r27, Z+3	; 0x03
     aa0:	eb 81       	ldd	r30, Y+3	; 0x03
     aa2:	fc 81       	ldd	r31, Y+4	; 0x04
     aa4:	84 81       	ldd	r24, Z+4	; 0x04
     aa6:	95 81       	ldd	r25, Z+5	; 0x05
     aa8:	15 96       	adiw	r26, 0x05	; 5
     aaa:	9c 93       	st	X, r25
     aac:	8e 93       	st	-X, r24
     aae:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     ab0:	eb 81       	ldd	r30, Y+3	; 0x03
     ab2:	fc 81       	ldd	r31, Y+4	; 0x04
     ab4:	a4 81       	ldd	r26, Z+4	; 0x04
     ab6:	b5 81       	ldd	r27, Z+5	; 0x05
     ab8:	eb 81       	ldd	r30, Y+3	; 0x03
     aba:	fc 81       	ldd	r31, Y+4	; 0x04
     abc:	82 81       	ldd	r24, Z+2	; 0x02
     abe:	93 81       	ldd	r25, Z+3	; 0x03
     ac0:	13 96       	adiw	r26, 0x03	; 3
     ac2:	9c 93       	st	X, r25
     ac4:	8e 93       	st	-X, r24
     ac6:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     ac8:	eb 81       	ldd	r30, Y+3	; 0x03
     aca:	fc 81       	ldd	r31, Y+4	; 0x04
     acc:	80 85       	ldd	r24, Z+8	; 0x08
     ace:	91 85       	ldd	r25, Z+9	; 0x09
     ad0:	9a 83       	std	Y+2, r25	; 0x02
     ad2:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     ad4:	e9 81       	ldd	r30, Y+1	; 0x01
     ad6:	fa 81       	ldd	r31, Y+2	; 0x02
     ad8:	21 81       	ldd	r18, Z+1	; 0x01
     ada:	32 81       	ldd	r19, Z+2	; 0x02
     adc:	8b 81       	ldd	r24, Y+3	; 0x03
     ade:	9c 81       	ldd	r25, Y+4	; 0x04
     ae0:	28 17       	cp	r18, r24
     ae2:	39 07       	cpc	r19, r25
     ae4:	41 f4       	brne	.+16     	; 0xaf6 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     ae6:	eb 81       	ldd	r30, Y+3	; 0x03
     ae8:	fc 81       	ldd	r31, Y+4	; 0x04
     aea:	84 81       	ldd	r24, Z+4	; 0x04
     aec:	95 81       	ldd	r25, Z+5	; 0x05
     aee:	e9 81       	ldd	r30, Y+1	; 0x01
     af0:	fa 81       	ldd	r31, Y+2	; 0x02
     af2:	92 83       	std	Z+2, r25	; 0x02
     af4:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
     af6:	eb 81       	ldd	r30, Y+3	; 0x03
     af8:	fc 81       	ldd	r31, Y+4	; 0x04
     afa:	11 86       	std	Z+9, r1	; 0x09
     afc:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     afe:	e9 81       	ldd	r30, Y+1	; 0x01
     b00:	fa 81       	ldd	r31, Y+2	; 0x02
     b02:	80 81       	ld	r24, Z
     b04:	81 50       	subi	r24, 0x01	; 1
     b06:	e9 81       	ldd	r30, Y+1	; 0x01
     b08:	fa 81       	ldd	r31, Y+2	; 0x02
     b0a:	80 83       	st	Z, r24
}
     b0c:	0f 90       	pop	r0
     b0e:	0f 90       	pop	r0
     b10:	0f 90       	pop	r0
     b12:	0f 90       	pop	r0
     b14:	cf 91       	pop	r28
     b16:	df 91       	pop	r29
     b18:	08 95       	ret

00000b1a <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
     b1a:	df 93       	push	r29
     b1c:	cf 93       	push	r28
     b1e:	cd b7       	in	r28, 0x3d	; 61
     b20:	de b7       	in	r29, 0x3e	; 62
     b22:	28 97       	sbiw	r28, 0x08	; 8
     b24:	0f b6       	in	r0, 0x3f	; 63
     b26:	f8 94       	cli
     b28:	de bf       	out	0x3e, r29	; 62
     b2a:	0f be       	out	0x3f, r0	; 63
     b2c:	cd bf       	out	0x3d, r28	; 61
     b2e:	9c 83       	std	Y+4, r25	; 0x04
     b30:	8b 83       	std	Y+3, r24	; 0x03
     b32:	7e 83       	std	Y+6, r23	; 0x06
     b34:	6d 83       	std	Y+5, r22	; 0x05
     b36:	58 87       	std	Y+8, r21	; 0x08
     b38:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     b3a:	eb 81       	ldd	r30, Y+3	; 0x03
     b3c:	fc 81       	ldd	r31, Y+4	; 0x04
     b3e:	81 e1       	ldi	r24, 0x11	; 17
     b40:	80 83       	st	Z, r24
	pxTopOfStack--;
     b42:	8b 81       	ldd	r24, Y+3	; 0x03
     b44:	9c 81       	ldd	r25, Y+4	; 0x04
     b46:	01 97       	sbiw	r24, 0x01	; 1
     b48:	9c 83       	std	Y+4, r25	; 0x04
     b4a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     b4c:	eb 81       	ldd	r30, Y+3	; 0x03
     b4e:	fc 81       	ldd	r31, Y+4	; 0x04
     b50:	82 e2       	ldi	r24, 0x22	; 34
     b52:	80 83       	st	Z, r24
	pxTopOfStack--;
     b54:	8b 81       	ldd	r24, Y+3	; 0x03
     b56:	9c 81       	ldd	r25, Y+4	; 0x04
     b58:	01 97       	sbiw	r24, 0x01	; 1
     b5a:	9c 83       	std	Y+4, r25	; 0x04
     b5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     b5e:	eb 81       	ldd	r30, Y+3	; 0x03
     b60:	fc 81       	ldd	r31, Y+4	; 0x04
     b62:	83 e3       	ldi	r24, 0x33	; 51
     b64:	80 83       	st	Z, r24
	pxTopOfStack--;
     b66:	8b 81       	ldd	r24, Y+3	; 0x03
     b68:	9c 81       	ldd	r25, Y+4	; 0x04
     b6a:	01 97       	sbiw	r24, 0x01	; 1
     b6c:	9c 83       	std	Y+4, r25	; 0x04
     b6e:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
     b70:	8d 81       	ldd	r24, Y+5	; 0x05
     b72:	9e 81       	ldd	r25, Y+6	; 0x06
     b74:	9a 83       	std	Y+2, r25	; 0x02
     b76:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     b78:	89 81       	ldd	r24, Y+1	; 0x01
     b7a:	eb 81       	ldd	r30, Y+3	; 0x03
     b7c:	fc 81       	ldd	r31, Y+4	; 0x04
     b7e:	80 83       	st	Z, r24
	pxTopOfStack--;
     b80:	8b 81       	ldd	r24, Y+3	; 0x03
     b82:	9c 81       	ldd	r25, Y+4	; 0x04
     b84:	01 97       	sbiw	r24, 0x01	; 1
     b86:	9c 83       	std	Y+4, r25	; 0x04
     b88:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     b8a:	89 81       	ldd	r24, Y+1	; 0x01
     b8c:	9a 81       	ldd	r25, Y+2	; 0x02
     b8e:	89 2f       	mov	r24, r25
     b90:	99 27       	eor	r25, r25
     b92:	9a 83       	std	Y+2, r25	; 0x02
     b94:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     b96:	89 81       	ldd	r24, Y+1	; 0x01
     b98:	eb 81       	ldd	r30, Y+3	; 0x03
     b9a:	fc 81       	ldd	r31, Y+4	; 0x04
     b9c:	80 83       	st	Z, r24
	pxTopOfStack--;
     b9e:	8b 81       	ldd	r24, Y+3	; 0x03
     ba0:	9c 81       	ldd	r25, Y+4	; 0x04
     ba2:	01 97       	sbiw	r24, 0x01	; 1
     ba4:	9c 83       	std	Y+4, r25	; 0x04
     ba6:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     ba8:	eb 81       	ldd	r30, Y+3	; 0x03
     baa:	fc 81       	ldd	r31, Y+4	; 0x04
     bac:	10 82       	st	Z, r1
	pxTopOfStack--;
     bae:	8b 81       	ldd	r24, Y+3	; 0x03
     bb0:	9c 81       	ldd	r25, Y+4	; 0x04
     bb2:	01 97       	sbiw	r24, 0x01	; 1
     bb4:	9c 83       	std	Y+4, r25	; 0x04
     bb6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     bb8:	eb 81       	ldd	r30, Y+3	; 0x03
     bba:	fc 81       	ldd	r31, Y+4	; 0x04
     bbc:	80 e8       	ldi	r24, 0x80	; 128
     bbe:	80 83       	st	Z, r24
	pxTopOfStack--;
     bc0:	8b 81       	ldd	r24, Y+3	; 0x03
     bc2:	9c 81       	ldd	r25, Y+4	; 0x04
     bc4:	01 97       	sbiw	r24, 0x01	; 1
     bc6:	9c 83       	std	Y+4, r25	; 0x04
     bc8:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     bca:	eb 81       	ldd	r30, Y+3	; 0x03
     bcc:	fc 81       	ldd	r31, Y+4	; 0x04
     bce:	10 82       	st	Z, r1
	pxTopOfStack--;
     bd0:	8b 81       	ldd	r24, Y+3	; 0x03
     bd2:	9c 81       	ldd	r25, Y+4	; 0x04
     bd4:	01 97       	sbiw	r24, 0x01	; 1
     bd6:	9c 83       	std	Y+4, r25	; 0x04
     bd8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     bda:	eb 81       	ldd	r30, Y+3	; 0x03
     bdc:	fc 81       	ldd	r31, Y+4	; 0x04
     bde:	82 e0       	ldi	r24, 0x02	; 2
     be0:	80 83       	st	Z, r24
	pxTopOfStack--;
     be2:	8b 81       	ldd	r24, Y+3	; 0x03
     be4:	9c 81       	ldd	r25, Y+4	; 0x04
     be6:	01 97       	sbiw	r24, 0x01	; 1
     be8:	9c 83       	std	Y+4, r25	; 0x04
     bea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     bec:	eb 81       	ldd	r30, Y+3	; 0x03
     bee:	fc 81       	ldd	r31, Y+4	; 0x04
     bf0:	83 e0       	ldi	r24, 0x03	; 3
     bf2:	80 83       	st	Z, r24
	pxTopOfStack--;
     bf4:	8b 81       	ldd	r24, Y+3	; 0x03
     bf6:	9c 81       	ldd	r25, Y+4	; 0x04
     bf8:	01 97       	sbiw	r24, 0x01	; 1
     bfa:	9c 83       	std	Y+4, r25	; 0x04
     bfc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     bfe:	eb 81       	ldd	r30, Y+3	; 0x03
     c00:	fc 81       	ldd	r31, Y+4	; 0x04
     c02:	84 e0       	ldi	r24, 0x04	; 4
     c04:	80 83       	st	Z, r24
	pxTopOfStack--;
     c06:	8b 81       	ldd	r24, Y+3	; 0x03
     c08:	9c 81       	ldd	r25, Y+4	; 0x04
     c0a:	01 97       	sbiw	r24, 0x01	; 1
     c0c:	9c 83       	std	Y+4, r25	; 0x04
     c0e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     c10:	eb 81       	ldd	r30, Y+3	; 0x03
     c12:	fc 81       	ldd	r31, Y+4	; 0x04
     c14:	85 e0       	ldi	r24, 0x05	; 5
     c16:	80 83       	st	Z, r24
	pxTopOfStack--;
     c18:	8b 81       	ldd	r24, Y+3	; 0x03
     c1a:	9c 81       	ldd	r25, Y+4	; 0x04
     c1c:	01 97       	sbiw	r24, 0x01	; 1
     c1e:	9c 83       	std	Y+4, r25	; 0x04
     c20:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     c22:	eb 81       	ldd	r30, Y+3	; 0x03
     c24:	fc 81       	ldd	r31, Y+4	; 0x04
     c26:	86 e0       	ldi	r24, 0x06	; 6
     c28:	80 83       	st	Z, r24
	pxTopOfStack--;
     c2a:	8b 81       	ldd	r24, Y+3	; 0x03
     c2c:	9c 81       	ldd	r25, Y+4	; 0x04
     c2e:	01 97       	sbiw	r24, 0x01	; 1
     c30:	9c 83       	std	Y+4, r25	; 0x04
     c32:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     c34:	eb 81       	ldd	r30, Y+3	; 0x03
     c36:	fc 81       	ldd	r31, Y+4	; 0x04
     c38:	87 e0       	ldi	r24, 0x07	; 7
     c3a:	80 83       	st	Z, r24
	pxTopOfStack--;
     c3c:	8b 81       	ldd	r24, Y+3	; 0x03
     c3e:	9c 81       	ldd	r25, Y+4	; 0x04
     c40:	01 97       	sbiw	r24, 0x01	; 1
     c42:	9c 83       	std	Y+4, r25	; 0x04
     c44:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     c46:	eb 81       	ldd	r30, Y+3	; 0x03
     c48:	fc 81       	ldd	r31, Y+4	; 0x04
     c4a:	88 e0       	ldi	r24, 0x08	; 8
     c4c:	80 83       	st	Z, r24
	pxTopOfStack--;
     c4e:	8b 81       	ldd	r24, Y+3	; 0x03
     c50:	9c 81       	ldd	r25, Y+4	; 0x04
     c52:	01 97       	sbiw	r24, 0x01	; 1
     c54:	9c 83       	std	Y+4, r25	; 0x04
     c56:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     c58:	eb 81       	ldd	r30, Y+3	; 0x03
     c5a:	fc 81       	ldd	r31, Y+4	; 0x04
     c5c:	89 e0       	ldi	r24, 0x09	; 9
     c5e:	80 83       	st	Z, r24
	pxTopOfStack--;
     c60:	8b 81       	ldd	r24, Y+3	; 0x03
     c62:	9c 81       	ldd	r25, Y+4	; 0x04
     c64:	01 97       	sbiw	r24, 0x01	; 1
     c66:	9c 83       	std	Y+4, r25	; 0x04
     c68:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     c6a:	eb 81       	ldd	r30, Y+3	; 0x03
     c6c:	fc 81       	ldd	r31, Y+4	; 0x04
     c6e:	80 e1       	ldi	r24, 0x10	; 16
     c70:	80 83       	st	Z, r24
	pxTopOfStack--;
     c72:	8b 81       	ldd	r24, Y+3	; 0x03
     c74:	9c 81       	ldd	r25, Y+4	; 0x04
     c76:	01 97       	sbiw	r24, 0x01	; 1
     c78:	9c 83       	std	Y+4, r25	; 0x04
     c7a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     c7c:	eb 81       	ldd	r30, Y+3	; 0x03
     c7e:	fc 81       	ldd	r31, Y+4	; 0x04
     c80:	81 e1       	ldi	r24, 0x11	; 17
     c82:	80 83       	st	Z, r24
	pxTopOfStack--;
     c84:	8b 81       	ldd	r24, Y+3	; 0x03
     c86:	9c 81       	ldd	r25, Y+4	; 0x04
     c88:	01 97       	sbiw	r24, 0x01	; 1
     c8a:	9c 83       	std	Y+4, r25	; 0x04
     c8c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     c8e:	eb 81       	ldd	r30, Y+3	; 0x03
     c90:	fc 81       	ldd	r31, Y+4	; 0x04
     c92:	82 e1       	ldi	r24, 0x12	; 18
     c94:	80 83       	st	Z, r24
	pxTopOfStack--;
     c96:	8b 81       	ldd	r24, Y+3	; 0x03
     c98:	9c 81       	ldd	r25, Y+4	; 0x04
     c9a:	01 97       	sbiw	r24, 0x01	; 1
     c9c:	9c 83       	std	Y+4, r25	; 0x04
     c9e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     ca0:	eb 81       	ldd	r30, Y+3	; 0x03
     ca2:	fc 81       	ldd	r31, Y+4	; 0x04
     ca4:	83 e1       	ldi	r24, 0x13	; 19
     ca6:	80 83       	st	Z, r24
	pxTopOfStack--;
     ca8:	8b 81       	ldd	r24, Y+3	; 0x03
     caa:	9c 81       	ldd	r25, Y+4	; 0x04
     cac:	01 97       	sbiw	r24, 0x01	; 1
     cae:	9c 83       	std	Y+4, r25	; 0x04
     cb0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     cb2:	eb 81       	ldd	r30, Y+3	; 0x03
     cb4:	fc 81       	ldd	r31, Y+4	; 0x04
     cb6:	84 e1       	ldi	r24, 0x14	; 20
     cb8:	80 83       	st	Z, r24
	pxTopOfStack--;
     cba:	8b 81       	ldd	r24, Y+3	; 0x03
     cbc:	9c 81       	ldd	r25, Y+4	; 0x04
     cbe:	01 97       	sbiw	r24, 0x01	; 1
     cc0:	9c 83       	std	Y+4, r25	; 0x04
     cc2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     cc4:	eb 81       	ldd	r30, Y+3	; 0x03
     cc6:	fc 81       	ldd	r31, Y+4	; 0x04
     cc8:	85 e1       	ldi	r24, 0x15	; 21
     cca:	80 83       	st	Z, r24
	pxTopOfStack--;
     ccc:	8b 81       	ldd	r24, Y+3	; 0x03
     cce:	9c 81       	ldd	r25, Y+4	; 0x04
     cd0:	01 97       	sbiw	r24, 0x01	; 1
     cd2:	9c 83       	std	Y+4, r25	; 0x04
     cd4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     cd6:	eb 81       	ldd	r30, Y+3	; 0x03
     cd8:	fc 81       	ldd	r31, Y+4	; 0x04
     cda:	86 e1       	ldi	r24, 0x16	; 22
     cdc:	80 83       	st	Z, r24
	pxTopOfStack--;
     cde:	8b 81       	ldd	r24, Y+3	; 0x03
     ce0:	9c 81       	ldd	r25, Y+4	; 0x04
     ce2:	01 97       	sbiw	r24, 0x01	; 1
     ce4:	9c 83       	std	Y+4, r25	; 0x04
     ce6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     ce8:	eb 81       	ldd	r30, Y+3	; 0x03
     cea:	fc 81       	ldd	r31, Y+4	; 0x04
     cec:	87 e1       	ldi	r24, 0x17	; 23
     cee:	80 83       	st	Z, r24
	pxTopOfStack--;
     cf0:	8b 81       	ldd	r24, Y+3	; 0x03
     cf2:	9c 81       	ldd	r25, Y+4	; 0x04
     cf4:	01 97       	sbiw	r24, 0x01	; 1
     cf6:	9c 83       	std	Y+4, r25	; 0x04
     cf8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     cfa:	eb 81       	ldd	r30, Y+3	; 0x03
     cfc:	fc 81       	ldd	r31, Y+4	; 0x04
     cfe:	88 e1       	ldi	r24, 0x18	; 24
     d00:	80 83       	st	Z, r24
	pxTopOfStack--;
     d02:	8b 81       	ldd	r24, Y+3	; 0x03
     d04:	9c 81       	ldd	r25, Y+4	; 0x04
     d06:	01 97       	sbiw	r24, 0x01	; 1
     d08:	9c 83       	std	Y+4, r25	; 0x04
     d0a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     d0c:	eb 81       	ldd	r30, Y+3	; 0x03
     d0e:	fc 81       	ldd	r31, Y+4	; 0x04
     d10:	89 e1       	ldi	r24, 0x19	; 25
     d12:	80 83       	st	Z, r24
	pxTopOfStack--;
     d14:	8b 81       	ldd	r24, Y+3	; 0x03
     d16:	9c 81       	ldd	r25, Y+4	; 0x04
     d18:	01 97       	sbiw	r24, 0x01	; 1
     d1a:	9c 83       	std	Y+4, r25	; 0x04
     d1c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     d1e:	eb 81       	ldd	r30, Y+3	; 0x03
     d20:	fc 81       	ldd	r31, Y+4	; 0x04
     d22:	80 e2       	ldi	r24, 0x20	; 32
     d24:	80 83       	st	Z, r24
	pxTopOfStack--;
     d26:	8b 81       	ldd	r24, Y+3	; 0x03
     d28:	9c 81       	ldd	r25, Y+4	; 0x04
     d2a:	01 97       	sbiw	r24, 0x01	; 1
     d2c:	9c 83       	std	Y+4, r25	; 0x04
     d2e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     d30:	eb 81       	ldd	r30, Y+3	; 0x03
     d32:	fc 81       	ldd	r31, Y+4	; 0x04
     d34:	81 e2       	ldi	r24, 0x21	; 33
     d36:	80 83       	st	Z, r24
	pxTopOfStack--;
     d38:	8b 81       	ldd	r24, Y+3	; 0x03
     d3a:	9c 81       	ldd	r25, Y+4	; 0x04
     d3c:	01 97       	sbiw	r24, 0x01	; 1
     d3e:	9c 83       	std	Y+4, r25	; 0x04
     d40:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     d42:	eb 81       	ldd	r30, Y+3	; 0x03
     d44:	fc 81       	ldd	r31, Y+4	; 0x04
     d46:	82 e2       	ldi	r24, 0x22	; 34
     d48:	80 83       	st	Z, r24
	pxTopOfStack--;
     d4a:	8b 81       	ldd	r24, Y+3	; 0x03
     d4c:	9c 81       	ldd	r25, Y+4	; 0x04
     d4e:	01 97       	sbiw	r24, 0x01	; 1
     d50:	9c 83       	std	Y+4, r25	; 0x04
     d52:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     d54:	eb 81       	ldd	r30, Y+3	; 0x03
     d56:	fc 81       	ldd	r31, Y+4	; 0x04
     d58:	83 e2       	ldi	r24, 0x23	; 35
     d5a:	80 83       	st	Z, r24
	pxTopOfStack--;
     d5c:	8b 81       	ldd	r24, Y+3	; 0x03
     d5e:	9c 81       	ldd	r25, Y+4	; 0x04
     d60:	01 97       	sbiw	r24, 0x01	; 1
     d62:	9c 83       	std	Y+4, r25	; 0x04
     d64:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
     d66:	8f 81       	ldd	r24, Y+7	; 0x07
     d68:	98 85       	ldd	r25, Y+8	; 0x08
     d6a:	9a 83       	std	Y+2, r25	; 0x02
     d6c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     d6e:	89 81       	ldd	r24, Y+1	; 0x01
     d70:	eb 81       	ldd	r30, Y+3	; 0x03
     d72:	fc 81       	ldd	r31, Y+4	; 0x04
     d74:	80 83       	st	Z, r24
	pxTopOfStack--;
     d76:	8b 81       	ldd	r24, Y+3	; 0x03
     d78:	9c 81       	ldd	r25, Y+4	; 0x04
     d7a:	01 97       	sbiw	r24, 0x01	; 1
     d7c:	9c 83       	std	Y+4, r25	; 0x04
     d7e:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     d80:	89 81       	ldd	r24, Y+1	; 0x01
     d82:	9a 81       	ldd	r25, Y+2	; 0x02
     d84:	89 2f       	mov	r24, r25
     d86:	99 27       	eor	r25, r25
     d88:	9a 83       	std	Y+2, r25	; 0x02
     d8a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     d8c:	89 81       	ldd	r24, Y+1	; 0x01
     d8e:	eb 81       	ldd	r30, Y+3	; 0x03
     d90:	fc 81       	ldd	r31, Y+4	; 0x04
     d92:	80 83       	st	Z, r24
	pxTopOfStack--;
     d94:	8b 81       	ldd	r24, Y+3	; 0x03
     d96:	9c 81       	ldd	r25, Y+4	; 0x04
     d98:	01 97       	sbiw	r24, 0x01	; 1
     d9a:	9c 83       	std	Y+4, r25	; 0x04
     d9c:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     d9e:	eb 81       	ldd	r30, Y+3	; 0x03
     da0:	fc 81       	ldd	r31, Y+4	; 0x04
     da2:	86 e2       	ldi	r24, 0x26	; 38
     da4:	80 83       	st	Z, r24
	pxTopOfStack--;
     da6:	8b 81       	ldd	r24, Y+3	; 0x03
     da8:	9c 81       	ldd	r25, Y+4	; 0x04
     daa:	01 97       	sbiw	r24, 0x01	; 1
     dac:	9c 83       	std	Y+4, r25	; 0x04
     dae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     db0:	eb 81       	ldd	r30, Y+3	; 0x03
     db2:	fc 81       	ldd	r31, Y+4	; 0x04
     db4:	87 e2       	ldi	r24, 0x27	; 39
     db6:	80 83       	st	Z, r24
	pxTopOfStack--;
     db8:	8b 81       	ldd	r24, Y+3	; 0x03
     dba:	9c 81       	ldd	r25, Y+4	; 0x04
     dbc:	01 97       	sbiw	r24, 0x01	; 1
     dbe:	9c 83       	std	Y+4, r25	; 0x04
     dc0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     dc2:	eb 81       	ldd	r30, Y+3	; 0x03
     dc4:	fc 81       	ldd	r31, Y+4	; 0x04
     dc6:	88 e2       	ldi	r24, 0x28	; 40
     dc8:	80 83       	st	Z, r24
	pxTopOfStack--;
     dca:	8b 81       	ldd	r24, Y+3	; 0x03
     dcc:	9c 81       	ldd	r25, Y+4	; 0x04
     dce:	01 97       	sbiw	r24, 0x01	; 1
     dd0:	9c 83       	std	Y+4, r25	; 0x04
     dd2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     dd4:	eb 81       	ldd	r30, Y+3	; 0x03
     dd6:	fc 81       	ldd	r31, Y+4	; 0x04
     dd8:	89 e2       	ldi	r24, 0x29	; 41
     dda:	80 83       	st	Z, r24
	pxTopOfStack--;
     ddc:	8b 81       	ldd	r24, Y+3	; 0x03
     dde:	9c 81       	ldd	r25, Y+4	; 0x04
     de0:	01 97       	sbiw	r24, 0x01	; 1
     de2:	9c 83       	std	Y+4, r25	; 0x04
     de4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     de6:	eb 81       	ldd	r30, Y+3	; 0x03
     de8:	fc 81       	ldd	r31, Y+4	; 0x04
     dea:	80 e3       	ldi	r24, 0x30	; 48
     dec:	80 83       	st	Z, r24
	pxTopOfStack--;
     dee:	8b 81       	ldd	r24, Y+3	; 0x03
     df0:	9c 81       	ldd	r25, Y+4	; 0x04
     df2:	01 97       	sbiw	r24, 0x01	; 1
     df4:	9c 83       	std	Y+4, r25	; 0x04
     df6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     df8:	eb 81       	ldd	r30, Y+3	; 0x03
     dfa:	fc 81       	ldd	r31, Y+4	; 0x04
     dfc:	81 e3       	ldi	r24, 0x31	; 49
     dfe:	80 83       	st	Z, r24
	pxTopOfStack--;
     e00:	8b 81       	ldd	r24, Y+3	; 0x03
     e02:	9c 81       	ldd	r25, Y+4	; 0x04
     e04:	01 97       	sbiw	r24, 0x01	; 1
     e06:	9c 83       	std	Y+4, r25	; 0x04
     e08:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     e0a:	8b 81       	ldd	r24, Y+3	; 0x03
     e0c:	9c 81       	ldd	r25, Y+4	; 0x04
}
     e0e:	28 96       	adiw	r28, 0x08	; 8
     e10:	0f b6       	in	r0, 0x3f	; 63
     e12:	f8 94       	cli
     e14:	de bf       	out	0x3e, r29	; 62
     e16:	0f be       	out	0x3f, r0	; 63
     e18:	cd bf       	out	0x3d, r28	; 61
     e1a:	cf 91       	pop	r28
     e1c:	df 91       	pop	r29
     e1e:	08 95       	ret

00000e20 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
     e20:	df 93       	push	r29
     e22:	cf 93       	push	r28
     e24:	cd b7       	in	r28, 0x3d	; 61
     e26:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     e28:	0e 94 00 08 	call	0x1000	; 0x1000 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     e2c:	a0 91 0f 03 	lds	r26, 0x030F
     e30:	b0 91 10 03 	lds	r27, 0x0310
     e34:	cd 91       	ld	r28, X+
     e36:	cd bf       	out	0x3d, r28	; 61
     e38:	dd 91       	ld	r29, X+
     e3a:	de bf       	out	0x3e, r29	; 62
     e3c:	ff 91       	pop	r31
     e3e:	ef 91       	pop	r30
     e40:	df 91       	pop	r29
     e42:	cf 91       	pop	r28
     e44:	bf 91       	pop	r27
     e46:	af 91       	pop	r26
     e48:	9f 91       	pop	r25
     e4a:	8f 91       	pop	r24
     e4c:	7f 91       	pop	r23
     e4e:	6f 91       	pop	r22
     e50:	5f 91       	pop	r21
     e52:	4f 91       	pop	r20
     e54:	3f 91       	pop	r19
     e56:	2f 91       	pop	r18
     e58:	1f 91       	pop	r17
     e5a:	0f 91       	pop	r16
     e5c:	ff 90       	pop	r15
     e5e:	ef 90       	pop	r14
     e60:	df 90       	pop	r13
     e62:	cf 90       	pop	r12
     e64:	bf 90       	pop	r11
     e66:	af 90       	pop	r10
     e68:	9f 90       	pop	r9
     e6a:	8f 90       	pop	r8
     e6c:	7f 90       	pop	r7
     e6e:	6f 90       	pop	r6
     e70:	5f 90       	pop	r5
     e72:	4f 90       	pop	r4
     e74:	3f 90       	pop	r3
     e76:	2f 90       	pop	r2
     e78:	1f 90       	pop	r1
     e7a:	0f 90       	pop	r0
     e7c:	0f be       	out	0x3f, r0	; 63
     e7e:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     e80:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     e82:	81 e0       	ldi	r24, 0x01	; 1
}
     e84:	cf 91       	pop	r28
     e86:	df 91       	pop	r29
     e88:	08 95       	ret

00000e8a <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     e8a:	df 93       	push	r29
     e8c:	cf 93       	push	r28
     e8e:	cd b7       	in	r28, 0x3d	; 61
     e90:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     e92:	cf 91       	pop	r28
     e94:	df 91       	pop	r29
     e96:	08 95       	ret

00000e98 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     e98:	0f 92       	push	r0
     e9a:	0f b6       	in	r0, 0x3f	; 63
     e9c:	f8 94       	cli
     e9e:	0f 92       	push	r0
     ea0:	1f 92       	push	r1
     ea2:	11 24       	eor	r1, r1
     ea4:	2f 92       	push	r2
     ea6:	3f 92       	push	r3
     ea8:	4f 92       	push	r4
     eaa:	5f 92       	push	r5
     eac:	6f 92       	push	r6
     eae:	7f 92       	push	r7
     eb0:	8f 92       	push	r8
     eb2:	9f 92       	push	r9
     eb4:	af 92       	push	r10
     eb6:	bf 92       	push	r11
     eb8:	cf 92       	push	r12
     eba:	df 92       	push	r13
     ebc:	ef 92       	push	r14
     ebe:	ff 92       	push	r15
     ec0:	0f 93       	push	r16
     ec2:	1f 93       	push	r17
     ec4:	2f 93       	push	r18
     ec6:	3f 93       	push	r19
     ec8:	4f 93       	push	r20
     eca:	5f 93       	push	r21
     ecc:	6f 93       	push	r22
     ece:	7f 93       	push	r23
     ed0:	8f 93       	push	r24
     ed2:	9f 93       	push	r25
     ed4:	af 93       	push	r26
     ed6:	bf 93       	push	r27
     ed8:	cf 93       	push	r28
     eda:	df 93       	push	r29
     edc:	ef 93       	push	r30
     ede:	ff 93       	push	r31
     ee0:	a0 91 0f 03 	lds	r26, 0x030F
     ee4:	b0 91 10 03 	lds	r27, 0x0310
     ee8:	0d b6       	in	r0, 0x3d	; 61
     eea:	0d 92       	st	X+, r0
     eec:	0e b6       	in	r0, 0x3e	; 62
     eee:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     ef0:	0e 94 bc 10 	call	0x2178	; 0x2178 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     ef4:	a0 91 0f 03 	lds	r26, 0x030F
     ef8:	b0 91 10 03 	lds	r27, 0x0310
     efc:	cd 91       	ld	r28, X+
     efe:	cd bf       	out	0x3d, r28	; 61
     f00:	dd 91       	ld	r29, X+
     f02:	de bf       	out	0x3e, r29	; 62
     f04:	ff 91       	pop	r31
     f06:	ef 91       	pop	r30
     f08:	df 91       	pop	r29
     f0a:	cf 91       	pop	r28
     f0c:	bf 91       	pop	r27
     f0e:	af 91       	pop	r26
     f10:	9f 91       	pop	r25
     f12:	8f 91       	pop	r24
     f14:	7f 91       	pop	r23
     f16:	6f 91       	pop	r22
     f18:	5f 91       	pop	r21
     f1a:	4f 91       	pop	r20
     f1c:	3f 91       	pop	r19
     f1e:	2f 91       	pop	r18
     f20:	1f 91       	pop	r17
     f22:	0f 91       	pop	r16
     f24:	ff 90       	pop	r15
     f26:	ef 90       	pop	r14
     f28:	df 90       	pop	r13
     f2a:	cf 90       	pop	r12
     f2c:	bf 90       	pop	r11
     f2e:	af 90       	pop	r10
     f30:	9f 90       	pop	r9
     f32:	8f 90       	pop	r8
     f34:	7f 90       	pop	r7
     f36:	6f 90       	pop	r6
     f38:	5f 90       	pop	r5
     f3a:	4f 90       	pop	r4
     f3c:	3f 90       	pop	r3
     f3e:	2f 90       	pop	r2
     f40:	1f 90       	pop	r1
     f42:	0f 90       	pop	r0
     f44:	0f be       	out	0x3f, r0	; 63
     f46:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f48:	08 95       	ret

00000f4a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     f4a:	0f 92       	push	r0
     f4c:	0f b6       	in	r0, 0x3f	; 63
     f4e:	f8 94       	cli
     f50:	0f 92       	push	r0
     f52:	1f 92       	push	r1
     f54:	11 24       	eor	r1, r1
     f56:	2f 92       	push	r2
     f58:	3f 92       	push	r3
     f5a:	4f 92       	push	r4
     f5c:	5f 92       	push	r5
     f5e:	6f 92       	push	r6
     f60:	7f 92       	push	r7
     f62:	8f 92       	push	r8
     f64:	9f 92       	push	r9
     f66:	af 92       	push	r10
     f68:	bf 92       	push	r11
     f6a:	cf 92       	push	r12
     f6c:	df 92       	push	r13
     f6e:	ef 92       	push	r14
     f70:	ff 92       	push	r15
     f72:	0f 93       	push	r16
     f74:	1f 93       	push	r17
     f76:	2f 93       	push	r18
     f78:	3f 93       	push	r19
     f7a:	4f 93       	push	r20
     f7c:	5f 93       	push	r21
     f7e:	6f 93       	push	r22
     f80:	7f 93       	push	r23
     f82:	8f 93       	push	r24
     f84:	9f 93       	push	r25
     f86:	af 93       	push	r26
     f88:	bf 93       	push	r27
     f8a:	cf 93       	push	r28
     f8c:	df 93       	push	r29
     f8e:	ef 93       	push	r30
     f90:	ff 93       	push	r31
     f92:	a0 91 0f 03 	lds	r26, 0x030F
     f96:	b0 91 10 03 	lds	r27, 0x0310
     f9a:	0d b6       	in	r0, 0x3d	; 61
     f9c:	0d 92       	st	X+, r0
     f9e:	0e b6       	in	r0, 0x3e	; 62
     fa0:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     fa2:	0e 94 e7 0f 	call	0x1fce	; 0x1fce <vTaskIncrementTick>
	vTaskSwitchContext();
     fa6:	0e 94 bc 10 	call	0x2178	; 0x2178 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     faa:	a0 91 0f 03 	lds	r26, 0x030F
     fae:	b0 91 10 03 	lds	r27, 0x0310
     fb2:	cd 91       	ld	r28, X+
     fb4:	cd bf       	out	0x3d, r28	; 61
     fb6:	dd 91       	ld	r29, X+
     fb8:	de bf       	out	0x3e, r29	; 62
     fba:	ff 91       	pop	r31
     fbc:	ef 91       	pop	r30
     fbe:	df 91       	pop	r29
     fc0:	cf 91       	pop	r28
     fc2:	bf 91       	pop	r27
     fc4:	af 91       	pop	r26
     fc6:	9f 91       	pop	r25
     fc8:	8f 91       	pop	r24
     fca:	7f 91       	pop	r23
     fcc:	6f 91       	pop	r22
     fce:	5f 91       	pop	r21
     fd0:	4f 91       	pop	r20
     fd2:	3f 91       	pop	r19
     fd4:	2f 91       	pop	r18
     fd6:	1f 91       	pop	r17
     fd8:	0f 91       	pop	r16
     fda:	ff 90       	pop	r15
     fdc:	ef 90       	pop	r14
     fde:	df 90       	pop	r13
     fe0:	cf 90       	pop	r12
     fe2:	bf 90       	pop	r11
     fe4:	af 90       	pop	r10
     fe6:	9f 90       	pop	r9
     fe8:	8f 90       	pop	r8
     fea:	7f 90       	pop	r7
     fec:	6f 90       	pop	r6
     fee:	5f 90       	pop	r5
     ff0:	4f 90       	pop	r4
     ff2:	3f 90       	pop	r3
     ff4:	2f 90       	pop	r2
     ff6:	1f 90       	pop	r1
     ff8:	0f 90       	pop	r0
     ffa:	0f be       	out	0x3f, r0	; 63
     ffc:	0f 90       	pop	r0

	asm volatile ( "ret" );
     ffe:	08 95       	ret

00001000 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1000:	df 93       	push	r29
    1002:	cf 93       	push	r28
    1004:	00 d0       	rcall	.+0      	; 0x1006 <prvSetupTimerInterrupt+0x6>
    1006:	00 d0       	rcall	.+0      	; 0x1008 <prvSetupTimerInterrupt+0x8>
    1008:	00 d0       	rcall	.+0      	; 0x100a <prvSetupTimerInterrupt+0xa>
    100a:	cd b7       	in	r28, 0x3d	; 61
    100c:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    100e:	80 e4       	ldi	r24, 0x40	; 64
    1010:	9f e1       	ldi	r25, 0x1F	; 31
    1012:	a0 e0       	ldi	r26, 0x00	; 0
    1014:	b0 e0       	ldi	r27, 0x00	; 0
    1016:	8b 83       	std	Y+3, r24	; 0x03
    1018:	9c 83       	std	Y+4, r25	; 0x04
    101a:	ad 83       	std	Y+5, r26	; 0x05
    101c:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    101e:	8b 81       	ldd	r24, Y+3	; 0x03
    1020:	9c 81       	ldd	r25, Y+4	; 0x04
    1022:	ad 81       	ldd	r26, Y+5	; 0x05
    1024:	be 81       	ldd	r27, Y+6	; 0x06
    1026:	68 94       	set
    1028:	15 f8       	bld	r1, 5
    102a:	b6 95       	lsr	r27
    102c:	a7 95       	ror	r26
    102e:	97 95       	ror	r25
    1030:	87 95       	ror	r24
    1032:	16 94       	lsr	r1
    1034:	d1 f7       	brne	.-12     	; 0x102a <prvSetupTimerInterrupt+0x2a>
    1036:	8b 83       	std	Y+3, r24	; 0x03
    1038:	9c 83       	std	Y+4, r25	; 0x04
    103a:	ad 83       	std	Y+5, r26	; 0x05
    103c:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    103e:	8b 81       	ldd	r24, Y+3	; 0x03
    1040:	9c 81       	ldd	r25, Y+4	; 0x04
    1042:	ad 81       	ldd	r26, Y+5	; 0x05
    1044:	be 81       	ldd	r27, Y+6	; 0x06
    1046:	01 97       	sbiw	r24, 0x01	; 1
    1048:	a1 09       	sbc	r26, r1
    104a:	b1 09       	sbc	r27, r1
    104c:	8b 83       	std	Y+3, r24	; 0x03
    104e:	9c 83       	std	Y+4, r25	; 0x04
    1050:	ad 83       	std	Y+5, r26	; 0x05
    1052:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1054:	8b 81       	ldd	r24, Y+3	; 0x03
    1056:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1058:	8b 81       	ldd	r24, Y+3	; 0x03
    105a:	9c 81       	ldd	r25, Y+4	; 0x04
    105c:	ad 81       	ldd	r26, Y+5	; 0x05
    105e:	be 81       	ldd	r27, Y+6	; 0x06
    1060:	89 2f       	mov	r24, r25
    1062:	9a 2f       	mov	r25, r26
    1064:	ab 2f       	mov	r26, r27
    1066:	bb 27       	eor	r27, r27
    1068:	8b 83       	std	Y+3, r24	; 0x03
    106a:	9c 83       	std	Y+4, r25	; 0x04
    106c:	ad 83       	std	Y+5, r26	; 0x05
    106e:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1070:	8b 81       	ldd	r24, Y+3	; 0x03
    1072:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1074:	eb e4       	ldi	r30, 0x4B	; 75
    1076:	f0 e0       	ldi	r31, 0x00	; 0
    1078:	8a 81       	ldd	r24, Y+2	; 0x02
    107a:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    107c:	ea e4       	ldi	r30, 0x4A	; 74
    107e:	f0 e0       	ldi	r31, 0x00	; 0
    1080:	89 81       	ldd	r24, Y+1	; 0x01
    1082:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1084:	8b e0       	ldi	r24, 0x0B	; 11
    1086:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1088:	ee e4       	ldi	r30, 0x4E	; 78
    108a:	f0 e0       	ldi	r31, 0x00	; 0
    108c:	89 81       	ldd	r24, Y+1	; 0x01
    108e:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1090:	e9 e5       	ldi	r30, 0x59	; 89
    1092:	f0 e0       	ldi	r31, 0x00	; 0
    1094:	80 81       	ld	r24, Z
    1096:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1098:	89 81       	ldd	r24, Y+1	; 0x01
    109a:	80 61       	ori	r24, 0x10	; 16
    109c:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    109e:	e9 e5       	ldi	r30, 0x59	; 89
    10a0:	f0 e0       	ldi	r31, 0x00	; 0
    10a2:	89 81       	ldd	r24, Y+1	; 0x01
    10a4:	80 83       	st	Z, r24
}
    10a6:	26 96       	adiw	r28, 0x06	; 6
    10a8:	0f b6       	in	r0, 0x3f	; 63
    10aa:	f8 94       	cli
    10ac:	de bf       	out	0x3e, r29	; 62
    10ae:	0f be       	out	0x3f, r0	; 63
    10b0:	cd bf       	out	0x3d, r28	; 61
    10b2:	cf 91       	pop	r28
    10b4:	df 91       	pop	r29
    10b6:	08 95       	ret

000010b8 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    10b8:	0e 94 a5 07 	call	0xf4a	; 0xf4a <vPortYieldFromTick>
		asm volatile ( "reti" );
    10bc:	18 95       	reti

000010be <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    10be:	df 93       	push	r29
    10c0:	cf 93       	push	r28
    10c2:	cd b7       	in	r28, 0x3d	; 61
    10c4:	de b7       	in	r29, 0x3e	; 62
    10c6:	28 97       	sbiw	r28, 0x08	; 8
    10c8:	0f b6       	in	r0, 0x3f	; 63
    10ca:	f8 94       	cli
    10cc:	de bf       	out	0x3e, r29	; 62
    10ce:	0f be       	out	0x3f, r0	; 63
    10d0:	cd bf       	out	0x3d, r28	; 61
    10d2:	8f 83       	std	Y+7, r24	; 0x07
    10d4:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    10d6:	1a 82       	std	Y+2, r1	; 0x02
    10d8:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    10da:	8f 81       	ldd	r24, Y+7	; 0x07
    10dc:	88 23       	and	r24, r24
    10de:	09 f4       	brne	.+2      	; 0x10e2 <xQueueCreate+0x24>
    10e0:	8c c0       	rjmp	.+280    	; 0x11fa <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    10e2:	8f e1       	ldi	r24, 0x1F	; 31
    10e4:	90 e0       	ldi	r25, 0x00	; 0
    10e6:	0e 94 e6 03 	call	0x7cc	; 0x7cc <pvPortMalloc>
    10ea:	9e 83       	std	Y+6, r25	; 0x06
    10ec:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    10ee:	8d 81       	ldd	r24, Y+5	; 0x05
    10f0:	9e 81       	ldd	r25, Y+6	; 0x06
    10f2:	00 97       	sbiw	r24, 0x00	; 0
    10f4:	09 f4       	brne	.+2      	; 0x10f8 <xQueueCreate+0x3a>
    10f6:	81 c0       	rjmp	.+258    	; 0x11fa <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    10f8:	8f 81       	ldd	r24, Y+7	; 0x07
    10fa:	28 2f       	mov	r18, r24
    10fc:	30 e0       	ldi	r19, 0x00	; 0
    10fe:	88 85       	ldd	r24, Y+8	; 0x08
    1100:	88 2f       	mov	r24, r24
    1102:	90 e0       	ldi	r25, 0x00	; 0
    1104:	ac 01       	movw	r20, r24
    1106:	24 9f       	mul	r18, r20
    1108:	c0 01       	movw	r24, r0
    110a:	25 9f       	mul	r18, r21
    110c:	90 0d       	add	r25, r0
    110e:	34 9f       	mul	r19, r20
    1110:	90 0d       	add	r25, r0
    1112:	11 24       	eor	r1, r1
    1114:	01 96       	adiw	r24, 0x01	; 1
    1116:	9c 83       	std	Y+4, r25	; 0x04
    1118:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    111a:	8b 81       	ldd	r24, Y+3	; 0x03
    111c:	9c 81       	ldd	r25, Y+4	; 0x04
    111e:	0e 94 e6 03 	call	0x7cc	; 0x7cc <pvPortMalloc>
    1122:	ed 81       	ldd	r30, Y+5	; 0x05
    1124:	fe 81       	ldd	r31, Y+6	; 0x06
    1126:	91 83       	std	Z+1, r25	; 0x01
    1128:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    112a:	ed 81       	ldd	r30, Y+5	; 0x05
    112c:	fe 81       	ldd	r31, Y+6	; 0x06
    112e:	80 81       	ld	r24, Z
    1130:	91 81       	ldd	r25, Z+1	; 0x01
    1132:	00 97       	sbiw	r24, 0x00	; 0
    1134:	09 f4       	brne	.+2      	; 0x1138 <xQueueCreate+0x7a>
    1136:	5d c0       	rjmp	.+186    	; 0x11f2 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    1138:	ed 81       	ldd	r30, Y+5	; 0x05
    113a:	fe 81       	ldd	r31, Y+6	; 0x06
    113c:	40 81       	ld	r20, Z
    113e:	51 81       	ldd	r21, Z+1	; 0x01
    1140:	8f 81       	ldd	r24, Y+7	; 0x07
    1142:	28 2f       	mov	r18, r24
    1144:	30 e0       	ldi	r19, 0x00	; 0
    1146:	88 85       	ldd	r24, Y+8	; 0x08
    1148:	88 2f       	mov	r24, r24
    114a:	90 e0       	ldi	r25, 0x00	; 0
    114c:	bc 01       	movw	r22, r24
    114e:	26 9f       	mul	r18, r22
    1150:	c0 01       	movw	r24, r0
    1152:	27 9f       	mul	r18, r23
    1154:	90 0d       	add	r25, r0
    1156:	36 9f       	mul	r19, r22
    1158:	90 0d       	add	r25, r0
    115a:	11 24       	eor	r1, r1
    115c:	84 0f       	add	r24, r20
    115e:	95 1f       	adc	r25, r21
    1160:	ed 81       	ldd	r30, Y+5	; 0x05
    1162:	fe 81       	ldd	r31, Y+6	; 0x06
    1164:	93 83       	std	Z+3, r25	; 0x03
    1166:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1168:	ed 81       	ldd	r30, Y+5	; 0x05
    116a:	fe 81       	ldd	r31, Y+6	; 0x06
    116c:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    116e:	ed 81       	ldd	r30, Y+5	; 0x05
    1170:	fe 81       	ldd	r31, Y+6	; 0x06
    1172:	80 81       	ld	r24, Z
    1174:	91 81       	ldd	r25, Z+1	; 0x01
    1176:	ed 81       	ldd	r30, Y+5	; 0x05
    1178:	fe 81       	ldd	r31, Y+6	; 0x06
    117a:	95 83       	std	Z+5, r25	; 0x05
    117c:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    117e:	ed 81       	ldd	r30, Y+5	; 0x05
    1180:	fe 81       	ldd	r31, Y+6	; 0x06
    1182:	40 81       	ld	r20, Z
    1184:	51 81       	ldd	r21, Z+1	; 0x01
    1186:	8f 81       	ldd	r24, Y+7	; 0x07
    1188:	88 2f       	mov	r24, r24
    118a:	90 e0       	ldi	r25, 0x00	; 0
    118c:	9c 01       	movw	r18, r24
    118e:	21 50       	subi	r18, 0x01	; 1
    1190:	30 40       	sbci	r19, 0x00	; 0
    1192:	88 85       	ldd	r24, Y+8	; 0x08
    1194:	88 2f       	mov	r24, r24
    1196:	90 e0       	ldi	r25, 0x00	; 0
    1198:	bc 01       	movw	r22, r24
    119a:	26 9f       	mul	r18, r22
    119c:	c0 01       	movw	r24, r0
    119e:	27 9f       	mul	r18, r23
    11a0:	90 0d       	add	r25, r0
    11a2:	36 9f       	mul	r19, r22
    11a4:	90 0d       	add	r25, r0
    11a6:	11 24       	eor	r1, r1
    11a8:	84 0f       	add	r24, r20
    11aa:	95 1f       	adc	r25, r21
    11ac:	ed 81       	ldd	r30, Y+5	; 0x05
    11ae:	fe 81       	ldd	r31, Y+6	; 0x06
    11b0:	97 83       	std	Z+7, r25	; 0x07
    11b2:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    11b4:	ed 81       	ldd	r30, Y+5	; 0x05
    11b6:	fe 81       	ldd	r31, Y+6	; 0x06
    11b8:	8f 81       	ldd	r24, Y+7	; 0x07
    11ba:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    11bc:	ed 81       	ldd	r30, Y+5	; 0x05
    11be:	fe 81       	ldd	r31, Y+6	; 0x06
    11c0:	88 85       	ldd	r24, Y+8	; 0x08
    11c2:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    11c4:	ed 81       	ldd	r30, Y+5	; 0x05
    11c6:	fe 81       	ldd	r31, Y+6	; 0x06
    11c8:	8f ef       	ldi	r24, 0xFF	; 255
    11ca:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    11cc:	ed 81       	ldd	r30, Y+5	; 0x05
    11ce:	fe 81       	ldd	r31, Y+6	; 0x06
    11d0:	8f ef       	ldi	r24, 0xFF	; 255
    11d2:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    11d4:	8d 81       	ldd	r24, Y+5	; 0x05
    11d6:	9e 81       	ldd	r25, Y+6	; 0x06
    11d8:	08 96       	adiw	r24, 0x08	; 8
    11da:	0e 94 52 04 	call	0x8a4	; 0x8a4 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    11de:	8d 81       	ldd	r24, Y+5	; 0x05
    11e0:	9e 81       	ldd	r25, Y+6	; 0x06
    11e2:	41 96       	adiw	r24, 0x11	; 17
    11e4:	0e 94 52 04 	call	0x8a4	; 0x8a4 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    11e8:	8d 81       	ldd	r24, Y+5	; 0x05
    11ea:	9e 81       	ldd	r25, Y+6	; 0x06
    11ec:	9a 83       	std	Y+2, r25	; 0x02
    11ee:	89 83       	std	Y+1, r24	; 0x01
    11f0:	04 c0       	rjmp	.+8      	; 0x11fa <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    11f2:	8d 81       	ldd	r24, Y+5	; 0x05
    11f4:	9e 81       	ldd	r25, Y+6	; 0x06
    11f6:	0e 94 2c 04 	call	0x858	; 0x858 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    11fa:	89 81       	ldd	r24, Y+1	; 0x01
    11fc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    11fe:	28 96       	adiw	r28, 0x08	; 8
    1200:	0f b6       	in	r0, 0x3f	; 63
    1202:	f8 94       	cli
    1204:	de bf       	out	0x3e, r29	; 62
    1206:	0f be       	out	0x3f, r0	; 63
    1208:	cd bf       	out	0x3d, r28	; 61
    120a:	cf 91       	pop	r28
    120c:	df 91       	pop	r29
    120e:	08 95       	ret

00001210 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1210:	df 93       	push	r29
    1212:	cf 93       	push	r28
    1214:	cd b7       	in	r28, 0x3d	; 61
    1216:	de b7       	in	r29, 0x3e	; 62
    1218:	2c 97       	sbiw	r28, 0x0c	; 12
    121a:	0f b6       	in	r0, 0x3f	; 63
    121c:	f8 94       	cli
    121e:	de bf       	out	0x3e, r29	; 62
    1220:	0f be       	out	0x3f, r0	; 63
    1222:	cd bf       	out	0x3d, r28	; 61
    1224:	9e 83       	std	Y+6, r25	; 0x06
    1226:	8d 83       	std	Y+5, r24	; 0x05
    1228:	78 87       	std	Y+8, r23	; 0x08
    122a:	6f 83       	std	Y+7, r22	; 0x07
    122c:	5a 87       	std	Y+10, r21	; 0x0a
    122e:	49 87       	std	Y+9, r20	; 0x09
    1230:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1232:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1234:	0f b6       	in	r0, 0x3f	; 63
    1236:	f8 94       	cli
    1238:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    123a:	ed 81       	ldd	r30, Y+5	; 0x05
    123c:	fe 81       	ldd	r31, Y+6	; 0x06
    123e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1240:	ed 81       	ldd	r30, Y+5	; 0x05
    1242:	fe 81       	ldd	r31, Y+6	; 0x06
    1244:	83 8d       	ldd	r24, Z+27	; 0x1b
    1246:	98 17       	cp	r25, r24
    1248:	d8 f4       	brcc	.+54     	; 0x1280 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    124a:	8d 81       	ldd	r24, Y+5	; 0x05
    124c:	9e 81       	ldd	r25, Y+6	; 0x06
    124e:	2f 81       	ldd	r18, Y+7	; 0x07
    1250:	38 85       	ldd	r19, Y+8	; 0x08
    1252:	b9 01       	movw	r22, r18
    1254:	4b 85       	ldd	r20, Y+11	; 0x0b
    1256:	0e 94 43 0b 	call	0x1686	; 0x1686 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    125a:	ed 81       	ldd	r30, Y+5	; 0x05
    125c:	fe 81       	ldd	r31, Y+6	; 0x06
    125e:	81 89       	ldd	r24, Z+17	; 0x11
    1260:	88 23       	and	r24, r24
    1262:	49 f0       	breq	.+18     	; 0x1276 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1264:	8d 81       	ldd	r24, Y+5	; 0x05
    1266:	9e 81       	ldd	r25, Y+6	; 0x06
    1268:	41 96       	adiw	r24, 0x11	; 17
    126a:	0e 94 58 11 	call	0x22b0	; 0x22b0 <xTaskRemoveFromEventList>
    126e:	81 30       	cpi	r24, 0x01	; 1
    1270:	11 f4       	brne	.+4      	; 0x1276 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1272:	0e 94 4c 07 	call	0xe98	; 0xe98 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1276:	0f 90       	pop	r0
    1278:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    127a:	81 e0       	ldi	r24, 0x01	; 1
    127c:	8c 87       	std	Y+12, r24	; 0x0c
    127e:	5c c0       	rjmp	.+184    	; 0x1338 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1280:	89 85       	ldd	r24, Y+9	; 0x09
    1282:	9a 85       	ldd	r25, Y+10	; 0x0a
    1284:	00 97       	sbiw	r24, 0x00	; 0
    1286:	21 f4       	brne	.+8      	; 0x1290 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1288:	0f 90       	pop	r0
    128a:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    128c:	1c 86       	std	Y+12, r1	; 0x0c
    128e:	54 c0       	rjmp	.+168    	; 0x1338 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    1290:	89 81       	ldd	r24, Y+1	; 0x01
    1292:	88 23       	and	r24, r24
    1294:	31 f4       	brne	.+12     	; 0x12a2 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1296:	ce 01       	movw	r24, r28
    1298:	02 96       	adiw	r24, 0x02	; 2
    129a:	0e 94 c0 11 	call	0x2380	; 0x2380 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    129e:	81 e0       	ldi	r24, 0x01	; 1
    12a0:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    12a2:	0f 90       	pop	r0
    12a4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    12a6:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    12aa:	0f b6       	in	r0, 0x3f	; 63
    12ac:	f8 94       	cli
    12ae:	0f 92       	push	r0
    12b0:	ed 81       	ldd	r30, Y+5	; 0x05
    12b2:	fe 81       	ldd	r31, Y+6	; 0x06
    12b4:	85 8d       	ldd	r24, Z+29	; 0x1d
    12b6:	8f 3f       	cpi	r24, 0xFF	; 255
    12b8:	19 f4       	brne	.+6      	; 0x12c0 <xQueueGenericSend+0xb0>
    12ba:	ed 81       	ldd	r30, Y+5	; 0x05
    12bc:	fe 81       	ldd	r31, Y+6	; 0x06
    12be:	15 8e       	std	Z+29, r1	; 0x1d
    12c0:	ed 81       	ldd	r30, Y+5	; 0x05
    12c2:	fe 81       	ldd	r31, Y+6	; 0x06
    12c4:	86 8d       	ldd	r24, Z+30	; 0x1e
    12c6:	8f 3f       	cpi	r24, 0xFF	; 255
    12c8:	19 f4       	brne	.+6      	; 0x12d0 <xQueueGenericSend+0xc0>
    12ca:	ed 81       	ldd	r30, Y+5	; 0x05
    12cc:	fe 81       	ldd	r31, Y+6	; 0x06
    12ce:	16 8e       	std	Z+30, r1	; 0x1e
    12d0:	0f 90       	pop	r0
    12d2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    12d4:	ce 01       	movw	r24, r28
    12d6:	02 96       	adiw	r24, 0x02	; 2
    12d8:	9e 01       	movw	r18, r28
    12da:	27 5f       	subi	r18, 0xF7	; 247
    12dc:	3f 4f       	sbci	r19, 0xFF	; 255
    12de:	b9 01       	movw	r22, r18
    12e0:	0e 94 d9 11 	call	0x23b2	; 0x23b2 <xTaskCheckForTimeOut>
    12e4:	88 23       	and	r24, r24
    12e6:	09 f5       	brne	.+66     	; 0x132a <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    12e8:	8d 81       	ldd	r24, Y+5	; 0x05
    12ea:	9e 81       	ldd	r25, Y+6	; 0x06
    12ec:	0e 94 a7 0c 	call	0x194e	; 0x194e <prvIsQueueFull>
    12f0:	88 23       	and	r24, r24
    12f2:	a1 f0       	breq	.+40     	; 0x131c <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    12f4:	8d 81       	ldd	r24, Y+5	; 0x05
    12f6:	9e 81       	ldd	r25, Y+6	; 0x06
    12f8:	08 96       	adiw	r24, 0x08	; 8
    12fa:	29 85       	ldd	r18, Y+9	; 0x09
    12fc:	3a 85       	ldd	r19, Y+10	; 0x0a
    12fe:	b9 01       	movw	r22, r18
    1300:	0e 94 22 11 	call	0x2244	; 0x2244 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1304:	8d 81       	ldd	r24, Y+5	; 0x05
    1306:	9e 81       	ldd	r25, Y+6	; 0x06
    1308:	0e 94 20 0c 	call	0x1840	; 0x1840 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    130c:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <xTaskResumeAll>
    1310:	88 23       	and	r24, r24
    1312:	09 f0       	breq	.+2      	; 0x1316 <xQueueGenericSend+0x106>
    1314:	8f cf       	rjmp	.-226    	; 0x1234 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    1316:	0e 94 4c 07 	call	0xe98	; 0xe98 <vPortYield>
    131a:	8c cf       	rjmp	.-232    	; 0x1234 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    131c:	8d 81       	ldd	r24, Y+5	; 0x05
    131e:	9e 81       	ldd	r25, Y+6	; 0x06
    1320:	0e 94 20 0c 	call	0x1840	; 0x1840 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1324:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <xTaskResumeAll>
    1328:	85 cf       	rjmp	.-246    	; 0x1234 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    132a:	8d 81       	ldd	r24, Y+5	; 0x05
    132c:	9e 81       	ldd	r25, Y+6	; 0x06
    132e:	0e 94 20 0c 	call	0x1840	; 0x1840 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1332:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1336:	1c 86       	std	Y+12, r1	; 0x0c
    1338:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    133a:	2c 96       	adiw	r28, 0x0c	; 12
    133c:	0f b6       	in	r0, 0x3f	; 63
    133e:	f8 94       	cli
    1340:	de bf       	out	0x3e, r29	; 62
    1342:	0f be       	out	0x3f, r0	; 63
    1344:	cd bf       	out	0x3d, r28	; 61
    1346:	cf 91       	pop	r28
    1348:	df 91       	pop	r29
    134a:	08 95       	ret

0000134c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    134c:	df 93       	push	r29
    134e:	cf 93       	push	r28
    1350:	cd b7       	in	r28, 0x3d	; 61
    1352:	de b7       	in	r29, 0x3e	; 62
    1354:	29 97       	sbiw	r28, 0x09	; 9
    1356:	0f b6       	in	r0, 0x3f	; 63
    1358:	f8 94       	cli
    135a:	de bf       	out	0x3e, r29	; 62
    135c:	0f be       	out	0x3f, r0	; 63
    135e:	cd bf       	out	0x3d, r28	; 61
    1360:	9c 83       	std	Y+4, r25	; 0x04
    1362:	8b 83       	std	Y+3, r24	; 0x03
    1364:	7e 83       	std	Y+6, r23	; 0x06
    1366:	6d 83       	std	Y+5, r22	; 0x05
    1368:	58 87       	std	Y+8, r21	; 0x08
    136a:	4f 83       	std	Y+7, r20	; 0x07
    136c:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    136e:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1370:	eb 81       	ldd	r30, Y+3	; 0x03
    1372:	fc 81       	ldd	r31, Y+4	; 0x04
    1374:	92 8d       	ldd	r25, Z+26	; 0x1a
    1376:	eb 81       	ldd	r30, Y+3	; 0x03
    1378:	fc 81       	ldd	r31, Y+4	; 0x04
    137a:	83 8d       	ldd	r24, Z+27	; 0x1b
    137c:	98 17       	cp	r25, r24
    137e:	40 f5       	brcc	.+80     	; 0x13d0 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1380:	8b 81       	ldd	r24, Y+3	; 0x03
    1382:	9c 81       	ldd	r25, Y+4	; 0x04
    1384:	2d 81       	ldd	r18, Y+5	; 0x05
    1386:	3e 81       	ldd	r19, Y+6	; 0x06
    1388:	b9 01       	movw	r22, r18
    138a:	49 85       	ldd	r20, Y+9	; 0x09
    138c:	0e 94 43 0b 	call	0x1686	; 0x1686 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1390:	eb 81       	ldd	r30, Y+3	; 0x03
    1392:	fc 81       	ldd	r31, Y+4	; 0x04
    1394:	86 8d       	ldd	r24, Z+30	; 0x1e
    1396:	8f 3f       	cpi	r24, 0xFF	; 255
    1398:	89 f4       	brne	.+34     	; 0x13bc <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    139a:	eb 81       	ldd	r30, Y+3	; 0x03
    139c:	fc 81       	ldd	r31, Y+4	; 0x04
    139e:	81 89       	ldd	r24, Z+17	; 0x11
    13a0:	88 23       	and	r24, r24
    13a2:	99 f0       	breq	.+38     	; 0x13ca <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13a4:	8b 81       	ldd	r24, Y+3	; 0x03
    13a6:	9c 81       	ldd	r25, Y+4	; 0x04
    13a8:	41 96       	adiw	r24, 0x11	; 17
    13aa:	0e 94 58 11 	call	0x22b0	; 0x22b0 <xTaskRemoveFromEventList>
    13ae:	88 23       	and	r24, r24
    13b0:	61 f0       	breq	.+24     	; 0x13ca <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    13b2:	ef 81       	ldd	r30, Y+7	; 0x07
    13b4:	f8 85       	ldd	r31, Y+8	; 0x08
    13b6:	81 e0       	ldi	r24, 0x01	; 1
    13b8:	80 83       	st	Z, r24
    13ba:	07 c0       	rjmp	.+14     	; 0x13ca <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    13bc:	eb 81       	ldd	r30, Y+3	; 0x03
    13be:	fc 81       	ldd	r31, Y+4	; 0x04
    13c0:	86 8d       	ldd	r24, Z+30	; 0x1e
    13c2:	8f 5f       	subi	r24, 0xFF	; 255
    13c4:	eb 81       	ldd	r30, Y+3	; 0x03
    13c6:	fc 81       	ldd	r31, Y+4	; 0x04
    13c8:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    13ca:	81 e0       	ldi	r24, 0x01	; 1
    13cc:	8a 83       	std	Y+2, r24	; 0x02
    13ce:	01 c0       	rjmp	.+2      	; 0x13d2 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    13d0:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    13d2:	8a 81       	ldd	r24, Y+2	; 0x02
}
    13d4:	29 96       	adiw	r28, 0x09	; 9
    13d6:	0f b6       	in	r0, 0x3f	; 63
    13d8:	f8 94       	cli
    13da:	de bf       	out	0x3e, r29	; 62
    13dc:	0f be       	out	0x3f, r0	; 63
    13de:	cd bf       	out	0x3d, r28	; 61
    13e0:	cf 91       	pop	r28
    13e2:	df 91       	pop	r29
    13e4:	08 95       	ret

000013e6 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    13e6:	df 93       	push	r29
    13e8:	cf 93       	push	r28
    13ea:	cd b7       	in	r28, 0x3d	; 61
    13ec:	de b7       	in	r29, 0x3e	; 62
    13ee:	2e 97       	sbiw	r28, 0x0e	; 14
    13f0:	0f b6       	in	r0, 0x3f	; 63
    13f2:	f8 94       	cli
    13f4:	de bf       	out	0x3e, r29	; 62
    13f6:	0f be       	out	0x3f, r0	; 63
    13f8:	cd bf       	out	0x3d, r28	; 61
    13fa:	98 87       	std	Y+8, r25	; 0x08
    13fc:	8f 83       	std	Y+7, r24	; 0x07
    13fe:	7a 87       	std	Y+10, r23	; 0x0a
    1400:	69 87       	std	Y+9, r22	; 0x09
    1402:	5c 87       	std	Y+12, r21	; 0x0c
    1404:	4b 87       	std	Y+11, r20	; 0x0b
    1406:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1408:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    140a:	0f b6       	in	r0, 0x3f	; 63
    140c:	f8 94       	cli
    140e:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1410:	ef 81       	ldd	r30, Y+7	; 0x07
    1412:	f8 85       	ldd	r31, Y+8	; 0x08
    1414:	82 8d       	ldd	r24, Z+26	; 0x1a
    1416:	88 23       	and	r24, r24
    1418:	09 f4       	brne	.+2      	; 0x141c <xQueueGenericReceive+0x36>
    141a:	3f c0       	rjmp	.+126    	; 0x149a <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    141c:	ef 81       	ldd	r30, Y+7	; 0x07
    141e:	f8 85       	ldd	r31, Y+8	; 0x08
    1420:	86 81       	ldd	r24, Z+6	; 0x06
    1422:	97 81       	ldd	r25, Z+7	; 0x07
    1424:	9a 83       	std	Y+2, r25	; 0x02
    1426:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1428:	8f 81       	ldd	r24, Y+7	; 0x07
    142a:	98 85       	ldd	r25, Y+8	; 0x08
    142c:	29 85       	ldd	r18, Y+9	; 0x09
    142e:	3a 85       	ldd	r19, Y+10	; 0x0a
    1430:	b9 01       	movw	r22, r18
    1432:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1436:	8d 85       	ldd	r24, Y+13	; 0x0d
    1438:	88 23       	and	r24, r24
    143a:	b1 f4       	brne	.+44     	; 0x1468 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    143c:	ef 81       	ldd	r30, Y+7	; 0x07
    143e:	f8 85       	ldd	r31, Y+8	; 0x08
    1440:	82 8d       	ldd	r24, Z+26	; 0x1a
    1442:	81 50       	subi	r24, 0x01	; 1
    1444:	ef 81       	ldd	r30, Y+7	; 0x07
    1446:	f8 85       	ldd	r31, Y+8	; 0x08
    1448:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    144a:	ef 81       	ldd	r30, Y+7	; 0x07
    144c:	f8 85       	ldd	r31, Y+8	; 0x08
    144e:	80 85       	ldd	r24, Z+8	; 0x08
    1450:	88 23       	and	r24, r24
    1452:	f1 f0       	breq	.+60     	; 0x1490 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1454:	8f 81       	ldd	r24, Y+7	; 0x07
    1456:	98 85       	ldd	r25, Y+8	; 0x08
    1458:	08 96       	adiw	r24, 0x08	; 8
    145a:	0e 94 58 11 	call	0x22b0	; 0x22b0 <xTaskRemoveFromEventList>
    145e:	81 30       	cpi	r24, 0x01	; 1
    1460:	b9 f4       	brne	.+46     	; 0x1490 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    1462:	0e 94 4c 07 	call	0xe98	; 0xe98 <vPortYield>
    1466:	14 c0       	rjmp	.+40     	; 0x1490 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1468:	ef 81       	ldd	r30, Y+7	; 0x07
    146a:	f8 85       	ldd	r31, Y+8	; 0x08
    146c:	89 81       	ldd	r24, Y+1	; 0x01
    146e:	9a 81       	ldd	r25, Y+2	; 0x02
    1470:	97 83       	std	Z+7, r25	; 0x07
    1472:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1474:	ef 81       	ldd	r30, Y+7	; 0x07
    1476:	f8 85       	ldd	r31, Y+8	; 0x08
    1478:	81 89       	ldd	r24, Z+17	; 0x11
    147a:	88 23       	and	r24, r24
    147c:	49 f0       	breq	.+18     	; 0x1490 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    147e:	8f 81       	ldd	r24, Y+7	; 0x07
    1480:	98 85       	ldd	r25, Y+8	; 0x08
    1482:	41 96       	adiw	r24, 0x11	; 17
    1484:	0e 94 58 11 	call	0x22b0	; 0x22b0 <xTaskRemoveFromEventList>
    1488:	88 23       	and	r24, r24
    148a:	11 f0       	breq	.+4      	; 0x1490 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    148c:	0e 94 4c 07 	call	0xe98	; 0xe98 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    1490:	0f 90       	pop	r0
    1492:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1494:	81 e0       	ldi	r24, 0x01	; 1
    1496:	8e 87       	std	Y+14, r24	; 0x0e
    1498:	5c c0       	rjmp	.+184    	; 0x1552 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    149a:	8b 85       	ldd	r24, Y+11	; 0x0b
    149c:	9c 85       	ldd	r25, Y+12	; 0x0c
    149e:	00 97       	sbiw	r24, 0x00	; 0
    14a0:	21 f4       	brne	.+8      	; 0x14aa <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    14a2:	0f 90       	pop	r0
    14a4:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    14a6:	1e 86       	std	Y+14, r1	; 0x0e
    14a8:	54 c0       	rjmp	.+168    	; 0x1552 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    14aa:	8b 81       	ldd	r24, Y+3	; 0x03
    14ac:	88 23       	and	r24, r24
    14ae:	31 f4       	brne	.+12     	; 0x14bc <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    14b0:	ce 01       	movw	r24, r28
    14b2:	04 96       	adiw	r24, 0x04	; 4
    14b4:	0e 94 c0 11 	call	0x2380	; 0x2380 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    14b8:	81 e0       	ldi	r24, 0x01	; 1
    14ba:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    14bc:	0f 90       	pop	r0
    14be:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    14c0:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    14c4:	0f b6       	in	r0, 0x3f	; 63
    14c6:	f8 94       	cli
    14c8:	0f 92       	push	r0
    14ca:	ef 81       	ldd	r30, Y+7	; 0x07
    14cc:	f8 85       	ldd	r31, Y+8	; 0x08
    14ce:	85 8d       	ldd	r24, Z+29	; 0x1d
    14d0:	8f 3f       	cpi	r24, 0xFF	; 255
    14d2:	19 f4       	brne	.+6      	; 0x14da <xQueueGenericReceive+0xf4>
    14d4:	ef 81       	ldd	r30, Y+7	; 0x07
    14d6:	f8 85       	ldd	r31, Y+8	; 0x08
    14d8:	15 8e       	std	Z+29, r1	; 0x1d
    14da:	ef 81       	ldd	r30, Y+7	; 0x07
    14dc:	f8 85       	ldd	r31, Y+8	; 0x08
    14de:	86 8d       	ldd	r24, Z+30	; 0x1e
    14e0:	8f 3f       	cpi	r24, 0xFF	; 255
    14e2:	19 f4       	brne	.+6      	; 0x14ea <xQueueGenericReceive+0x104>
    14e4:	ef 81       	ldd	r30, Y+7	; 0x07
    14e6:	f8 85       	ldd	r31, Y+8	; 0x08
    14e8:	16 8e       	std	Z+30, r1	; 0x1e
    14ea:	0f 90       	pop	r0
    14ec:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    14ee:	ce 01       	movw	r24, r28
    14f0:	04 96       	adiw	r24, 0x04	; 4
    14f2:	9e 01       	movw	r18, r28
    14f4:	25 5f       	subi	r18, 0xF5	; 245
    14f6:	3f 4f       	sbci	r19, 0xFF	; 255
    14f8:	b9 01       	movw	r22, r18
    14fa:	0e 94 d9 11 	call	0x23b2	; 0x23b2 <xTaskCheckForTimeOut>
    14fe:	88 23       	and	r24, r24
    1500:	09 f5       	brne	.+66     	; 0x1544 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1502:	8f 81       	ldd	r24, Y+7	; 0x07
    1504:	98 85       	ldd	r25, Y+8	; 0x08
    1506:	0e 94 74 0c 	call	0x18e8	; 0x18e8 <prvIsQueueEmpty>
    150a:	88 23       	and	r24, r24
    150c:	a1 f0       	breq	.+40     	; 0x1536 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    150e:	8f 81       	ldd	r24, Y+7	; 0x07
    1510:	98 85       	ldd	r25, Y+8	; 0x08
    1512:	41 96       	adiw	r24, 0x11	; 17
    1514:	2b 85       	ldd	r18, Y+11	; 0x0b
    1516:	3c 85       	ldd	r19, Y+12	; 0x0c
    1518:	b9 01       	movw	r22, r18
    151a:	0e 94 22 11 	call	0x2244	; 0x2244 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    151e:	8f 81       	ldd	r24, Y+7	; 0x07
    1520:	98 85       	ldd	r25, Y+8	; 0x08
    1522:	0e 94 20 0c 	call	0x1840	; 0x1840 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1526:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <xTaskResumeAll>
    152a:	88 23       	and	r24, r24
    152c:	09 f0       	breq	.+2      	; 0x1530 <xQueueGenericReceive+0x14a>
    152e:	6d cf       	rjmp	.-294    	; 0x140a <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    1530:	0e 94 4c 07 	call	0xe98	; 0xe98 <vPortYield>
    1534:	6a cf       	rjmp	.-300    	; 0x140a <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1536:	8f 81       	ldd	r24, Y+7	; 0x07
    1538:	98 85       	ldd	r25, Y+8	; 0x08
    153a:	0e 94 20 0c 	call	0x1840	; 0x1840 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    153e:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <xTaskResumeAll>
    1542:	63 cf       	rjmp	.-314    	; 0x140a <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1544:	8f 81       	ldd	r24, Y+7	; 0x07
    1546:	98 85       	ldd	r25, Y+8	; 0x08
    1548:	0e 94 20 0c 	call	0x1840	; 0x1840 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    154c:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1550:	1e 86       	std	Y+14, r1	; 0x0e
    1552:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    1554:	2e 96       	adiw	r28, 0x0e	; 14
    1556:	0f b6       	in	r0, 0x3f	; 63
    1558:	f8 94       	cli
    155a:	de bf       	out	0x3e, r29	; 62
    155c:	0f be       	out	0x3f, r0	; 63
    155e:	cd bf       	out	0x3d, r28	; 61
    1560:	cf 91       	pop	r28
    1562:	df 91       	pop	r29
    1564:	08 95       	ret

00001566 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1566:	df 93       	push	r29
    1568:	cf 93       	push	r28
    156a:	cd b7       	in	r28, 0x3d	; 61
    156c:	de b7       	in	r29, 0x3e	; 62
    156e:	28 97       	sbiw	r28, 0x08	; 8
    1570:	0f b6       	in	r0, 0x3f	; 63
    1572:	f8 94       	cli
    1574:	de bf       	out	0x3e, r29	; 62
    1576:	0f be       	out	0x3f, r0	; 63
    1578:	cd bf       	out	0x3d, r28	; 61
    157a:	9c 83       	std	Y+4, r25	; 0x04
    157c:	8b 83       	std	Y+3, r24	; 0x03
    157e:	7e 83       	std	Y+6, r23	; 0x06
    1580:	6d 83       	std	Y+5, r22	; 0x05
    1582:	58 87       	std	Y+8, r21	; 0x08
    1584:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1586:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1588:	eb 81       	ldd	r30, Y+3	; 0x03
    158a:	fc 81       	ldd	r31, Y+4	; 0x04
    158c:	82 8d       	ldd	r24, Z+26	; 0x1a
    158e:	88 23       	and	r24, r24
    1590:	71 f1       	breq	.+92     	; 0x15ee <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1592:	8b 81       	ldd	r24, Y+3	; 0x03
    1594:	9c 81       	ldd	r25, Y+4	; 0x04
    1596:	2d 81       	ldd	r18, Y+5	; 0x05
    1598:	3e 81       	ldd	r19, Y+6	; 0x06
    159a:	b9 01       	movw	r22, r18
    159c:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    15a0:	eb 81       	ldd	r30, Y+3	; 0x03
    15a2:	fc 81       	ldd	r31, Y+4	; 0x04
    15a4:	82 8d       	ldd	r24, Z+26	; 0x1a
    15a6:	81 50       	subi	r24, 0x01	; 1
    15a8:	eb 81       	ldd	r30, Y+3	; 0x03
    15aa:	fc 81       	ldd	r31, Y+4	; 0x04
    15ac:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    15ae:	eb 81       	ldd	r30, Y+3	; 0x03
    15b0:	fc 81       	ldd	r31, Y+4	; 0x04
    15b2:	85 8d       	ldd	r24, Z+29	; 0x1d
    15b4:	8f 3f       	cpi	r24, 0xFF	; 255
    15b6:	89 f4       	brne	.+34     	; 0x15da <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    15b8:	eb 81       	ldd	r30, Y+3	; 0x03
    15ba:	fc 81       	ldd	r31, Y+4	; 0x04
    15bc:	80 85       	ldd	r24, Z+8	; 0x08
    15be:	88 23       	and	r24, r24
    15c0:	99 f0       	breq	.+38     	; 0x15e8 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    15c2:	8b 81       	ldd	r24, Y+3	; 0x03
    15c4:	9c 81       	ldd	r25, Y+4	; 0x04
    15c6:	08 96       	adiw	r24, 0x08	; 8
    15c8:	0e 94 58 11 	call	0x22b0	; 0x22b0 <xTaskRemoveFromEventList>
    15cc:	88 23       	and	r24, r24
    15ce:	61 f0       	breq	.+24     	; 0x15e8 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    15d0:	ef 81       	ldd	r30, Y+7	; 0x07
    15d2:	f8 85       	ldd	r31, Y+8	; 0x08
    15d4:	81 e0       	ldi	r24, 0x01	; 1
    15d6:	80 83       	st	Z, r24
    15d8:	07 c0       	rjmp	.+14     	; 0x15e8 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    15da:	eb 81       	ldd	r30, Y+3	; 0x03
    15dc:	fc 81       	ldd	r31, Y+4	; 0x04
    15de:	85 8d       	ldd	r24, Z+29	; 0x1d
    15e0:	8f 5f       	subi	r24, 0xFF	; 255
    15e2:	eb 81       	ldd	r30, Y+3	; 0x03
    15e4:	fc 81       	ldd	r31, Y+4	; 0x04
    15e6:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    15e8:	81 e0       	ldi	r24, 0x01	; 1
    15ea:	8a 83       	std	Y+2, r24	; 0x02
    15ec:	01 c0       	rjmp	.+2      	; 0x15f0 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    15ee:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    15f0:	8a 81       	ldd	r24, Y+2	; 0x02
}
    15f2:	28 96       	adiw	r28, 0x08	; 8
    15f4:	0f b6       	in	r0, 0x3f	; 63
    15f6:	f8 94       	cli
    15f8:	de bf       	out	0x3e, r29	; 62
    15fa:	0f be       	out	0x3f, r0	; 63
    15fc:	cd bf       	out	0x3d, r28	; 61
    15fe:	cf 91       	pop	r28
    1600:	df 91       	pop	r29
    1602:	08 95       	ret

00001604 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    1604:	df 93       	push	r29
    1606:	cf 93       	push	r28
    1608:	00 d0       	rcall	.+0      	; 0x160a <uxQueueMessagesWaiting+0x6>
    160a:	0f 92       	push	r0
    160c:	cd b7       	in	r28, 0x3d	; 61
    160e:	de b7       	in	r29, 0x3e	; 62
    1610:	9b 83       	std	Y+3, r25	; 0x03
    1612:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1614:	0f b6       	in	r0, 0x3f	; 63
    1616:	f8 94       	cli
    1618:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    161a:	ea 81       	ldd	r30, Y+2	; 0x02
    161c:	fb 81       	ldd	r31, Y+3	; 0x03
    161e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1620:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1622:	0f 90       	pop	r0
    1624:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1626:	89 81       	ldd	r24, Y+1	; 0x01
}
    1628:	0f 90       	pop	r0
    162a:	0f 90       	pop	r0
    162c:	0f 90       	pop	r0
    162e:	cf 91       	pop	r28
    1630:	df 91       	pop	r29
    1632:	08 95       	ret

00001634 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    1634:	df 93       	push	r29
    1636:	cf 93       	push	r28
    1638:	00 d0       	rcall	.+0      	; 0x163a <uxQueueMessagesWaitingFromISR+0x6>
    163a:	0f 92       	push	r0
    163c:	cd b7       	in	r28, 0x3d	; 61
    163e:	de b7       	in	r29, 0x3e	; 62
    1640:	9b 83       	std	Y+3, r25	; 0x03
    1642:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1644:	ea 81       	ldd	r30, Y+2	; 0x02
    1646:	fb 81       	ldd	r31, Y+3	; 0x03
    1648:	82 8d       	ldd	r24, Z+26	; 0x1a
    164a:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    164c:	89 81       	ldd	r24, Y+1	; 0x01
}
    164e:	0f 90       	pop	r0
    1650:	0f 90       	pop	r0
    1652:	0f 90       	pop	r0
    1654:	cf 91       	pop	r28
    1656:	df 91       	pop	r29
    1658:	08 95       	ret

0000165a <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    165a:	df 93       	push	r29
    165c:	cf 93       	push	r28
    165e:	00 d0       	rcall	.+0      	; 0x1660 <vQueueDelete+0x6>
    1660:	cd b7       	in	r28, 0x3d	; 61
    1662:	de b7       	in	r29, 0x3e	; 62
    1664:	9a 83       	std	Y+2, r25	; 0x02
    1666:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1668:	e9 81       	ldd	r30, Y+1	; 0x01
    166a:	fa 81       	ldd	r31, Y+2	; 0x02
    166c:	80 81       	ld	r24, Z
    166e:	91 81       	ldd	r25, Z+1	; 0x01
    1670:	0e 94 2c 04 	call	0x858	; 0x858 <vPortFree>
	vPortFree( pxQueue );
    1674:	89 81       	ldd	r24, Y+1	; 0x01
    1676:	9a 81       	ldd	r25, Y+2	; 0x02
    1678:	0e 94 2c 04 	call	0x858	; 0x858 <vPortFree>
}
    167c:	0f 90       	pop	r0
    167e:	0f 90       	pop	r0
    1680:	cf 91       	pop	r28
    1682:	df 91       	pop	r29
    1684:	08 95       	ret

00001686 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    1686:	df 93       	push	r29
    1688:	cf 93       	push	r28
    168a:	00 d0       	rcall	.+0      	; 0x168c <prvCopyDataToQueue+0x6>
    168c:	00 d0       	rcall	.+0      	; 0x168e <prvCopyDataToQueue+0x8>
    168e:	0f 92       	push	r0
    1690:	cd b7       	in	r28, 0x3d	; 61
    1692:	de b7       	in	r29, 0x3e	; 62
    1694:	9a 83       	std	Y+2, r25	; 0x02
    1696:	89 83       	std	Y+1, r24	; 0x01
    1698:	7c 83       	std	Y+4, r23	; 0x04
    169a:	6b 83       	std	Y+3, r22	; 0x03
    169c:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    169e:	e9 81       	ldd	r30, Y+1	; 0x01
    16a0:	fa 81       	ldd	r31, Y+2	; 0x02
    16a2:	84 8d       	ldd	r24, Z+28	; 0x1c
    16a4:	88 23       	and	r24, r24
    16a6:	09 f4       	brne	.+2      	; 0x16aa <prvCopyDataToQueue+0x24>
    16a8:	74 c0       	rjmp	.+232    	; 0x1792 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    16aa:	8d 81       	ldd	r24, Y+5	; 0x05
    16ac:	88 23       	and	r24, r24
    16ae:	99 f5       	brne	.+102    	; 0x1716 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    16b0:	e9 81       	ldd	r30, Y+1	; 0x01
    16b2:	fa 81       	ldd	r31, Y+2	; 0x02
    16b4:	64 81       	ldd	r22, Z+4	; 0x04
    16b6:	75 81       	ldd	r23, Z+5	; 0x05
    16b8:	e9 81       	ldd	r30, Y+1	; 0x01
    16ba:	fa 81       	ldd	r31, Y+2	; 0x02
    16bc:	84 8d       	ldd	r24, Z+28	; 0x1c
    16be:	48 2f       	mov	r20, r24
    16c0:	50 e0       	ldi	r21, 0x00	; 0
    16c2:	2b 81       	ldd	r18, Y+3	; 0x03
    16c4:	3c 81       	ldd	r19, Y+4	; 0x04
    16c6:	cb 01       	movw	r24, r22
    16c8:	b9 01       	movw	r22, r18
    16ca:	0e 94 cb 13 	call	0x2796	; 0x2796 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    16ce:	e9 81       	ldd	r30, Y+1	; 0x01
    16d0:	fa 81       	ldd	r31, Y+2	; 0x02
    16d2:	24 81       	ldd	r18, Z+4	; 0x04
    16d4:	35 81       	ldd	r19, Z+5	; 0x05
    16d6:	e9 81       	ldd	r30, Y+1	; 0x01
    16d8:	fa 81       	ldd	r31, Y+2	; 0x02
    16da:	84 8d       	ldd	r24, Z+28	; 0x1c
    16dc:	88 2f       	mov	r24, r24
    16de:	90 e0       	ldi	r25, 0x00	; 0
    16e0:	82 0f       	add	r24, r18
    16e2:	93 1f       	adc	r25, r19
    16e4:	e9 81       	ldd	r30, Y+1	; 0x01
    16e6:	fa 81       	ldd	r31, Y+2	; 0x02
    16e8:	95 83       	std	Z+5, r25	; 0x05
    16ea:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    16ec:	e9 81       	ldd	r30, Y+1	; 0x01
    16ee:	fa 81       	ldd	r31, Y+2	; 0x02
    16f0:	24 81       	ldd	r18, Z+4	; 0x04
    16f2:	35 81       	ldd	r19, Z+5	; 0x05
    16f4:	e9 81       	ldd	r30, Y+1	; 0x01
    16f6:	fa 81       	ldd	r31, Y+2	; 0x02
    16f8:	82 81       	ldd	r24, Z+2	; 0x02
    16fa:	93 81       	ldd	r25, Z+3	; 0x03
    16fc:	28 17       	cp	r18, r24
    16fe:	39 07       	cpc	r19, r25
    1700:	08 f4       	brcc	.+2      	; 0x1704 <prvCopyDataToQueue+0x7e>
    1702:	47 c0       	rjmp	.+142    	; 0x1792 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1704:	e9 81       	ldd	r30, Y+1	; 0x01
    1706:	fa 81       	ldd	r31, Y+2	; 0x02
    1708:	80 81       	ld	r24, Z
    170a:	91 81       	ldd	r25, Z+1	; 0x01
    170c:	e9 81       	ldd	r30, Y+1	; 0x01
    170e:	fa 81       	ldd	r31, Y+2	; 0x02
    1710:	95 83       	std	Z+5, r25	; 0x05
    1712:	84 83       	std	Z+4, r24	; 0x04
    1714:	3e c0       	rjmp	.+124    	; 0x1792 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1716:	e9 81       	ldd	r30, Y+1	; 0x01
    1718:	fa 81       	ldd	r31, Y+2	; 0x02
    171a:	66 81       	ldd	r22, Z+6	; 0x06
    171c:	77 81       	ldd	r23, Z+7	; 0x07
    171e:	e9 81       	ldd	r30, Y+1	; 0x01
    1720:	fa 81       	ldd	r31, Y+2	; 0x02
    1722:	84 8d       	ldd	r24, Z+28	; 0x1c
    1724:	48 2f       	mov	r20, r24
    1726:	50 e0       	ldi	r21, 0x00	; 0
    1728:	2b 81       	ldd	r18, Y+3	; 0x03
    172a:	3c 81       	ldd	r19, Y+4	; 0x04
    172c:	cb 01       	movw	r24, r22
    172e:	b9 01       	movw	r22, r18
    1730:	0e 94 cb 13 	call	0x2796	; 0x2796 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1734:	e9 81       	ldd	r30, Y+1	; 0x01
    1736:	fa 81       	ldd	r31, Y+2	; 0x02
    1738:	26 81       	ldd	r18, Z+6	; 0x06
    173a:	37 81       	ldd	r19, Z+7	; 0x07
    173c:	e9 81       	ldd	r30, Y+1	; 0x01
    173e:	fa 81       	ldd	r31, Y+2	; 0x02
    1740:	84 8d       	ldd	r24, Z+28	; 0x1c
    1742:	88 2f       	mov	r24, r24
    1744:	90 e0       	ldi	r25, 0x00	; 0
    1746:	90 95       	com	r25
    1748:	81 95       	neg	r24
    174a:	9f 4f       	sbci	r25, 0xFF	; 255
    174c:	82 0f       	add	r24, r18
    174e:	93 1f       	adc	r25, r19
    1750:	e9 81       	ldd	r30, Y+1	; 0x01
    1752:	fa 81       	ldd	r31, Y+2	; 0x02
    1754:	97 83       	std	Z+7, r25	; 0x07
    1756:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1758:	e9 81       	ldd	r30, Y+1	; 0x01
    175a:	fa 81       	ldd	r31, Y+2	; 0x02
    175c:	26 81       	ldd	r18, Z+6	; 0x06
    175e:	37 81       	ldd	r19, Z+7	; 0x07
    1760:	e9 81       	ldd	r30, Y+1	; 0x01
    1762:	fa 81       	ldd	r31, Y+2	; 0x02
    1764:	80 81       	ld	r24, Z
    1766:	91 81       	ldd	r25, Z+1	; 0x01
    1768:	28 17       	cp	r18, r24
    176a:	39 07       	cpc	r19, r25
    176c:	90 f4       	brcc	.+36     	; 0x1792 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    176e:	e9 81       	ldd	r30, Y+1	; 0x01
    1770:	fa 81       	ldd	r31, Y+2	; 0x02
    1772:	22 81       	ldd	r18, Z+2	; 0x02
    1774:	33 81       	ldd	r19, Z+3	; 0x03
    1776:	e9 81       	ldd	r30, Y+1	; 0x01
    1778:	fa 81       	ldd	r31, Y+2	; 0x02
    177a:	84 8d       	ldd	r24, Z+28	; 0x1c
    177c:	88 2f       	mov	r24, r24
    177e:	90 e0       	ldi	r25, 0x00	; 0
    1780:	90 95       	com	r25
    1782:	81 95       	neg	r24
    1784:	9f 4f       	sbci	r25, 0xFF	; 255
    1786:	82 0f       	add	r24, r18
    1788:	93 1f       	adc	r25, r19
    178a:	e9 81       	ldd	r30, Y+1	; 0x01
    178c:	fa 81       	ldd	r31, Y+2	; 0x02
    178e:	97 83       	std	Z+7, r25	; 0x07
    1790:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1792:	e9 81       	ldd	r30, Y+1	; 0x01
    1794:	fa 81       	ldd	r31, Y+2	; 0x02
    1796:	82 8d       	ldd	r24, Z+26	; 0x1a
    1798:	8f 5f       	subi	r24, 0xFF	; 255
    179a:	e9 81       	ldd	r30, Y+1	; 0x01
    179c:	fa 81       	ldd	r31, Y+2	; 0x02
    179e:	82 8f       	std	Z+26, r24	; 0x1a
}
    17a0:	0f 90       	pop	r0
    17a2:	0f 90       	pop	r0
    17a4:	0f 90       	pop	r0
    17a6:	0f 90       	pop	r0
    17a8:	0f 90       	pop	r0
    17aa:	cf 91       	pop	r28
    17ac:	df 91       	pop	r29
    17ae:	08 95       	ret

000017b0 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    17b0:	df 93       	push	r29
    17b2:	cf 93       	push	r28
    17b4:	00 d0       	rcall	.+0      	; 0x17b6 <prvCopyDataFromQueue+0x6>
    17b6:	00 d0       	rcall	.+0      	; 0x17b8 <prvCopyDataFromQueue+0x8>
    17b8:	cd b7       	in	r28, 0x3d	; 61
    17ba:	de b7       	in	r29, 0x3e	; 62
    17bc:	9a 83       	std	Y+2, r25	; 0x02
    17be:	89 83       	std	Y+1, r24	; 0x01
    17c0:	7c 83       	std	Y+4, r23	; 0x04
    17c2:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    17c4:	e9 81       	ldd	r30, Y+1	; 0x01
    17c6:	fa 81       	ldd	r31, Y+2	; 0x02
    17c8:	80 81       	ld	r24, Z
    17ca:	91 81       	ldd	r25, Z+1	; 0x01
    17cc:	00 97       	sbiw	r24, 0x00	; 0
    17ce:	89 f1       	breq	.+98     	; 0x1832 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    17d0:	e9 81       	ldd	r30, Y+1	; 0x01
    17d2:	fa 81       	ldd	r31, Y+2	; 0x02
    17d4:	26 81       	ldd	r18, Z+6	; 0x06
    17d6:	37 81       	ldd	r19, Z+7	; 0x07
    17d8:	e9 81       	ldd	r30, Y+1	; 0x01
    17da:	fa 81       	ldd	r31, Y+2	; 0x02
    17dc:	84 8d       	ldd	r24, Z+28	; 0x1c
    17de:	88 2f       	mov	r24, r24
    17e0:	90 e0       	ldi	r25, 0x00	; 0
    17e2:	82 0f       	add	r24, r18
    17e4:	93 1f       	adc	r25, r19
    17e6:	e9 81       	ldd	r30, Y+1	; 0x01
    17e8:	fa 81       	ldd	r31, Y+2	; 0x02
    17ea:	97 83       	std	Z+7, r25	; 0x07
    17ec:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    17ee:	e9 81       	ldd	r30, Y+1	; 0x01
    17f0:	fa 81       	ldd	r31, Y+2	; 0x02
    17f2:	26 81       	ldd	r18, Z+6	; 0x06
    17f4:	37 81       	ldd	r19, Z+7	; 0x07
    17f6:	e9 81       	ldd	r30, Y+1	; 0x01
    17f8:	fa 81       	ldd	r31, Y+2	; 0x02
    17fa:	82 81       	ldd	r24, Z+2	; 0x02
    17fc:	93 81       	ldd	r25, Z+3	; 0x03
    17fe:	28 17       	cp	r18, r24
    1800:	39 07       	cpc	r19, r25
    1802:	40 f0       	brcs	.+16     	; 0x1814 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1804:	e9 81       	ldd	r30, Y+1	; 0x01
    1806:	fa 81       	ldd	r31, Y+2	; 0x02
    1808:	80 81       	ld	r24, Z
    180a:	91 81       	ldd	r25, Z+1	; 0x01
    180c:	e9 81       	ldd	r30, Y+1	; 0x01
    180e:	fa 81       	ldd	r31, Y+2	; 0x02
    1810:	97 83       	std	Z+7, r25	; 0x07
    1812:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1814:	e9 81       	ldd	r30, Y+1	; 0x01
    1816:	fa 81       	ldd	r31, Y+2	; 0x02
    1818:	46 81       	ldd	r20, Z+6	; 0x06
    181a:	57 81       	ldd	r21, Z+7	; 0x07
    181c:	e9 81       	ldd	r30, Y+1	; 0x01
    181e:	fa 81       	ldd	r31, Y+2	; 0x02
    1820:	84 8d       	ldd	r24, Z+28	; 0x1c
    1822:	28 2f       	mov	r18, r24
    1824:	30 e0       	ldi	r19, 0x00	; 0
    1826:	8b 81       	ldd	r24, Y+3	; 0x03
    1828:	9c 81       	ldd	r25, Y+4	; 0x04
    182a:	ba 01       	movw	r22, r20
    182c:	a9 01       	movw	r20, r18
    182e:	0e 94 cb 13 	call	0x2796	; 0x2796 <memcpy>
	}
}
    1832:	0f 90       	pop	r0
    1834:	0f 90       	pop	r0
    1836:	0f 90       	pop	r0
    1838:	0f 90       	pop	r0
    183a:	cf 91       	pop	r28
    183c:	df 91       	pop	r29
    183e:	08 95       	ret

00001840 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1840:	df 93       	push	r29
    1842:	cf 93       	push	r28
    1844:	00 d0       	rcall	.+0      	; 0x1846 <prvUnlockQueue+0x6>
    1846:	cd b7       	in	r28, 0x3d	; 61
    1848:	de b7       	in	r29, 0x3e	; 62
    184a:	9a 83       	std	Y+2, r25	; 0x02
    184c:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    184e:	0f b6       	in	r0, 0x3f	; 63
    1850:	f8 94       	cli
    1852:	0f 92       	push	r0
    1854:	15 c0       	rjmp	.+42     	; 0x1880 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1856:	e9 81       	ldd	r30, Y+1	; 0x01
    1858:	fa 81       	ldd	r31, Y+2	; 0x02
    185a:	81 89       	ldd	r24, Z+17	; 0x11
    185c:	88 23       	and	r24, r24
    185e:	a9 f0       	breq	.+42     	; 0x188a <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1860:	89 81       	ldd	r24, Y+1	; 0x01
    1862:	9a 81       	ldd	r25, Y+2	; 0x02
    1864:	41 96       	adiw	r24, 0x11	; 17
    1866:	0e 94 58 11 	call	0x22b0	; 0x22b0 <xTaskRemoveFromEventList>
    186a:	88 23       	and	r24, r24
    186c:	11 f0       	breq	.+4      	; 0x1872 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    186e:	0e 94 36 12 	call	0x246c	; 0x246c <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    1872:	e9 81       	ldd	r30, Y+1	; 0x01
    1874:	fa 81       	ldd	r31, Y+2	; 0x02
    1876:	86 8d       	ldd	r24, Z+30	; 0x1e
    1878:	81 50       	subi	r24, 0x01	; 1
    187a:	e9 81       	ldd	r30, Y+1	; 0x01
    187c:	fa 81       	ldd	r31, Y+2	; 0x02
    187e:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1880:	e9 81       	ldd	r30, Y+1	; 0x01
    1882:	fa 81       	ldd	r31, Y+2	; 0x02
    1884:	86 8d       	ldd	r24, Z+30	; 0x1e
    1886:	18 16       	cp	r1, r24
    1888:	34 f3       	brlt	.-52     	; 0x1856 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    188a:	e9 81       	ldd	r30, Y+1	; 0x01
    188c:	fa 81       	ldd	r31, Y+2	; 0x02
    188e:	8f ef       	ldi	r24, 0xFF	; 255
    1890:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1892:	0f 90       	pop	r0
    1894:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1896:	0f b6       	in	r0, 0x3f	; 63
    1898:	f8 94       	cli
    189a:	0f 92       	push	r0
    189c:	15 c0       	rjmp	.+42     	; 0x18c8 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    189e:	e9 81       	ldd	r30, Y+1	; 0x01
    18a0:	fa 81       	ldd	r31, Y+2	; 0x02
    18a2:	80 85       	ldd	r24, Z+8	; 0x08
    18a4:	88 23       	and	r24, r24
    18a6:	a9 f0       	breq	.+42     	; 0x18d2 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    18a8:	89 81       	ldd	r24, Y+1	; 0x01
    18aa:	9a 81       	ldd	r25, Y+2	; 0x02
    18ac:	08 96       	adiw	r24, 0x08	; 8
    18ae:	0e 94 58 11 	call	0x22b0	; 0x22b0 <xTaskRemoveFromEventList>
    18b2:	88 23       	and	r24, r24
    18b4:	11 f0       	breq	.+4      	; 0x18ba <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    18b6:	0e 94 36 12 	call	0x246c	; 0x246c <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    18ba:	e9 81       	ldd	r30, Y+1	; 0x01
    18bc:	fa 81       	ldd	r31, Y+2	; 0x02
    18be:	85 8d       	ldd	r24, Z+29	; 0x1d
    18c0:	81 50       	subi	r24, 0x01	; 1
    18c2:	e9 81       	ldd	r30, Y+1	; 0x01
    18c4:	fa 81       	ldd	r31, Y+2	; 0x02
    18c6:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    18c8:	e9 81       	ldd	r30, Y+1	; 0x01
    18ca:	fa 81       	ldd	r31, Y+2	; 0x02
    18cc:	85 8d       	ldd	r24, Z+29	; 0x1d
    18ce:	18 16       	cp	r1, r24
    18d0:	34 f3       	brlt	.-52     	; 0x189e <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    18d2:	e9 81       	ldd	r30, Y+1	; 0x01
    18d4:	fa 81       	ldd	r31, Y+2	; 0x02
    18d6:	8f ef       	ldi	r24, 0xFF	; 255
    18d8:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    18da:	0f 90       	pop	r0
    18dc:	0f be       	out	0x3f, r0	; 63
}
    18de:	0f 90       	pop	r0
    18e0:	0f 90       	pop	r0
    18e2:	cf 91       	pop	r28
    18e4:	df 91       	pop	r29
    18e6:	08 95       	ret

000018e8 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    18e8:	df 93       	push	r29
    18ea:	cf 93       	push	r28
    18ec:	00 d0       	rcall	.+0      	; 0x18ee <prvIsQueueEmpty+0x6>
    18ee:	0f 92       	push	r0
    18f0:	cd b7       	in	r28, 0x3d	; 61
    18f2:	de b7       	in	r29, 0x3e	; 62
    18f4:	9b 83       	std	Y+3, r25	; 0x03
    18f6:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    18f8:	0f b6       	in	r0, 0x3f	; 63
    18fa:	f8 94       	cli
    18fc:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    18fe:	ea 81       	ldd	r30, Y+2	; 0x02
    1900:	fb 81       	ldd	r31, Y+3	; 0x03
    1902:	82 8d       	ldd	r24, Z+26	; 0x1a
    1904:	19 82       	std	Y+1, r1	; 0x01
    1906:	88 23       	and	r24, r24
    1908:	11 f4       	brne	.+4      	; 0x190e <prvIsQueueEmpty+0x26>
    190a:	81 e0       	ldi	r24, 0x01	; 1
    190c:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    190e:	0f 90       	pop	r0
    1910:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1912:	89 81       	ldd	r24, Y+1	; 0x01
}
    1914:	0f 90       	pop	r0
    1916:	0f 90       	pop	r0
    1918:	0f 90       	pop	r0
    191a:	cf 91       	pop	r28
    191c:	df 91       	pop	r29
    191e:	08 95       	ret

00001920 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    1920:	df 93       	push	r29
    1922:	cf 93       	push	r28
    1924:	00 d0       	rcall	.+0      	; 0x1926 <xQueueIsQueueEmptyFromISR+0x6>
    1926:	0f 92       	push	r0
    1928:	cd b7       	in	r28, 0x3d	; 61
    192a:	de b7       	in	r29, 0x3e	; 62
    192c:	9b 83       	std	Y+3, r25	; 0x03
    192e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1930:	ea 81       	ldd	r30, Y+2	; 0x02
    1932:	fb 81       	ldd	r31, Y+3	; 0x03
    1934:	82 8d       	ldd	r24, Z+26	; 0x1a
    1936:	19 82       	std	Y+1, r1	; 0x01
    1938:	88 23       	and	r24, r24
    193a:	11 f4       	brne	.+4      	; 0x1940 <xQueueIsQueueEmptyFromISR+0x20>
    193c:	81 e0       	ldi	r24, 0x01	; 1
    193e:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    1940:	89 81       	ldd	r24, Y+1	; 0x01
}
    1942:	0f 90       	pop	r0
    1944:	0f 90       	pop	r0
    1946:	0f 90       	pop	r0
    1948:	cf 91       	pop	r28
    194a:	df 91       	pop	r29
    194c:	08 95       	ret

0000194e <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    194e:	df 93       	push	r29
    1950:	cf 93       	push	r28
    1952:	00 d0       	rcall	.+0      	; 0x1954 <prvIsQueueFull+0x6>
    1954:	0f 92       	push	r0
    1956:	cd b7       	in	r28, 0x3d	; 61
    1958:	de b7       	in	r29, 0x3e	; 62
    195a:	9b 83       	std	Y+3, r25	; 0x03
    195c:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    195e:	0f b6       	in	r0, 0x3f	; 63
    1960:	f8 94       	cli
    1962:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1964:	ea 81       	ldd	r30, Y+2	; 0x02
    1966:	fb 81       	ldd	r31, Y+3	; 0x03
    1968:	92 8d       	ldd	r25, Z+26	; 0x1a
    196a:	ea 81       	ldd	r30, Y+2	; 0x02
    196c:	fb 81       	ldd	r31, Y+3	; 0x03
    196e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1970:	19 82       	std	Y+1, r1	; 0x01
    1972:	98 17       	cp	r25, r24
    1974:	11 f4       	brne	.+4      	; 0x197a <prvIsQueueFull+0x2c>
    1976:	81 e0       	ldi	r24, 0x01	; 1
    1978:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    197a:	0f 90       	pop	r0
    197c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    197e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1980:	0f 90       	pop	r0
    1982:	0f 90       	pop	r0
    1984:	0f 90       	pop	r0
    1986:	cf 91       	pop	r28
    1988:	df 91       	pop	r29
    198a:	08 95       	ret

0000198c <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    198c:	df 93       	push	r29
    198e:	cf 93       	push	r28
    1990:	00 d0       	rcall	.+0      	; 0x1992 <xQueueIsQueueFullFromISR+0x6>
    1992:	0f 92       	push	r0
    1994:	cd b7       	in	r28, 0x3d	; 61
    1996:	de b7       	in	r29, 0x3e	; 62
    1998:	9b 83       	std	Y+3, r25	; 0x03
    199a:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    199c:	ea 81       	ldd	r30, Y+2	; 0x02
    199e:	fb 81       	ldd	r31, Y+3	; 0x03
    19a0:	92 8d       	ldd	r25, Z+26	; 0x1a
    19a2:	ea 81       	ldd	r30, Y+2	; 0x02
    19a4:	fb 81       	ldd	r31, Y+3	; 0x03
    19a6:	83 8d       	ldd	r24, Z+27	; 0x1b
    19a8:	19 82       	std	Y+1, r1	; 0x01
    19aa:	98 17       	cp	r25, r24
    19ac:	11 f4       	brne	.+4      	; 0x19b2 <xQueueIsQueueFullFromISR+0x26>
    19ae:	81 e0       	ldi	r24, 0x01	; 1
    19b0:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    19b2:	89 81       	ldd	r24, Y+1	; 0x01
}
    19b4:	0f 90       	pop	r0
    19b6:	0f 90       	pop	r0
    19b8:	0f 90       	pop	r0
    19ba:	cf 91       	pop	r28
    19bc:	df 91       	pop	r29
    19be:	08 95       	ret

000019c0 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    19c0:	af 92       	push	r10
    19c2:	bf 92       	push	r11
    19c4:	cf 92       	push	r12
    19c6:	df 92       	push	r13
    19c8:	ef 92       	push	r14
    19ca:	ff 92       	push	r15
    19cc:	0f 93       	push	r16
    19ce:	1f 93       	push	r17
    19d0:	df 93       	push	r29
    19d2:	cf 93       	push	r28
    19d4:	cd b7       	in	r28, 0x3d	; 61
    19d6:	de b7       	in	r29, 0x3e	; 62
    19d8:	64 97       	sbiw	r28, 0x14	; 20
    19da:	0f b6       	in	r0, 0x3f	; 63
    19dc:	f8 94       	cli
    19de:	de bf       	out	0x3e, r29	; 62
    19e0:	0f be       	out	0x3f, r0	; 63
    19e2:	cd bf       	out	0x3d, r28	; 61
    19e4:	9f 83       	std	Y+7, r25	; 0x07
    19e6:	8e 83       	std	Y+6, r24	; 0x06
    19e8:	79 87       	std	Y+9, r23	; 0x09
    19ea:	68 87       	std	Y+8, r22	; 0x08
    19ec:	5b 87       	std	Y+11, r21	; 0x0b
    19ee:	4a 87       	std	Y+10, r20	; 0x0a
    19f0:	3d 87       	std	Y+13, r19	; 0x0d
    19f2:	2c 87       	std	Y+12, r18	; 0x0c
    19f4:	0e 87       	std	Y+14, r16	; 0x0e
    19f6:	f8 8a       	std	Y+16, r15	; 0x10
    19f8:	ef 86       	std	Y+15, r14	; 0x0f
    19fa:	da 8a       	std	Y+18, r13	; 0x12
    19fc:	c9 8a       	std	Y+17, r12	; 0x11
    19fe:	bc 8a       	std	Y+20, r11	; 0x14
    1a00:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    1a02:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a04:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a06:	29 89       	ldd	r18, Y+17	; 0x11
    1a08:	3a 89       	ldd	r19, Y+18	; 0x12
    1a0a:	b9 01       	movw	r22, r18
    1a0c:	0e 94 65 13 	call	0x26ca	; 0x26ca <prvAllocateTCBAndStack>
    1a10:	9c 83       	std	Y+4, r25	; 0x04
    1a12:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    1a14:	8b 81       	ldd	r24, Y+3	; 0x03
    1a16:	9c 81       	ldd	r25, Y+4	; 0x04
    1a18:	00 97       	sbiw	r24, 0x00	; 0
    1a1a:	09 f4       	brne	.+2      	; 0x1a1e <xTaskGenericCreate+0x5e>
    1a1c:	99 c0       	rjmp	.+306    	; 0x1b50 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1a1e:	eb 81       	ldd	r30, Y+3	; 0x03
    1a20:	fc 81       	ldd	r31, Y+4	; 0x04
    1a22:	27 89       	ldd	r18, Z+23	; 0x17
    1a24:	30 8d       	ldd	r19, Z+24	; 0x18
    1a26:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a28:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a2a:	01 97       	sbiw	r24, 0x01	; 1
    1a2c:	82 0f       	add	r24, r18
    1a2e:	93 1f       	adc	r25, r19
    1a30:	9a 83       	std	Y+2, r25	; 0x02
    1a32:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    1a34:	8b 81       	ldd	r24, Y+3	; 0x03
    1a36:	9c 81       	ldd	r25, Y+4	; 0x04
    1a38:	28 85       	ldd	r18, Y+8	; 0x08
    1a3a:	39 85       	ldd	r19, Y+9	; 0x09
    1a3c:	eb 89       	ldd	r30, Y+19	; 0x13
    1a3e:	fc 89       	ldd	r31, Y+20	; 0x14
    1a40:	aa 85       	ldd	r26, Y+10	; 0x0a
    1a42:	bb 85       	ldd	r27, Y+11	; 0x0b
    1a44:	b9 01       	movw	r22, r18
    1a46:	4e 85       	ldd	r20, Y+14	; 0x0e
    1a48:	9f 01       	movw	r18, r30
    1a4a:	8d 01       	movw	r16, r26
    1a4c:	0e 94 4a 12 	call	0x2494	; 0x2494 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1a50:	89 81       	ldd	r24, Y+1	; 0x01
    1a52:	9a 81       	ldd	r25, Y+2	; 0x02
    1a54:	2e 81       	ldd	r18, Y+6	; 0x06
    1a56:	3f 81       	ldd	r19, Y+7	; 0x07
    1a58:	4c 85       	ldd	r20, Y+12	; 0x0c
    1a5a:	5d 85       	ldd	r21, Y+13	; 0x0d
    1a5c:	b9 01       	movw	r22, r18
    1a5e:	0e 94 8d 05 	call	0xb1a	; 0xb1a <pxPortInitialiseStack>
    1a62:	eb 81       	ldd	r30, Y+3	; 0x03
    1a64:	fc 81       	ldd	r31, Y+4	; 0x04
    1a66:	91 83       	std	Z+1, r25	; 0x01
    1a68:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    1a6a:	8f 85       	ldd	r24, Y+15	; 0x0f
    1a6c:	98 89       	ldd	r25, Y+16	; 0x10
    1a6e:	00 97       	sbiw	r24, 0x00	; 0
    1a70:	31 f0       	breq	.+12     	; 0x1a7e <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1a72:	ef 85       	ldd	r30, Y+15	; 0x0f
    1a74:	f8 89       	ldd	r31, Y+16	; 0x10
    1a76:	8b 81       	ldd	r24, Y+3	; 0x03
    1a78:	9c 81       	ldd	r25, Y+4	; 0x04
    1a7a:	91 83       	std	Z+1, r25	; 0x01
    1a7c:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    1a7e:	0f b6       	in	r0, 0x3f	; 63
    1a80:	f8 94       	cli
    1a82:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1a84:	80 91 12 03 	lds	r24, 0x0312
    1a88:	8f 5f       	subi	r24, 0xFF	; 255
    1a8a:	80 93 12 03 	sts	0x0312, r24
			if( pxCurrentTCB == NULL )
    1a8e:	80 91 0f 03 	lds	r24, 0x030F
    1a92:	90 91 10 03 	lds	r25, 0x0310
    1a96:	00 97       	sbiw	r24, 0x00	; 0
    1a98:	69 f4       	brne	.+26     	; 0x1ab4 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1a9a:	8b 81       	ldd	r24, Y+3	; 0x03
    1a9c:	9c 81       	ldd	r25, Y+4	; 0x04
    1a9e:	90 93 10 03 	sts	0x0310, r25
    1aa2:	80 93 0f 03 	sts	0x030F, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    1aa6:	80 91 12 03 	lds	r24, 0x0312
    1aaa:	81 30       	cpi	r24, 0x01	; 1
    1aac:	a9 f4       	brne	.+42     	; 0x1ad8 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    1aae:	0e 94 a1 12 	call	0x2542	; 0x2542 <prvInitialiseTaskLists>
    1ab2:	12 c0       	rjmp	.+36     	; 0x1ad8 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1ab4:	80 91 17 03 	lds	r24, 0x0317
    1ab8:	88 23       	and	r24, r24
    1aba:	71 f4       	brne	.+28     	; 0x1ad8 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1abc:	e0 91 0f 03 	lds	r30, 0x030F
    1ac0:	f0 91 10 03 	lds	r31, 0x0310
    1ac4:	96 89       	ldd	r25, Z+22	; 0x16
    1ac6:	8e 85       	ldd	r24, Y+14	; 0x0e
    1ac8:	89 17       	cp	r24, r25
    1aca:	30 f0       	brcs	.+12     	; 0x1ad8 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    1acc:	8b 81       	ldd	r24, Y+3	; 0x03
    1ace:	9c 81       	ldd	r25, Y+4	; 0x04
    1ad0:	90 93 10 03 	sts	0x0310, r25
    1ad4:	80 93 0f 03 	sts	0x030F, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1ad8:	eb 81       	ldd	r30, Y+3	; 0x03
    1ada:	fc 81       	ldd	r31, Y+4	; 0x04
    1adc:	96 89       	ldd	r25, Z+22	; 0x16
    1ade:	80 91 15 03 	lds	r24, 0x0315
    1ae2:	89 17       	cp	r24, r25
    1ae4:	28 f4       	brcc	.+10     	; 0x1af0 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1ae6:	eb 81       	ldd	r30, Y+3	; 0x03
    1ae8:	fc 81       	ldd	r31, Y+4	; 0x04
    1aea:	86 89       	ldd	r24, Z+22	; 0x16
    1aec:	80 93 15 03 	sts	0x0315, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1af0:	80 91 1c 03 	lds	r24, 0x031C
    1af4:	8f 5f       	subi	r24, 0xFF	; 255
    1af6:	80 93 1c 03 	sts	0x031C, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    1afa:	eb 81       	ldd	r30, Y+3	; 0x03
    1afc:	fc 81       	ldd	r31, Y+4	; 0x04
    1afe:	96 89       	ldd	r25, Z+22	; 0x16
    1b00:	80 91 16 03 	lds	r24, 0x0316
    1b04:	89 17       	cp	r24, r25
    1b06:	28 f4       	brcc	.+10     	; 0x1b12 <xTaskGenericCreate+0x152>
    1b08:	eb 81       	ldd	r30, Y+3	; 0x03
    1b0a:	fc 81       	ldd	r31, Y+4	; 0x04
    1b0c:	86 89       	ldd	r24, Z+22	; 0x16
    1b0e:	80 93 16 03 	sts	0x0316, r24
    1b12:	eb 81       	ldd	r30, Y+3	; 0x03
    1b14:	fc 81       	ldd	r31, Y+4	; 0x04
    1b16:	86 89       	ldd	r24, Z+22	; 0x16
    1b18:	28 2f       	mov	r18, r24
    1b1a:	30 e0       	ldi	r19, 0x00	; 0
    1b1c:	c9 01       	movw	r24, r18
    1b1e:	88 0f       	add	r24, r24
    1b20:	99 1f       	adc	r25, r25
    1b22:	88 0f       	add	r24, r24
    1b24:	99 1f       	adc	r25, r25
    1b26:	88 0f       	add	r24, r24
    1b28:	99 1f       	adc	r25, r25
    1b2a:	82 0f       	add	r24, r18
    1b2c:	93 1f       	adc	r25, r19
    1b2e:	ac 01       	movw	r20, r24
    1b30:	43 5e       	subi	r20, 0xE3	; 227
    1b32:	5c 4f       	sbci	r21, 0xFC	; 252
    1b34:	8b 81       	ldd	r24, Y+3	; 0x03
    1b36:	9c 81       	ldd	r25, Y+4	; 0x04
    1b38:	9c 01       	movw	r18, r24
    1b3a:	2e 5f       	subi	r18, 0xFE	; 254
    1b3c:	3f 4f       	sbci	r19, 0xFF	; 255
    1b3e:	ca 01       	movw	r24, r20
    1b40:	b9 01       	movw	r22, r18
    1b42:	0e 94 8c 04 	call	0x918	; 0x918 <vListInsertEnd>

			xReturn = pdPASS;
    1b46:	81 e0       	ldi	r24, 0x01	; 1
    1b48:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1b4a:	0f 90       	pop	r0
    1b4c:	0f be       	out	0x3f, r0	; 63
    1b4e:	02 c0       	rjmp	.+4      	; 0x1b54 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1b50:	8f ef       	ldi	r24, 0xFF	; 255
    1b52:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    1b54:	8d 81       	ldd	r24, Y+5	; 0x05
    1b56:	81 30       	cpi	r24, 0x01	; 1
    1b58:	71 f4       	brne	.+28     	; 0x1b76 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    1b5a:	80 91 17 03 	lds	r24, 0x0317
    1b5e:	88 23       	and	r24, r24
    1b60:	51 f0       	breq	.+20     	; 0x1b76 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1b62:	e0 91 0f 03 	lds	r30, 0x030F
    1b66:	f0 91 10 03 	lds	r31, 0x0310
    1b6a:	96 89       	ldd	r25, Z+22	; 0x16
    1b6c:	8e 85       	ldd	r24, Y+14	; 0x0e
    1b6e:	98 17       	cp	r25, r24
    1b70:	10 f4       	brcc	.+4      	; 0x1b76 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    1b72:	0e 94 4c 07 	call	0xe98	; 0xe98 <vPortYield>
			}
		}
	}

	return xReturn;
    1b76:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1b78:	64 96       	adiw	r28, 0x14	; 20
    1b7a:	0f b6       	in	r0, 0x3f	; 63
    1b7c:	f8 94       	cli
    1b7e:	de bf       	out	0x3e, r29	; 62
    1b80:	0f be       	out	0x3f, r0	; 63
    1b82:	cd bf       	out	0x3d, r28	; 61
    1b84:	cf 91       	pop	r28
    1b86:	df 91       	pop	r29
    1b88:	1f 91       	pop	r17
    1b8a:	0f 91       	pop	r16
    1b8c:	ff 90       	pop	r15
    1b8e:	ef 90       	pop	r14
    1b90:	df 90       	pop	r13
    1b92:	cf 90       	pop	r12
    1b94:	bf 90       	pop	r11
    1b96:	af 90       	pop	r10
    1b98:	08 95       	ret

00001b9a <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1b9a:	df 93       	push	r29
    1b9c:	cf 93       	push	r28
    1b9e:	00 d0       	rcall	.+0      	; 0x1ba0 <vTaskDelete+0x6>
    1ba0:	00 d0       	rcall	.+0      	; 0x1ba2 <vTaskDelete+0x8>
    1ba2:	00 d0       	rcall	.+0      	; 0x1ba4 <vTaskDelete+0xa>
    1ba4:	cd b7       	in	r28, 0x3d	; 61
    1ba6:	de b7       	in	r29, 0x3e	; 62
    1ba8:	9c 83       	std	Y+4, r25	; 0x04
    1baa:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1bac:	0f b6       	in	r0, 0x3f	; 63
    1bae:	f8 94       	cli
    1bb0:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1bb2:	20 91 0f 03 	lds	r18, 0x030F
    1bb6:	30 91 10 03 	lds	r19, 0x0310
    1bba:	8b 81       	ldd	r24, Y+3	; 0x03
    1bbc:	9c 81       	ldd	r25, Y+4	; 0x04
    1bbe:	82 17       	cp	r24, r18
    1bc0:	93 07       	cpc	r25, r19
    1bc2:	11 f4       	brne	.+4      	; 0x1bc8 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    1bc4:	1c 82       	std	Y+4, r1	; 0x04
    1bc6:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1bc8:	8b 81       	ldd	r24, Y+3	; 0x03
    1bca:	9c 81       	ldd	r25, Y+4	; 0x04
    1bcc:	00 97       	sbiw	r24, 0x00	; 0
    1bce:	39 f4       	brne	.+14     	; 0x1bde <vTaskDelete+0x44>
    1bd0:	80 91 0f 03 	lds	r24, 0x030F
    1bd4:	90 91 10 03 	lds	r25, 0x0310
    1bd8:	9e 83       	std	Y+6, r25	; 0x06
    1bda:	8d 83       	std	Y+5, r24	; 0x05
    1bdc:	04 c0       	rjmp	.+8      	; 0x1be6 <vTaskDelete+0x4c>
    1bde:	8b 81       	ldd	r24, Y+3	; 0x03
    1be0:	9c 81       	ldd	r25, Y+4	; 0x04
    1be2:	9e 83       	std	Y+6, r25	; 0x06
    1be4:	8d 83       	std	Y+5, r24	; 0x05
    1be6:	8d 81       	ldd	r24, Y+5	; 0x05
    1be8:	9e 81       	ldd	r25, Y+6	; 0x06
    1bea:	9a 83       	std	Y+2, r25	; 0x02
    1bec:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1bee:	89 81       	ldd	r24, Y+1	; 0x01
    1bf0:	9a 81       	ldd	r25, Y+2	; 0x02
    1bf2:	02 96       	adiw	r24, 0x02	; 2
    1bf4:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1bf8:	e9 81       	ldd	r30, Y+1	; 0x01
    1bfa:	fa 81       	ldd	r31, Y+2	; 0x02
    1bfc:	84 89       	ldd	r24, Z+20	; 0x14
    1bfe:	95 89       	ldd	r25, Z+21	; 0x15
    1c00:	00 97       	sbiw	r24, 0x00	; 0
    1c02:	29 f0       	breq	.+10     	; 0x1c0e <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1c04:	89 81       	ldd	r24, Y+1	; 0x01
    1c06:	9a 81       	ldd	r25, Y+2	; 0x02
    1c08:	0c 96       	adiw	r24, 0x0c	; 12
    1c0a:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1c0e:	89 81       	ldd	r24, Y+1	; 0x01
    1c10:	9a 81       	ldd	r25, Y+2	; 0x02
    1c12:	9c 01       	movw	r18, r24
    1c14:	2e 5f       	subi	r18, 0xFE	; 254
    1c16:	3f 4f       	sbci	r19, 0xFF	; 255
    1c18:	89 e6       	ldi	r24, 0x69	; 105
    1c1a:	93 e0       	ldi	r25, 0x03	; 3
    1c1c:	b9 01       	movw	r22, r18
    1c1e:	0e 94 8c 04 	call	0x918	; 0x918 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1c22:	80 91 11 03 	lds	r24, 0x0311
    1c26:	8f 5f       	subi	r24, 0xFF	; 255
    1c28:	80 93 11 03 	sts	0x0311, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1c2c:	80 91 1c 03 	lds	r24, 0x031C
    1c30:	8f 5f       	subi	r24, 0xFF	; 255
    1c32:	80 93 1c 03 	sts	0x031C, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1c36:	0f 90       	pop	r0
    1c38:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1c3a:	80 91 17 03 	lds	r24, 0x0317
    1c3e:	88 23       	and	r24, r24
    1c40:	31 f0       	breq	.+12     	; 0x1c4e <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1c42:	8b 81       	ldd	r24, Y+3	; 0x03
    1c44:	9c 81       	ldd	r25, Y+4	; 0x04
    1c46:	00 97       	sbiw	r24, 0x00	; 0
    1c48:	11 f4       	brne	.+4      	; 0x1c4e <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    1c4a:	0e 94 4c 07 	call	0xe98	; 0xe98 <vPortYield>
			}
		}
	}
    1c4e:	26 96       	adiw	r28, 0x06	; 6
    1c50:	0f b6       	in	r0, 0x3f	; 63
    1c52:	f8 94       	cli
    1c54:	de bf       	out	0x3e, r29	; 62
    1c56:	0f be       	out	0x3f, r0	; 63
    1c58:	cd bf       	out	0x3d, r28	; 61
    1c5a:	cf 91       	pop	r28
    1c5c:	df 91       	pop	r29
    1c5e:	08 95       	ret

00001c60 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    1c60:	df 93       	push	r29
    1c62:	cf 93       	push	r28
    1c64:	cd b7       	in	r28, 0x3d	; 61
    1c66:	de b7       	in	r29, 0x3e	; 62
    1c68:	28 97       	sbiw	r28, 0x08	; 8
    1c6a:	0f b6       	in	r0, 0x3f	; 63
    1c6c:	f8 94       	cli
    1c6e:	de bf       	out	0x3e, r29	; 62
    1c70:	0f be       	out	0x3f, r0	; 63
    1c72:	cd bf       	out	0x3d, r28	; 61
    1c74:	9e 83       	std	Y+6, r25	; 0x06
    1c76:	8d 83       	std	Y+5, r24	; 0x05
    1c78:	78 87       	std	Y+8, r23	; 0x08
    1c7a:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    1c7c:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    1c7e:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1c82:	ed 81       	ldd	r30, Y+5	; 0x05
    1c84:	fe 81       	ldd	r31, Y+6	; 0x06
    1c86:	20 81       	ld	r18, Z
    1c88:	31 81       	ldd	r19, Z+1	; 0x01
    1c8a:	8f 81       	ldd	r24, Y+7	; 0x07
    1c8c:	98 85       	ldd	r25, Y+8	; 0x08
    1c8e:	82 0f       	add	r24, r18
    1c90:	93 1f       	adc	r25, r19
    1c92:	9c 83       	std	Y+4, r25	; 0x04
    1c94:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    1c96:	ed 81       	ldd	r30, Y+5	; 0x05
    1c98:	fe 81       	ldd	r31, Y+6	; 0x06
    1c9a:	20 81       	ld	r18, Z
    1c9c:	31 81       	ldd	r19, Z+1	; 0x01
    1c9e:	80 91 13 03 	lds	r24, 0x0313
    1ca2:	90 91 14 03 	lds	r25, 0x0314
    1ca6:	82 17       	cp	r24, r18
    1ca8:	93 07       	cpc	r25, r19
    1caa:	a8 f4       	brcc	.+42     	; 0x1cd6 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    1cac:	ed 81       	ldd	r30, Y+5	; 0x05
    1cae:	fe 81       	ldd	r31, Y+6	; 0x06
    1cb0:	20 81       	ld	r18, Z
    1cb2:	31 81       	ldd	r19, Z+1	; 0x01
    1cb4:	8b 81       	ldd	r24, Y+3	; 0x03
    1cb6:	9c 81       	ldd	r25, Y+4	; 0x04
    1cb8:	82 17       	cp	r24, r18
    1cba:	93 07       	cpc	r25, r19
    1cbc:	00 f5       	brcc	.+64     	; 0x1cfe <vTaskDelayUntil+0x9e>
    1cbe:	20 91 13 03 	lds	r18, 0x0313
    1cc2:	30 91 14 03 	lds	r19, 0x0314
    1cc6:	8b 81       	ldd	r24, Y+3	; 0x03
    1cc8:	9c 81       	ldd	r25, Y+4	; 0x04
    1cca:	28 17       	cp	r18, r24
    1ccc:	39 07       	cpc	r19, r25
    1cce:	b8 f4       	brcc	.+46     	; 0x1cfe <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1cd0:	81 e0       	ldi	r24, 0x01	; 1
    1cd2:	89 83       	std	Y+1, r24	; 0x01
    1cd4:	14 c0       	rjmp	.+40     	; 0x1cfe <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    1cd6:	ed 81       	ldd	r30, Y+5	; 0x05
    1cd8:	fe 81       	ldd	r31, Y+6	; 0x06
    1cda:	20 81       	ld	r18, Z
    1cdc:	31 81       	ldd	r19, Z+1	; 0x01
    1cde:	8b 81       	ldd	r24, Y+3	; 0x03
    1ce0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ce2:	82 17       	cp	r24, r18
    1ce4:	93 07       	cpc	r25, r19
    1ce6:	48 f0       	brcs	.+18     	; 0x1cfa <vTaskDelayUntil+0x9a>
    1ce8:	20 91 13 03 	lds	r18, 0x0313
    1cec:	30 91 14 03 	lds	r19, 0x0314
    1cf0:	8b 81       	ldd	r24, Y+3	; 0x03
    1cf2:	9c 81       	ldd	r25, Y+4	; 0x04
    1cf4:	28 17       	cp	r18, r24
    1cf6:	39 07       	cpc	r19, r25
    1cf8:	10 f4       	brcc	.+4      	; 0x1cfe <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    1cfa:	81 e0       	ldi	r24, 0x01	; 1
    1cfc:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1cfe:	ed 81       	ldd	r30, Y+5	; 0x05
    1d00:	fe 81       	ldd	r31, Y+6	; 0x06
    1d02:	8b 81       	ldd	r24, Y+3	; 0x03
    1d04:	9c 81       	ldd	r25, Y+4	; 0x04
    1d06:	91 83       	std	Z+1, r25	; 0x01
    1d08:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    1d0a:	89 81       	ldd	r24, Y+1	; 0x01
    1d0c:	88 23       	and	r24, r24
    1d0e:	59 f0       	breq	.+22     	; 0x1d26 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1d10:	80 91 0f 03 	lds	r24, 0x030F
    1d14:	90 91 10 03 	lds	r25, 0x0310
    1d18:	02 96       	adiw	r24, 0x02	; 2
    1d1a:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1d1e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d20:	9c 81       	ldd	r25, Y+4	; 0x04
    1d22:	0e 94 1c 13 	call	0x2638	; 0x2638 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1d26:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <xTaskResumeAll>
    1d2a:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1d2c:	8a 81       	ldd	r24, Y+2	; 0x02
    1d2e:	88 23       	and	r24, r24
    1d30:	11 f4       	brne	.+4      	; 0x1d36 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    1d32:	0e 94 4c 07 	call	0xe98	; 0xe98 <vPortYield>
		}
	}
    1d36:	28 96       	adiw	r28, 0x08	; 8
    1d38:	0f b6       	in	r0, 0x3f	; 63
    1d3a:	f8 94       	cli
    1d3c:	de bf       	out	0x3e, r29	; 62
    1d3e:	0f be       	out	0x3f, r0	; 63
    1d40:	cd bf       	out	0x3d, r28	; 61
    1d42:	cf 91       	pop	r28
    1d44:	df 91       	pop	r29
    1d46:	08 95       	ret

00001d48 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1d48:	df 93       	push	r29
    1d4a:	cf 93       	push	r28
    1d4c:	00 d0       	rcall	.+0      	; 0x1d4e <vTaskDelay+0x6>
    1d4e:	00 d0       	rcall	.+0      	; 0x1d50 <vTaskDelay+0x8>
    1d50:	0f 92       	push	r0
    1d52:	cd b7       	in	r28, 0x3d	; 61
    1d54:	de b7       	in	r29, 0x3e	; 62
    1d56:	9d 83       	std	Y+5, r25	; 0x05
    1d58:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1d5a:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1d5c:	8c 81       	ldd	r24, Y+4	; 0x04
    1d5e:	9d 81       	ldd	r25, Y+5	; 0x05
    1d60:	00 97       	sbiw	r24, 0x00	; 0
    1d62:	d1 f0       	breq	.+52     	; 0x1d98 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    1d64:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1d68:	20 91 13 03 	lds	r18, 0x0313
    1d6c:	30 91 14 03 	lds	r19, 0x0314
    1d70:	8c 81       	ldd	r24, Y+4	; 0x04
    1d72:	9d 81       	ldd	r25, Y+5	; 0x05
    1d74:	82 0f       	add	r24, r18
    1d76:	93 1f       	adc	r25, r19
    1d78:	9b 83       	std	Y+3, r25	; 0x03
    1d7a:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1d7c:	80 91 0f 03 	lds	r24, 0x030F
    1d80:	90 91 10 03 	lds	r25, 0x0310
    1d84:	02 96       	adiw	r24, 0x02	; 2
    1d86:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1d8a:	8a 81       	ldd	r24, Y+2	; 0x02
    1d8c:	9b 81       	ldd	r25, Y+3	; 0x03
    1d8e:	0e 94 1c 13 	call	0x2638	; 0x2638 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1d92:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <xTaskResumeAll>
    1d96:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1d98:	89 81       	ldd	r24, Y+1	; 0x01
    1d9a:	88 23       	and	r24, r24
    1d9c:	11 f4       	brne	.+4      	; 0x1da2 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    1d9e:	0e 94 4c 07 	call	0xe98	; 0xe98 <vPortYield>
		}
	}
    1da2:	0f 90       	pop	r0
    1da4:	0f 90       	pop	r0
    1da6:	0f 90       	pop	r0
    1da8:	0f 90       	pop	r0
    1daa:	0f 90       	pop	r0
    1dac:	cf 91       	pop	r28
    1dae:	df 91       	pop	r29
    1db0:	08 95       	ret

00001db2 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1db2:	af 92       	push	r10
    1db4:	bf 92       	push	r11
    1db6:	cf 92       	push	r12
    1db8:	df 92       	push	r13
    1dba:	ef 92       	push	r14
    1dbc:	ff 92       	push	r15
    1dbe:	0f 93       	push	r16
    1dc0:	df 93       	push	r29
    1dc2:	cf 93       	push	r28
    1dc4:	0f 92       	push	r0
    1dc6:	cd b7       	in	r28, 0x3d	; 61
    1dc8:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    1dca:	21 e7       	ldi	r18, 0x71	; 113
    1dcc:	30 e0       	ldi	r19, 0x00	; 0
    1dce:	80 e4       	ldi	r24, 0x40	; 64
    1dd0:	92 e1       	ldi	r25, 0x12	; 18
    1dd2:	b9 01       	movw	r22, r18
    1dd4:	45 e5       	ldi	r20, 0x55	; 85
    1dd6:	50 e0       	ldi	r21, 0x00	; 0
    1dd8:	20 e0       	ldi	r18, 0x00	; 0
    1dda:	30 e0       	ldi	r19, 0x00	; 0
    1ddc:	00 e0       	ldi	r16, 0x00	; 0
    1dde:	ee 24       	eor	r14, r14
    1de0:	ff 24       	eor	r15, r15
    1de2:	cc 24       	eor	r12, r12
    1de4:	dd 24       	eor	r13, r13
    1de6:	aa 24       	eor	r10, r10
    1de8:	bb 24       	eor	r11, r11
    1dea:	0e 94 e0 0c 	call	0x19c0	; 0x19c0 <xTaskGenericCreate>
    1dee:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    1df0:	89 81       	ldd	r24, Y+1	; 0x01
    1df2:	81 30       	cpi	r24, 0x01	; 1
    1df4:	51 f4       	brne	.+20     	; 0x1e0a <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1df6:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1df8:	81 e0       	ldi	r24, 0x01	; 1
    1dfa:	80 93 17 03 	sts	0x0317, r24
		xTickCount = ( portTickType ) 0U;
    1dfe:	10 92 14 03 	sts	0x0314, r1
    1e02:	10 92 13 03 	sts	0x0313, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1e06:	0e 94 10 07 	call	0xe20	; 0xe20 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    1e0a:	0f 90       	pop	r0
    1e0c:	cf 91       	pop	r28
    1e0e:	df 91       	pop	r29
    1e10:	0f 91       	pop	r16
    1e12:	ff 90       	pop	r15
    1e14:	ef 90       	pop	r14
    1e16:	df 90       	pop	r13
    1e18:	cf 90       	pop	r12
    1e1a:	bf 90       	pop	r11
    1e1c:	af 90       	pop	r10
    1e1e:	08 95       	ret

00001e20 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    1e20:	df 93       	push	r29
    1e22:	cf 93       	push	r28
    1e24:	cd b7       	in	r28, 0x3d	; 61
    1e26:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1e28:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1e2a:	10 92 17 03 	sts	0x0317, r1
	vPortEndScheduler();
    1e2e:	0e 94 45 07 	call	0xe8a	; 0xe8a <vPortEndScheduler>
}
    1e32:	cf 91       	pop	r28
    1e34:	df 91       	pop	r29
    1e36:	08 95       	ret

00001e38 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    1e38:	df 93       	push	r29
    1e3a:	cf 93       	push	r28
    1e3c:	cd b7       	in	r28, 0x3d	; 61
    1e3e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1e40:	80 91 18 03 	lds	r24, 0x0318
    1e44:	8f 5f       	subi	r24, 0xFF	; 255
    1e46:	80 93 18 03 	sts	0x0318, r24
}
    1e4a:	cf 91       	pop	r28
    1e4c:	df 91       	pop	r29
    1e4e:	08 95       	ret

00001e50 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1e50:	df 93       	push	r29
    1e52:	cf 93       	push	r28
    1e54:	00 d0       	rcall	.+0      	; 0x1e56 <xTaskResumeAll+0x6>
    1e56:	00 d0       	rcall	.+0      	; 0x1e58 <xTaskResumeAll+0x8>
    1e58:	cd b7       	in	r28, 0x3d	; 61
    1e5a:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1e5c:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1e5e:	0f b6       	in	r0, 0x3f	; 63
    1e60:	f8 94       	cli
    1e62:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1e64:	80 91 18 03 	lds	r24, 0x0318
    1e68:	81 50       	subi	r24, 0x01	; 1
    1e6a:	80 93 18 03 	sts	0x0318, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1e6e:	80 91 18 03 	lds	r24, 0x0318
    1e72:	88 23       	and	r24, r24
    1e74:	09 f0       	breq	.+2      	; 0x1e78 <xTaskResumeAll+0x28>
    1e76:	6c c0       	rjmp	.+216    	; 0x1f50 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    1e78:	80 91 12 03 	lds	r24, 0x0312
    1e7c:	88 23       	and	r24, r24
    1e7e:	09 f4       	brne	.+2      	; 0x1e82 <xTaskResumeAll+0x32>
    1e80:	67 c0       	rjmp	.+206    	; 0x1f50 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    1e82:	19 82       	std	Y+1, r1	; 0x01
    1e84:	41 c0       	rjmp	.+130    	; 0x1f08 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    1e86:	e0 91 65 03 	lds	r30, 0x0365
    1e8a:	f0 91 66 03 	lds	r31, 0x0366
    1e8e:	86 81       	ldd	r24, Z+6	; 0x06
    1e90:	97 81       	ldd	r25, Z+7	; 0x07
    1e92:	9c 83       	std	Y+4, r25	; 0x04
    1e94:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    1e96:	8b 81       	ldd	r24, Y+3	; 0x03
    1e98:	9c 81       	ldd	r25, Y+4	; 0x04
    1e9a:	0c 96       	adiw	r24, 0x0c	; 12
    1e9c:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1ea0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ea2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ea4:	02 96       	adiw	r24, 0x02	; 2
    1ea6:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1eaa:	eb 81       	ldd	r30, Y+3	; 0x03
    1eac:	fc 81       	ldd	r31, Y+4	; 0x04
    1eae:	96 89       	ldd	r25, Z+22	; 0x16
    1eb0:	80 91 16 03 	lds	r24, 0x0316
    1eb4:	89 17       	cp	r24, r25
    1eb6:	28 f4       	brcc	.+10     	; 0x1ec2 <xTaskResumeAll+0x72>
    1eb8:	eb 81       	ldd	r30, Y+3	; 0x03
    1eba:	fc 81       	ldd	r31, Y+4	; 0x04
    1ebc:	86 89       	ldd	r24, Z+22	; 0x16
    1ebe:	80 93 16 03 	sts	0x0316, r24
    1ec2:	eb 81       	ldd	r30, Y+3	; 0x03
    1ec4:	fc 81       	ldd	r31, Y+4	; 0x04
    1ec6:	86 89       	ldd	r24, Z+22	; 0x16
    1ec8:	28 2f       	mov	r18, r24
    1eca:	30 e0       	ldi	r19, 0x00	; 0
    1ecc:	c9 01       	movw	r24, r18
    1ece:	88 0f       	add	r24, r24
    1ed0:	99 1f       	adc	r25, r25
    1ed2:	88 0f       	add	r24, r24
    1ed4:	99 1f       	adc	r25, r25
    1ed6:	88 0f       	add	r24, r24
    1ed8:	99 1f       	adc	r25, r25
    1eda:	82 0f       	add	r24, r18
    1edc:	93 1f       	adc	r25, r19
    1ede:	83 5e       	subi	r24, 0xE3	; 227
    1ee0:	9c 4f       	sbci	r25, 0xFC	; 252
    1ee2:	2b 81       	ldd	r18, Y+3	; 0x03
    1ee4:	3c 81       	ldd	r19, Y+4	; 0x04
    1ee6:	2e 5f       	subi	r18, 0xFE	; 254
    1ee8:	3f 4f       	sbci	r19, 0xFF	; 255
    1eea:	b9 01       	movw	r22, r18
    1eec:	0e 94 8c 04 	call	0x918	; 0x918 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1ef0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ef2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ef4:	96 89       	ldd	r25, Z+22	; 0x16
    1ef6:	e0 91 0f 03 	lds	r30, 0x030F
    1efa:	f0 91 10 03 	lds	r31, 0x0310
    1efe:	86 89       	ldd	r24, Z+22	; 0x16
    1f00:	98 17       	cp	r25, r24
    1f02:	10 f0       	brcs	.+4      	; 0x1f08 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    1f04:	81 e0       	ldi	r24, 0x01	; 1
    1f06:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1f08:	80 91 60 03 	lds	r24, 0x0360
    1f0c:	88 23       	and	r24, r24
    1f0e:	09 f0       	breq	.+2      	; 0x1f12 <xTaskResumeAll+0xc2>
    1f10:	ba cf       	rjmp	.-140    	; 0x1e86 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1f12:	80 91 19 03 	lds	r24, 0x0319
    1f16:	88 23       	and	r24, r24
    1f18:	71 f0       	breq	.+28     	; 0x1f36 <xTaskResumeAll+0xe6>
    1f1a:	07 c0       	rjmp	.+14     	; 0x1f2a <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    1f1c:	0e 94 e7 0f 	call	0x1fce	; 0x1fce <vTaskIncrementTick>
						--uxMissedTicks;
    1f20:	80 91 19 03 	lds	r24, 0x0319
    1f24:	81 50       	subi	r24, 0x01	; 1
    1f26:	80 93 19 03 	sts	0x0319, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1f2a:	80 91 19 03 	lds	r24, 0x0319
    1f2e:	88 23       	and	r24, r24
    1f30:	a9 f7       	brne	.-22     	; 0x1f1c <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    1f32:	81 e0       	ldi	r24, 0x01	; 1
    1f34:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1f36:	89 81       	ldd	r24, Y+1	; 0x01
    1f38:	81 30       	cpi	r24, 0x01	; 1
    1f3a:	21 f0       	breq	.+8      	; 0x1f44 <xTaskResumeAll+0xf4>
    1f3c:	80 91 1a 03 	lds	r24, 0x031A
    1f40:	81 30       	cpi	r24, 0x01	; 1
    1f42:	31 f4       	brne	.+12     	; 0x1f50 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    1f44:	81 e0       	ldi	r24, 0x01	; 1
    1f46:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    1f48:	10 92 1a 03 	sts	0x031A, r1
					portYIELD_WITHIN_API();
    1f4c:	0e 94 4c 07 	call	0xe98	; 0xe98 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    1f50:	0f 90       	pop	r0
    1f52:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    1f54:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1f56:	0f 90       	pop	r0
    1f58:	0f 90       	pop	r0
    1f5a:	0f 90       	pop	r0
    1f5c:	0f 90       	pop	r0
    1f5e:	cf 91       	pop	r28
    1f60:	df 91       	pop	r29
    1f62:	08 95       	ret

00001f64 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    1f64:	df 93       	push	r29
    1f66:	cf 93       	push	r28
    1f68:	00 d0       	rcall	.+0      	; 0x1f6a <xTaskGetTickCount+0x6>
    1f6a:	cd b7       	in	r28, 0x3d	; 61
    1f6c:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    1f6e:	0f b6       	in	r0, 0x3f	; 63
    1f70:	f8 94       	cli
    1f72:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1f74:	80 91 13 03 	lds	r24, 0x0313
    1f78:	90 91 14 03 	lds	r25, 0x0314
    1f7c:	9a 83       	std	Y+2, r25	; 0x02
    1f7e:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    1f80:	0f 90       	pop	r0
    1f82:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    1f84:	89 81       	ldd	r24, Y+1	; 0x01
    1f86:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1f88:	0f 90       	pop	r0
    1f8a:	0f 90       	pop	r0
    1f8c:	cf 91       	pop	r28
    1f8e:	df 91       	pop	r29
    1f90:	08 95       	ret

00001f92 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    1f92:	df 93       	push	r29
    1f94:	cf 93       	push	r28
    1f96:	00 d0       	rcall	.+0      	; 0x1f98 <xTaskGetTickCountFromISR+0x6>
    1f98:	0f 92       	push	r0
    1f9a:	cd b7       	in	r28, 0x3d	; 61
    1f9c:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1f9e:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    1fa0:	80 91 13 03 	lds	r24, 0x0313
    1fa4:	90 91 14 03 	lds	r25, 0x0314
    1fa8:	9b 83       	std	Y+3, r25	; 0x03
    1faa:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1fac:	8a 81       	ldd	r24, Y+2	; 0x02
    1fae:	9b 81       	ldd	r25, Y+3	; 0x03
}
    1fb0:	0f 90       	pop	r0
    1fb2:	0f 90       	pop	r0
    1fb4:	0f 90       	pop	r0
    1fb6:	cf 91       	pop	r28
    1fb8:	df 91       	pop	r29
    1fba:	08 95       	ret

00001fbc <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    1fbc:	df 93       	push	r29
    1fbe:	cf 93       	push	r28
    1fc0:	cd b7       	in	r28, 0x3d	; 61
    1fc2:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1fc4:	80 91 12 03 	lds	r24, 0x0312
}
    1fc8:	cf 91       	pop	r28
    1fca:	df 91       	pop	r29
    1fcc:	08 95       	ret

00001fce <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1fce:	df 93       	push	r29
    1fd0:	cf 93       	push	r28
    1fd2:	00 d0       	rcall	.+0      	; 0x1fd4 <vTaskIncrementTick+0x6>
    1fd4:	00 d0       	rcall	.+0      	; 0x1fd6 <vTaskIncrementTick+0x8>
    1fd6:	00 d0       	rcall	.+0      	; 0x1fd8 <vTaskIncrementTick+0xa>
    1fd8:	cd b7       	in	r28, 0x3d	; 61
    1fda:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1fdc:	80 91 18 03 	lds	r24, 0x0318
    1fe0:	88 23       	and	r24, r24
    1fe2:	09 f0       	breq	.+2      	; 0x1fe6 <vTaskIncrementTick+0x18>
    1fe4:	bb c0       	rjmp	.+374    	; 0x215c <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    1fe6:	80 91 13 03 	lds	r24, 0x0313
    1fea:	90 91 14 03 	lds	r25, 0x0314
    1fee:	01 96       	adiw	r24, 0x01	; 1
    1ff0:	90 93 14 03 	sts	0x0314, r25
    1ff4:	80 93 13 03 	sts	0x0313, r24
		if( xTickCount == ( portTickType ) 0U )
    1ff8:	80 91 13 03 	lds	r24, 0x0313
    1ffc:	90 91 14 03 	lds	r25, 0x0314
    2000:	00 97       	sbiw	r24, 0x00	; 0
    2002:	d1 f5       	brne	.+116    	; 0x2078 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    2004:	80 91 5c 03 	lds	r24, 0x035C
    2008:	90 91 5d 03 	lds	r25, 0x035D
    200c:	9c 83       	std	Y+4, r25	; 0x04
    200e:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2010:	80 91 5e 03 	lds	r24, 0x035E
    2014:	90 91 5f 03 	lds	r25, 0x035F
    2018:	90 93 5d 03 	sts	0x035D, r25
    201c:	80 93 5c 03 	sts	0x035C, r24
			pxOverflowDelayedTaskList = pxTemp;
    2020:	8b 81       	ldd	r24, Y+3	; 0x03
    2022:	9c 81       	ldd	r25, Y+4	; 0x04
    2024:	90 93 5f 03 	sts	0x035F, r25
    2028:	80 93 5e 03 	sts	0x035E, r24
			xNumOfOverflows++;
    202c:	80 91 1b 03 	lds	r24, 0x031B
    2030:	8f 5f       	subi	r24, 0xFF	; 255
    2032:	80 93 1b 03 	sts	0x031B, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2036:	e0 91 5c 03 	lds	r30, 0x035C
    203a:	f0 91 5d 03 	lds	r31, 0x035D
    203e:	80 81       	ld	r24, Z
    2040:	88 23       	and	r24, r24
    2042:	39 f4       	brne	.+14     	; 0x2052 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2044:	8f ef       	ldi	r24, 0xFF	; 255
    2046:	9f ef       	ldi	r25, 0xFF	; 255
    2048:	90 93 78 00 	sts	0x0078, r25
    204c:	80 93 77 00 	sts	0x0077, r24
    2050:	13 c0       	rjmp	.+38     	; 0x2078 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2052:	e0 91 5c 03 	lds	r30, 0x035C
    2056:	f0 91 5d 03 	lds	r31, 0x035D
    205a:	05 80       	ldd	r0, Z+5	; 0x05
    205c:	f6 81       	ldd	r31, Z+6	; 0x06
    205e:	e0 2d       	mov	r30, r0
    2060:	86 81       	ldd	r24, Z+6	; 0x06
    2062:	97 81       	ldd	r25, Z+7	; 0x07
    2064:	9e 83       	std	Y+6, r25	; 0x06
    2066:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2068:	ed 81       	ldd	r30, Y+5	; 0x05
    206a:	fe 81       	ldd	r31, Y+6	; 0x06
    206c:	82 81       	ldd	r24, Z+2	; 0x02
    206e:	93 81       	ldd	r25, Z+3	; 0x03
    2070:	90 93 78 00 	sts	0x0078, r25
    2074:	80 93 77 00 	sts	0x0077, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2078:	20 91 13 03 	lds	r18, 0x0313
    207c:	30 91 14 03 	lds	r19, 0x0314
    2080:	80 91 77 00 	lds	r24, 0x0077
    2084:	90 91 78 00 	lds	r25, 0x0078
    2088:	28 17       	cp	r18, r24
    208a:	39 07       	cpc	r19, r25
    208c:	08 f4       	brcc	.+2      	; 0x2090 <vTaskIncrementTick+0xc2>
    208e:	6b c0       	rjmp	.+214    	; 0x2166 <vTaskIncrementTick+0x198>
    2090:	e0 91 5c 03 	lds	r30, 0x035C
    2094:	f0 91 5d 03 	lds	r31, 0x035D
    2098:	80 81       	ld	r24, Z
    209a:	88 23       	and	r24, r24
    209c:	39 f4       	brne	.+14     	; 0x20ac <vTaskIncrementTick+0xde>
    209e:	8f ef       	ldi	r24, 0xFF	; 255
    20a0:	9f ef       	ldi	r25, 0xFF	; 255
    20a2:	90 93 78 00 	sts	0x0078, r25
    20a6:	80 93 77 00 	sts	0x0077, r24
    20aa:	5d c0       	rjmp	.+186    	; 0x2166 <vTaskIncrementTick+0x198>
    20ac:	e0 91 5c 03 	lds	r30, 0x035C
    20b0:	f0 91 5d 03 	lds	r31, 0x035D
    20b4:	05 80       	ldd	r0, Z+5	; 0x05
    20b6:	f6 81       	ldd	r31, Z+6	; 0x06
    20b8:	e0 2d       	mov	r30, r0
    20ba:	86 81       	ldd	r24, Z+6	; 0x06
    20bc:	97 81       	ldd	r25, Z+7	; 0x07
    20be:	9e 83       	std	Y+6, r25	; 0x06
    20c0:	8d 83       	std	Y+5, r24	; 0x05
    20c2:	ed 81       	ldd	r30, Y+5	; 0x05
    20c4:	fe 81       	ldd	r31, Y+6	; 0x06
    20c6:	82 81       	ldd	r24, Z+2	; 0x02
    20c8:	93 81       	ldd	r25, Z+3	; 0x03
    20ca:	9a 83       	std	Y+2, r25	; 0x02
    20cc:	89 83       	std	Y+1, r24	; 0x01
    20ce:	20 91 13 03 	lds	r18, 0x0313
    20d2:	30 91 14 03 	lds	r19, 0x0314
    20d6:	89 81       	ldd	r24, Y+1	; 0x01
    20d8:	9a 81       	ldd	r25, Y+2	; 0x02
    20da:	28 17       	cp	r18, r24
    20dc:	39 07       	cpc	r19, r25
    20de:	38 f4       	brcc	.+14     	; 0x20ee <vTaskIncrementTick+0x120>
    20e0:	89 81       	ldd	r24, Y+1	; 0x01
    20e2:	9a 81       	ldd	r25, Y+2	; 0x02
    20e4:	90 93 78 00 	sts	0x0078, r25
    20e8:	80 93 77 00 	sts	0x0077, r24
    20ec:	3c c0       	rjmp	.+120    	; 0x2166 <vTaskIncrementTick+0x198>
    20ee:	8d 81       	ldd	r24, Y+5	; 0x05
    20f0:	9e 81       	ldd	r25, Y+6	; 0x06
    20f2:	02 96       	adiw	r24, 0x02	; 2
    20f4:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
    20f8:	ed 81       	ldd	r30, Y+5	; 0x05
    20fa:	fe 81       	ldd	r31, Y+6	; 0x06
    20fc:	84 89       	ldd	r24, Z+20	; 0x14
    20fe:	95 89       	ldd	r25, Z+21	; 0x15
    2100:	00 97       	sbiw	r24, 0x00	; 0
    2102:	29 f0       	breq	.+10     	; 0x210e <vTaskIncrementTick+0x140>
    2104:	8d 81       	ldd	r24, Y+5	; 0x05
    2106:	9e 81       	ldd	r25, Y+6	; 0x06
    2108:	0c 96       	adiw	r24, 0x0c	; 12
    210a:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
    210e:	ed 81       	ldd	r30, Y+5	; 0x05
    2110:	fe 81       	ldd	r31, Y+6	; 0x06
    2112:	96 89       	ldd	r25, Z+22	; 0x16
    2114:	80 91 16 03 	lds	r24, 0x0316
    2118:	89 17       	cp	r24, r25
    211a:	28 f4       	brcc	.+10     	; 0x2126 <vTaskIncrementTick+0x158>
    211c:	ed 81       	ldd	r30, Y+5	; 0x05
    211e:	fe 81       	ldd	r31, Y+6	; 0x06
    2120:	86 89       	ldd	r24, Z+22	; 0x16
    2122:	80 93 16 03 	sts	0x0316, r24
    2126:	ed 81       	ldd	r30, Y+5	; 0x05
    2128:	fe 81       	ldd	r31, Y+6	; 0x06
    212a:	86 89       	ldd	r24, Z+22	; 0x16
    212c:	28 2f       	mov	r18, r24
    212e:	30 e0       	ldi	r19, 0x00	; 0
    2130:	c9 01       	movw	r24, r18
    2132:	88 0f       	add	r24, r24
    2134:	99 1f       	adc	r25, r25
    2136:	88 0f       	add	r24, r24
    2138:	99 1f       	adc	r25, r25
    213a:	88 0f       	add	r24, r24
    213c:	99 1f       	adc	r25, r25
    213e:	82 0f       	add	r24, r18
    2140:	93 1f       	adc	r25, r19
    2142:	ac 01       	movw	r20, r24
    2144:	43 5e       	subi	r20, 0xE3	; 227
    2146:	5c 4f       	sbci	r21, 0xFC	; 252
    2148:	8d 81       	ldd	r24, Y+5	; 0x05
    214a:	9e 81       	ldd	r25, Y+6	; 0x06
    214c:	9c 01       	movw	r18, r24
    214e:	2e 5f       	subi	r18, 0xFE	; 254
    2150:	3f 4f       	sbci	r19, 0xFF	; 255
    2152:	ca 01       	movw	r24, r20
    2154:	b9 01       	movw	r22, r18
    2156:	0e 94 8c 04 	call	0x918	; 0x918 <vListInsertEnd>
    215a:	9a cf       	rjmp	.-204    	; 0x2090 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    215c:	80 91 19 03 	lds	r24, 0x0319
    2160:	8f 5f       	subi	r24, 0xFF	; 255
    2162:	80 93 19 03 	sts	0x0319, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2166:	26 96       	adiw	r28, 0x06	; 6
    2168:	0f b6       	in	r0, 0x3f	; 63
    216a:	f8 94       	cli
    216c:	de bf       	out	0x3e, r29	; 62
    216e:	0f be       	out	0x3f, r0	; 63
    2170:	cd bf       	out	0x3d, r28	; 61
    2172:	cf 91       	pop	r28
    2174:	df 91       	pop	r29
    2176:	08 95       	ret

00002178 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    2178:	df 93       	push	r29
    217a:	cf 93       	push	r28
    217c:	00 d0       	rcall	.+0      	; 0x217e <vTaskSwitchContext+0x6>
    217e:	cd b7       	in	r28, 0x3d	; 61
    2180:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    2182:	80 91 18 03 	lds	r24, 0x0318
    2186:	88 23       	and	r24, r24
    2188:	49 f0       	breq	.+18     	; 0x219c <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    218a:	81 e0       	ldi	r24, 0x01	; 1
    218c:	80 93 1a 03 	sts	0x031A, r24
    2190:	54 c0       	rjmp	.+168    	; 0x223a <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2192:	80 91 16 03 	lds	r24, 0x0316
    2196:	81 50       	subi	r24, 0x01	; 1
    2198:	80 93 16 03 	sts	0x0316, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    219c:	80 91 16 03 	lds	r24, 0x0316
    21a0:	28 2f       	mov	r18, r24
    21a2:	30 e0       	ldi	r19, 0x00	; 0
    21a4:	c9 01       	movw	r24, r18
    21a6:	88 0f       	add	r24, r24
    21a8:	99 1f       	adc	r25, r25
    21aa:	88 0f       	add	r24, r24
    21ac:	99 1f       	adc	r25, r25
    21ae:	88 0f       	add	r24, r24
    21b0:	99 1f       	adc	r25, r25
    21b2:	82 0f       	add	r24, r18
    21b4:	93 1f       	adc	r25, r19
    21b6:	fc 01       	movw	r30, r24
    21b8:	e3 5e       	subi	r30, 0xE3	; 227
    21ba:	fc 4f       	sbci	r31, 0xFC	; 252
    21bc:	80 81       	ld	r24, Z
    21be:	88 23       	and	r24, r24
    21c0:	41 f3       	breq	.-48     	; 0x2192 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    21c2:	80 91 16 03 	lds	r24, 0x0316
    21c6:	28 2f       	mov	r18, r24
    21c8:	30 e0       	ldi	r19, 0x00	; 0
    21ca:	c9 01       	movw	r24, r18
    21cc:	88 0f       	add	r24, r24
    21ce:	99 1f       	adc	r25, r25
    21d0:	88 0f       	add	r24, r24
    21d2:	99 1f       	adc	r25, r25
    21d4:	88 0f       	add	r24, r24
    21d6:	99 1f       	adc	r25, r25
    21d8:	82 0f       	add	r24, r18
    21da:	93 1f       	adc	r25, r19
    21dc:	83 5e       	subi	r24, 0xE3	; 227
    21de:	9c 4f       	sbci	r25, 0xFC	; 252
    21e0:	9a 83       	std	Y+2, r25	; 0x02
    21e2:	89 83       	std	Y+1, r24	; 0x01
    21e4:	e9 81       	ldd	r30, Y+1	; 0x01
    21e6:	fa 81       	ldd	r31, Y+2	; 0x02
    21e8:	01 80       	ldd	r0, Z+1	; 0x01
    21ea:	f2 81       	ldd	r31, Z+2	; 0x02
    21ec:	e0 2d       	mov	r30, r0
    21ee:	82 81       	ldd	r24, Z+2	; 0x02
    21f0:	93 81       	ldd	r25, Z+3	; 0x03
    21f2:	e9 81       	ldd	r30, Y+1	; 0x01
    21f4:	fa 81       	ldd	r31, Y+2	; 0x02
    21f6:	92 83       	std	Z+2, r25	; 0x02
    21f8:	81 83       	std	Z+1, r24	; 0x01
    21fa:	e9 81       	ldd	r30, Y+1	; 0x01
    21fc:	fa 81       	ldd	r31, Y+2	; 0x02
    21fe:	21 81       	ldd	r18, Z+1	; 0x01
    2200:	32 81       	ldd	r19, Z+2	; 0x02
    2202:	89 81       	ldd	r24, Y+1	; 0x01
    2204:	9a 81       	ldd	r25, Y+2	; 0x02
    2206:	03 96       	adiw	r24, 0x03	; 3
    2208:	28 17       	cp	r18, r24
    220a:	39 07       	cpc	r19, r25
    220c:	59 f4       	brne	.+22     	; 0x2224 <vTaskSwitchContext+0xac>
    220e:	e9 81       	ldd	r30, Y+1	; 0x01
    2210:	fa 81       	ldd	r31, Y+2	; 0x02
    2212:	01 80       	ldd	r0, Z+1	; 0x01
    2214:	f2 81       	ldd	r31, Z+2	; 0x02
    2216:	e0 2d       	mov	r30, r0
    2218:	82 81       	ldd	r24, Z+2	; 0x02
    221a:	93 81       	ldd	r25, Z+3	; 0x03
    221c:	e9 81       	ldd	r30, Y+1	; 0x01
    221e:	fa 81       	ldd	r31, Y+2	; 0x02
    2220:	92 83       	std	Z+2, r25	; 0x02
    2222:	81 83       	std	Z+1, r24	; 0x01
    2224:	e9 81       	ldd	r30, Y+1	; 0x01
    2226:	fa 81       	ldd	r31, Y+2	; 0x02
    2228:	01 80       	ldd	r0, Z+1	; 0x01
    222a:	f2 81       	ldd	r31, Z+2	; 0x02
    222c:	e0 2d       	mov	r30, r0
    222e:	86 81       	ldd	r24, Z+6	; 0x06
    2230:	97 81       	ldd	r25, Z+7	; 0x07
    2232:	90 93 10 03 	sts	0x0310, r25
    2236:	80 93 0f 03 	sts	0x030F, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    223a:	0f 90       	pop	r0
    223c:	0f 90       	pop	r0
    223e:	cf 91       	pop	r28
    2240:	df 91       	pop	r29
    2242:	08 95       	ret

00002244 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2244:	df 93       	push	r29
    2246:	cf 93       	push	r28
    2248:	00 d0       	rcall	.+0      	; 0x224a <vTaskPlaceOnEventList+0x6>
    224a:	00 d0       	rcall	.+0      	; 0x224c <vTaskPlaceOnEventList+0x8>
    224c:	00 d0       	rcall	.+0      	; 0x224e <vTaskPlaceOnEventList+0xa>
    224e:	cd b7       	in	r28, 0x3d	; 61
    2250:	de b7       	in	r29, 0x3e	; 62
    2252:	9c 83       	std	Y+4, r25	; 0x04
    2254:	8b 83       	std	Y+3, r24	; 0x03
    2256:	7e 83       	std	Y+6, r23	; 0x06
    2258:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    225a:	4b 81       	ldd	r20, Y+3	; 0x03
    225c:	5c 81       	ldd	r21, Y+4	; 0x04
    225e:	80 91 0f 03 	lds	r24, 0x030F
    2262:	90 91 10 03 	lds	r25, 0x0310
    2266:	9c 01       	movw	r18, r24
    2268:	24 5f       	subi	r18, 0xF4	; 244
    226a:	3f 4f       	sbci	r19, 0xFF	; 255
    226c:	ca 01       	movw	r24, r20
    226e:	b9 01       	movw	r22, r18
    2270:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2274:	80 91 0f 03 	lds	r24, 0x030F
    2278:	90 91 10 03 	lds	r25, 0x0310
    227c:	02 96       	adiw	r24, 0x02	; 2
    227e:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    2282:	20 91 13 03 	lds	r18, 0x0313
    2286:	30 91 14 03 	lds	r19, 0x0314
    228a:	8d 81       	ldd	r24, Y+5	; 0x05
    228c:	9e 81       	ldd	r25, Y+6	; 0x06
    228e:	82 0f       	add	r24, r18
    2290:	93 1f       	adc	r25, r19
    2292:	9a 83       	std	Y+2, r25	; 0x02
    2294:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2296:	89 81       	ldd	r24, Y+1	; 0x01
    2298:	9a 81       	ldd	r25, Y+2	; 0x02
    229a:	0e 94 1c 13 	call	0x2638	; 0x2638 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    229e:	26 96       	adiw	r28, 0x06	; 6
    22a0:	0f b6       	in	r0, 0x3f	; 63
    22a2:	f8 94       	cli
    22a4:	de bf       	out	0x3e, r29	; 62
    22a6:	0f be       	out	0x3f, r0	; 63
    22a8:	cd bf       	out	0x3d, r28	; 61
    22aa:	cf 91       	pop	r28
    22ac:	df 91       	pop	r29
    22ae:	08 95       	ret

000022b0 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    22b0:	df 93       	push	r29
    22b2:	cf 93       	push	r28
    22b4:	00 d0       	rcall	.+0      	; 0x22b6 <xTaskRemoveFromEventList+0x6>
    22b6:	00 d0       	rcall	.+0      	; 0x22b8 <xTaskRemoveFromEventList+0x8>
    22b8:	0f 92       	push	r0
    22ba:	cd b7       	in	r28, 0x3d	; 61
    22bc:	de b7       	in	r29, 0x3e	; 62
    22be:	9d 83       	std	Y+5, r25	; 0x05
    22c0:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    22c2:	ec 81       	ldd	r30, Y+4	; 0x04
    22c4:	fd 81       	ldd	r31, Y+5	; 0x05
    22c6:	05 80       	ldd	r0, Z+5	; 0x05
    22c8:	f6 81       	ldd	r31, Z+6	; 0x06
    22ca:	e0 2d       	mov	r30, r0
    22cc:	86 81       	ldd	r24, Z+6	; 0x06
    22ce:	97 81       	ldd	r25, Z+7	; 0x07
    22d0:	9b 83       	std	Y+3, r25	; 0x03
    22d2:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    22d4:	8a 81       	ldd	r24, Y+2	; 0x02
    22d6:	9b 81       	ldd	r25, Y+3	; 0x03
    22d8:	0c 96       	adiw	r24, 0x0c	; 12
    22da:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    22de:	80 91 18 03 	lds	r24, 0x0318
    22e2:	88 23       	and	r24, r24
    22e4:	61 f5       	brne	.+88     	; 0x233e <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    22e6:	8a 81       	ldd	r24, Y+2	; 0x02
    22e8:	9b 81       	ldd	r25, Y+3	; 0x03
    22ea:	02 96       	adiw	r24, 0x02	; 2
    22ec:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    22f0:	ea 81       	ldd	r30, Y+2	; 0x02
    22f2:	fb 81       	ldd	r31, Y+3	; 0x03
    22f4:	96 89       	ldd	r25, Z+22	; 0x16
    22f6:	80 91 16 03 	lds	r24, 0x0316
    22fa:	89 17       	cp	r24, r25
    22fc:	28 f4       	brcc	.+10     	; 0x2308 <xTaskRemoveFromEventList+0x58>
    22fe:	ea 81       	ldd	r30, Y+2	; 0x02
    2300:	fb 81       	ldd	r31, Y+3	; 0x03
    2302:	86 89       	ldd	r24, Z+22	; 0x16
    2304:	80 93 16 03 	sts	0x0316, r24
    2308:	ea 81       	ldd	r30, Y+2	; 0x02
    230a:	fb 81       	ldd	r31, Y+3	; 0x03
    230c:	86 89       	ldd	r24, Z+22	; 0x16
    230e:	28 2f       	mov	r18, r24
    2310:	30 e0       	ldi	r19, 0x00	; 0
    2312:	c9 01       	movw	r24, r18
    2314:	88 0f       	add	r24, r24
    2316:	99 1f       	adc	r25, r25
    2318:	88 0f       	add	r24, r24
    231a:	99 1f       	adc	r25, r25
    231c:	88 0f       	add	r24, r24
    231e:	99 1f       	adc	r25, r25
    2320:	82 0f       	add	r24, r18
    2322:	93 1f       	adc	r25, r19
    2324:	ac 01       	movw	r20, r24
    2326:	43 5e       	subi	r20, 0xE3	; 227
    2328:	5c 4f       	sbci	r21, 0xFC	; 252
    232a:	8a 81       	ldd	r24, Y+2	; 0x02
    232c:	9b 81       	ldd	r25, Y+3	; 0x03
    232e:	9c 01       	movw	r18, r24
    2330:	2e 5f       	subi	r18, 0xFE	; 254
    2332:	3f 4f       	sbci	r19, 0xFF	; 255
    2334:	ca 01       	movw	r24, r20
    2336:	b9 01       	movw	r22, r18
    2338:	0e 94 8c 04 	call	0x918	; 0x918 <vListInsertEnd>
    233c:	0a c0       	rjmp	.+20     	; 0x2352 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    233e:	8a 81       	ldd	r24, Y+2	; 0x02
    2340:	9b 81       	ldd	r25, Y+3	; 0x03
    2342:	9c 01       	movw	r18, r24
    2344:	24 5f       	subi	r18, 0xF4	; 244
    2346:	3f 4f       	sbci	r19, 0xFF	; 255
    2348:	80 e6       	ldi	r24, 0x60	; 96
    234a:	93 e0       	ldi	r25, 0x03	; 3
    234c:	b9 01       	movw	r22, r18
    234e:	0e 94 8c 04 	call	0x918	; 0x918 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2352:	ea 81       	ldd	r30, Y+2	; 0x02
    2354:	fb 81       	ldd	r31, Y+3	; 0x03
    2356:	96 89       	ldd	r25, Z+22	; 0x16
    2358:	e0 91 0f 03 	lds	r30, 0x030F
    235c:	f0 91 10 03 	lds	r31, 0x0310
    2360:	86 89       	ldd	r24, Z+22	; 0x16
    2362:	98 17       	cp	r25, r24
    2364:	18 f0       	brcs	.+6      	; 0x236c <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    2366:	81 e0       	ldi	r24, 0x01	; 1
    2368:	89 83       	std	Y+1, r24	; 0x01
    236a:	01 c0       	rjmp	.+2      	; 0x236e <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    236c:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    236e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2370:	0f 90       	pop	r0
    2372:	0f 90       	pop	r0
    2374:	0f 90       	pop	r0
    2376:	0f 90       	pop	r0
    2378:	0f 90       	pop	r0
    237a:	cf 91       	pop	r28
    237c:	df 91       	pop	r29
    237e:	08 95       	ret

00002380 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2380:	df 93       	push	r29
    2382:	cf 93       	push	r28
    2384:	00 d0       	rcall	.+0      	; 0x2386 <vTaskSetTimeOutState+0x6>
    2386:	cd b7       	in	r28, 0x3d	; 61
    2388:	de b7       	in	r29, 0x3e	; 62
    238a:	9a 83       	std	Y+2, r25	; 0x02
    238c:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    238e:	80 91 1b 03 	lds	r24, 0x031B
    2392:	e9 81       	ldd	r30, Y+1	; 0x01
    2394:	fa 81       	ldd	r31, Y+2	; 0x02
    2396:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2398:	80 91 13 03 	lds	r24, 0x0313
    239c:	90 91 14 03 	lds	r25, 0x0314
    23a0:	e9 81       	ldd	r30, Y+1	; 0x01
    23a2:	fa 81       	ldd	r31, Y+2	; 0x02
    23a4:	92 83       	std	Z+2, r25	; 0x02
    23a6:	81 83       	std	Z+1, r24	; 0x01
}
    23a8:	0f 90       	pop	r0
    23aa:	0f 90       	pop	r0
    23ac:	cf 91       	pop	r28
    23ae:	df 91       	pop	r29
    23b0:	08 95       	ret

000023b2 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    23b2:	df 93       	push	r29
    23b4:	cf 93       	push	r28
    23b6:	00 d0       	rcall	.+0      	; 0x23b8 <xTaskCheckForTimeOut+0x6>
    23b8:	00 d0       	rcall	.+0      	; 0x23ba <xTaskCheckForTimeOut+0x8>
    23ba:	0f 92       	push	r0
    23bc:	cd b7       	in	r28, 0x3d	; 61
    23be:	de b7       	in	r29, 0x3e	; 62
    23c0:	9b 83       	std	Y+3, r25	; 0x03
    23c2:	8a 83       	std	Y+2, r24	; 0x02
    23c4:	7d 83       	std	Y+5, r23	; 0x05
    23c6:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    23c8:	0f b6       	in	r0, 0x3f	; 63
    23ca:	f8 94       	cli
    23cc:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    23ce:	ea 81       	ldd	r30, Y+2	; 0x02
    23d0:	fb 81       	ldd	r31, Y+3	; 0x03
    23d2:	90 81       	ld	r25, Z
    23d4:	80 91 1b 03 	lds	r24, 0x031B
    23d8:	98 17       	cp	r25, r24
    23da:	71 f0       	breq	.+28     	; 0x23f8 <xTaskCheckForTimeOut+0x46>
    23dc:	ea 81       	ldd	r30, Y+2	; 0x02
    23de:	fb 81       	ldd	r31, Y+3	; 0x03
    23e0:	21 81       	ldd	r18, Z+1	; 0x01
    23e2:	32 81       	ldd	r19, Z+2	; 0x02
    23e4:	80 91 13 03 	lds	r24, 0x0313
    23e8:	90 91 14 03 	lds	r25, 0x0314
    23ec:	82 17       	cp	r24, r18
    23ee:	93 07       	cpc	r25, r19
    23f0:	18 f0       	brcs	.+6      	; 0x23f8 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    23f2:	81 e0       	ldi	r24, 0x01	; 1
    23f4:	89 83       	std	Y+1, r24	; 0x01
    23f6:	2f c0       	rjmp	.+94     	; 0x2456 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    23f8:	20 91 13 03 	lds	r18, 0x0313
    23fc:	30 91 14 03 	lds	r19, 0x0314
    2400:	ea 81       	ldd	r30, Y+2	; 0x02
    2402:	fb 81       	ldd	r31, Y+3	; 0x03
    2404:	81 81       	ldd	r24, Z+1	; 0x01
    2406:	92 81       	ldd	r25, Z+2	; 0x02
    2408:	28 1b       	sub	r18, r24
    240a:	39 0b       	sbc	r19, r25
    240c:	ec 81       	ldd	r30, Y+4	; 0x04
    240e:	fd 81       	ldd	r31, Y+5	; 0x05
    2410:	80 81       	ld	r24, Z
    2412:	91 81       	ldd	r25, Z+1	; 0x01
    2414:	28 17       	cp	r18, r24
    2416:	39 07       	cpc	r19, r25
    2418:	e0 f4       	brcc	.+56     	; 0x2452 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    241a:	ec 81       	ldd	r30, Y+4	; 0x04
    241c:	fd 81       	ldd	r31, Y+5	; 0x05
    241e:	40 81       	ld	r20, Z
    2420:	51 81       	ldd	r21, Z+1	; 0x01
    2422:	ea 81       	ldd	r30, Y+2	; 0x02
    2424:	fb 81       	ldd	r31, Y+3	; 0x03
    2426:	21 81       	ldd	r18, Z+1	; 0x01
    2428:	32 81       	ldd	r19, Z+2	; 0x02
    242a:	80 91 13 03 	lds	r24, 0x0313
    242e:	90 91 14 03 	lds	r25, 0x0314
    2432:	b9 01       	movw	r22, r18
    2434:	68 1b       	sub	r22, r24
    2436:	79 0b       	sbc	r23, r25
    2438:	cb 01       	movw	r24, r22
    243a:	84 0f       	add	r24, r20
    243c:	95 1f       	adc	r25, r21
    243e:	ec 81       	ldd	r30, Y+4	; 0x04
    2440:	fd 81       	ldd	r31, Y+5	; 0x05
    2442:	91 83       	std	Z+1, r25	; 0x01
    2444:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    2446:	8a 81       	ldd	r24, Y+2	; 0x02
    2448:	9b 81       	ldd	r25, Y+3	; 0x03
    244a:	0e 94 c0 11 	call	0x2380	; 0x2380 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    244e:	19 82       	std	Y+1, r1	; 0x01
    2450:	02 c0       	rjmp	.+4      	; 0x2456 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    2452:	81 e0       	ldi	r24, 0x01	; 1
    2454:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2456:	0f 90       	pop	r0
    2458:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    245a:	89 81       	ldd	r24, Y+1	; 0x01
}
    245c:	0f 90       	pop	r0
    245e:	0f 90       	pop	r0
    2460:	0f 90       	pop	r0
    2462:	0f 90       	pop	r0
    2464:	0f 90       	pop	r0
    2466:	cf 91       	pop	r28
    2468:	df 91       	pop	r29
    246a:	08 95       	ret

0000246c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    246c:	df 93       	push	r29
    246e:	cf 93       	push	r28
    2470:	cd b7       	in	r28, 0x3d	; 61
    2472:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    2474:	81 e0       	ldi	r24, 0x01	; 1
    2476:	80 93 1a 03 	sts	0x031A, r24
}
    247a:	cf 91       	pop	r28
    247c:	df 91       	pop	r29
    247e:	08 95       	ret

00002480 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    2480:	df 93       	push	r29
    2482:	cf 93       	push	r28
    2484:	00 d0       	rcall	.+0      	; 0x2486 <prvIdleTask+0x6>
    2486:	cd b7       	in	r28, 0x3d	; 61
    2488:	de b7       	in	r29, 0x3e	; 62
    248a:	9a 83       	std	Y+2, r25	; 0x02
    248c:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    248e:	0e 94 de 12 	call	0x25bc	; 0x25bc <prvCheckTasksWaitingTermination>
    2492:	fd cf       	rjmp	.-6      	; 0x248e <prvIdleTask+0xe>

00002494 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    2494:	0f 93       	push	r16
    2496:	1f 93       	push	r17
    2498:	df 93       	push	r29
    249a:	cf 93       	push	r28
    249c:	cd b7       	in	r28, 0x3d	; 61
    249e:	de b7       	in	r29, 0x3e	; 62
    24a0:	29 97       	sbiw	r28, 0x09	; 9
    24a2:	0f b6       	in	r0, 0x3f	; 63
    24a4:	f8 94       	cli
    24a6:	de bf       	out	0x3e, r29	; 62
    24a8:	0f be       	out	0x3f, r0	; 63
    24aa:	cd bf       	out	0x3d, r28	; 61
    24ac:	9a 83       	std	Y+2, r25	; 0x02
    24ae:	89 83       	std	Y+1, r24	; 0x01
    24b0:	7c 83       	std	Y+4, r23	; 0x04
    24b2:	6b 83       	std	Y+3, r22	; 0x03
    24b4:	4d 83       	std	Y+5, r20	; 0x05
    24b6:	3f 83       	std	Y+7, r19	; 0x07
    24b8:	2e 83       	std	Y+6, r18	; 0x06
    24ba:	19 87       	std	Y+9, r17	; 0x09
    24bc:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    24be:	89 81       	ldd	r24, Y+1	; 0x01
    24c0:	9a 81       	ldd	r25, Y+2	; 0x02
    24c2:	49 96       	adiw	r24, 0x19	; 25
    24c4:	2b 81       	ldd	r18, Y+3	; 0x03
    24c6:	3c 81       	ldd	r19, Y+4	; 0x04
    24c8:	b9 01       	movw	r22, r18
    24ca:	48 e0       	ldi	r20, 0x08	; 8
    24cc:	50 e0       	ldi	r21, 0x00	; 0
    24ce:	0e 94 db 13 	call	0x27b6	; 0x27b6 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    24d2:	e9 81       	ldd	r30, Y+1	; 0x01
    24d4:	fa 81       	ldd	r31, Y+2	; 0x02
    24d6:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    24d8:	8d 81       	ldd	r24, Y+5	; 0x05
    24da:	85 30       	cpi	r24, 0x05	; 5
    24dc:	10 f0       	brcs	.+4      	; 0x24e2 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    24de:	84 e0       	ldi	r24, 0x04	; 4
    24e0:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    24e2:	e9 81       	ldd	r30, Y+1	; 0x01
    24e4:	fa 81       	ldd	r31, Y+2	; 0x02
    24e6:	8d 81       	ldd	r24, Y+5	; 0x05
    24e8:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    24ea:	89 81       	ldd	r24, Y+1	; 0x01
    24ec:	9a 81       	ldd	r25, Y+2	; 0x02
    24ee:	02 96       	adiw	r24, 0x02	; 2
    24f0:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    24f4:	89 81       	ldd	r24, Y+1	; 0x01
    24f6:	9a 81       	ldd	r25, Y+2	; 0x02
    24f8:	0c 96       	adiw	r24, 0x0c	; 12
    24fa:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    24fe:	e9 81       	ldd	r30, Y+1	; 0x01
    2500:	fa 81       	ldd	r31, Y+2	; 0x02
    2502:	89 81       	ldd	r24, Y+1	; 0x01
    2504:	9a 81       	ldd	r25, Y+2	; 0x02
    2506:	91 87       	std	Z+9, r25	; 0x09
    2508:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    250a:	8d 81       	ldd	r24, Y+5	; 0x05
    250c:	28 2f       	mov	r18, r24
    250e:	30 e0       	ldi	r19, 0x00	; 0
    2510:	85 e0       	ldi	r24, 0x05	; 5
    2512:	90 e0       	ldi	r25, 0x00	; 0
    2514:	82 1b       	sub	r24, r18
    2516:	93 0b       	sbc	r25, r19
    2518:	e9 81       	ldd	r30, Y+1	; 0x01
    251a:	fa 81       	ldd	r31, Y+2	; 0x02
    251c:	95 87       	std	Z+13, r25	; 0x0d
    251e:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2520:	e9 81       	ldd	r30, Y+1	; 0x01
    2522:	fa 81       	ldd	r31, Y+2	; 0x02
    2524:	89 81       	ldd	r24, Y+1	; 0x01
    2526:	9a 81       	ldd	r25, Y+2	; 0x02
    2528:	93 8b       	std	Z+19, r25	; 0x13
    252a:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    252c:	29 96       	adiw	r28, 0x09	; 9
    252e:	0f b6       	in	r0, 0x3f	; 63
    2530:	f8 94       	cli
    2532:	de bf       	out	0x3e, r29	; 62
    2534:	0f be       	out	0x3f, r0	; 63
    2536:	cd bf       	out	0x3d, r28	; 61
    2538:	cf 91       	pop	r28
    253a:	df 91       	pop	r29
    253c:	1f 91       	pop	r17
    253e:	0f 91       	pop	r16
    2540:	08 95       	ret

00002542 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    2542:	df 93       	push	r29
    2544:	cf 93       	push	r28
    2546:	0f 92       	push	r0
    2548:	cd b7       	in	r28, 0x3d	; 61
    254a:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    254c:	19 82       	std	Y+1, r1	; 0x01
    254e:	13 c0       	rjmp	.+38     	; 0x2576 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2550:	89 81       	ldd	r24, Y+1	; 0x01
    2552:	28 2f       	mov	r18, r24
    2554:	30 e0       	ldi	r19, 0x00	; 0
    2556:	c9 01       	movw	r24, r18
    2558:	88 0f       	add	r24, r24
    255a:	99 1f       	adc	r25, r25
    255c:	88 0f       	add	r24, r24
    255e:	99 1f       	adc	r25, r25
    2560:	88 0f       	add	r24, r24
    2562:	99 1f       	adc	r25, r25
    2564:	82 0f       	add	r24, r18
    2566:	93 1f       	adc	r25, r19
    2568:	83 5e       	subi	r24, 0xE3	; 227
    256a:	9c 4f       	sbci	r25, 0xFC	; 252
    256c:	0e 94 52 04 	call	0x8a4	; 0x8a4 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2570:	89 81       	ldd	r24, Y+1	; 0x01
    2572:	8f 5f       	subi	r24, 0xFF	; 255
    2574:	89 83       	std	Y+1, r24	; 0x01
    2576:	89 81       	ldd	r24, Y+1	; 0x01
    2578:	85 30       	cpi	r24, 0x05	; 5
    257a:	50 f3       	brcs	.-44     	; 0x2550 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    257c:	8a e4       	ldi	r24, 0x4A	; 74
    257e:	93 e0       	ldi	r25, 0x03	; 3
    2580:	0e 94 52 04 	call	0x8a4	; 0x8a4 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2584:	83 e5       	ldi	r24, 0x53	; 83
    2586:	93 e0       	ldi	r25, 0x03	; 3
    2588:	0e 94 52 04 	call	0x8a4	; 0x8a4 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    258c:	80 e6       	ldi	r24, 0x60	; 96
    258e:	93 e0       	ldi	r25, 0x03	; 3
    2590:	0e 94 52 04 	call	0x8a4	; 0x8a4 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    2594:	89 e6       	ldi	r24, 0x69	; 105
    2596:	93 e0       	ldi	r25, 0x03	; 3
    2598:	0e 94 52 04 	call	0x8a4	; 0x8a4 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    259c:	8a e4       	ldi	r24, 0x4A	; 74
    259e:	93 e0       	ldi	r25, 0x03	; 3
    25a0:	90 93 5d 03 	sts	0x035D, r25
    25a4:	80 93 5c 03 	sts	0x035C, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    25a8:	83 e5       	ldi	r24, 0x53	; 83
    25aa:	93 e0       	ldi	r25, 0x03	; 3
    25ac:	90 93 5f 03 	sts	0x035F, r25
    25b0:	80 93 5e 03 	sts	0x035E, r24
}
    25b4:	0f 90       	pop	r0
    25b6:	cf 91       	pop	r28
    25b8:	df 91       	pop	r29
    25ba:	08 95       	ret

000025bc <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    25bc:	df 93       	push	r29
    25be:	cf 93       	push	r28
    25c0:	00 d0       	rcall	.+0      	; 0x25c2 <prvCheckTasksWaitingTermination+0x6>
    25c2:	0f 92       	push	r0
    25c4:	cd b7       	in	r28, 0x3d	; 61
    25c6:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    25c8:	80 91 11 03 	lds	r24, 0x0311
    25cc:	88 23       	and	r24, r24
    25ce:	71 f1       	breq	.+92     	; 0x262c <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    25d0:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    25d4:	80 91 69 03 	lds	r24, 0x0369
    25d8:	1b 82       	std	Y+3, r1	; 0x03
    25da:	88 23       	and	r24, r24
    25dc:	11 f4       	brne	.+4      	; 0x25e2 <prvCheckTasksWaitingTermination+0x26>
    25de:	81 e0       	ldi	r24, 0x01	; 1
    25e0:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    25e2:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    25e6:	8b 81       	ldd	r24, Y+3	; 0x03
    25e8:	88 23       	and	r24, r24
    25ea:	01 f5       	brne	.+64     	; 0x262c <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    25ec:	0f b6       	in	r0, 0x3f	; 63
    25ee:	f8 94       	cli
    25f0:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    25f2:	e0 91 6e 03 	lds	r30, 0x036E
    25f6:	f0 91 6f 03 	lds	r31, 0x036F
    25fa:	86 81       	ldd	r24, Z+6	; 0x06
    25fc:	97 81       	ldd	r25, Z+7	; 0x07
    25fe:	9a 83       	std	Y+2, r25	; 0x02
    2600:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    2602:	89 81       	ldd	r24, Y+1	; 0x01
    2604:	9a 81       	ldd	r25, Y+2	; 0x02
    2606:	02 96       	adiw	r24, 0x02	; 2
    2608:	0e 94 44 05 	call	0xa88	; 0xa88 <vListRemove>
					--uxCurrentNumberOfTasks;
    260c:	80 91 12 03 	lds	r24, 0x0312
    2610:	81 50       	subi	r24, 0x01	; 1
    2612:	80 93 12 03 	sts	0x0312, r24
					--uxTasksDeleted;
    2616:	80 91 11 03 	lds	r24, 0x0311
    261a:	81 50       	subi	r24, 0x01	; 1
    261c:	80 93 11 03 	sts	0x0311, r24
				}
				taskEXIT_CRITICAL();
    2620:	0f 90       	pop	r0
    2622:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    2624:	89 81       	ldd	r24, Y+1	; 0x01
    2626:	9a 81       	ldd	r25, Y+2	; 0x02
    2628:	0e 94 b5 13 	call	0x276a	; 0x276a <prvDeleteTCB>
			}
		}
	}
	#endif
}
    262c:	0f 90       	pop	r0
    262e:	0f 90       	pop	r0
    2630:	0f 90       	pop	r0
    2632:	cf 91       	pop	r28
    2634:	df 91       	pop	r29
    2636:	08 95       	ret

00002638 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    2638:	df 93       	push	r29
    263a:	cf 93       	push	r28
    263c:	00 d0       	rcall	.+0      	; 0x263e <prvAddCurrentTaskToDelayedList+0x6>
    263e:	cd b7       	in	r28, 0x3d	; 61
    2640:	de b7       	in	r29, 0x3e	; 62
    2642:	9a 83       	std	Y+2, r25	; 0x02
    2644:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2646:	e0 91 0f 03 	lds	r30, 0x030F
    264a:	f0 91 10 03 	lds	r31, 0x0310
    264e:	89 81       	ldd	r24, Y+1	; 0x01
    2650:	9a 81       	ldd	r25, Y+2	; 0x02
    2652:	93 83       	std	Z+3, r25	; 0x03
    2654:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    2656:	20 91 13 03 	lds	r18, 0x0313
    265a:	30 91 14 03 	lds	r19, 0x0314
    265e:	89 81       	ldd	r24, Y+1	; 0x01
    2660:	9a 81       	ldd	r25, Y+2	; 0x02
    2662:	82 17       	cp	r24, r18
    2664:	93 07       	cpc	r25, r19
    2666:	70 f4       	brcc	.+28     	; 0x2684 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2668:	80 91 5e 03 	lds	r24, 0x035E
    266c:	90 91 5f 03 	lds	r25, 0x035F
    2670:	20 91 0f 03 	lds	r18, 0x030F
    2674:	30 91 10 03 	lds	r19, 0x0310
    2678:	2e 5f       	subi	r18, 0xFE	; 254
    267a:	3f 4f       	sbci	r19, 0xFF	; 255
    267c:	b9 01       	movw	r22, r18
    267e:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <vListInsert>
    2682:	1e c0       	rjmp	.+60     	; 0x26c0 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2684:	40 91 5c 03 	lds	r20, 0x035C
    2688:	50 91 5d 03 	lds	r21, 0x035D
    268c:	80 91 0f 03 	lds	r24, 0x030F
    2690:	90 91 10 03 	lds	r25, 0x0310
    2694:	9c 01       	movw	r18, r24
    2696:	2e 5f       	subi	r18, 0xFE	; 254
    2698:	3f 4f       	sbci	r19, 0xFF	; 255
    269a:	ca 01       	movw	r24, r20
    269c:	b9 01       	movw	r22, r18
    269e:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    26a2:	20 91 77 00 	lds	r18, 0x0077
    26a6:	30 91 78 00 	lds	r19, 0x0078
    26aa:	89 81       	ldd	r24, Y+1	; 0x01
    26ac:	9a 81       	ldd	r25, Y+2	; 0x02
    26ae:	82 17       	cp	r24, r18
    26b0:	93 07       	cpc	r25, r19
    26b2:	30 f4       	brcc	.+12     	; 0x26c0 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    26b4:	89 81       	ldd	r24, Y+1	; 0x01
    26b6:	9a 81       	ldd	r25, Y+2	; 0x02
    26b8:	90 93 78 00 	sts	0x0078, r25
    26bc:	80 93 77 00 	sts	0x0077, r24
		}
	}
}
    26c0:	0f 90       	pop	r0
    26c2:	0f 90       	pop	r0
    26c4:	cf 91       	pop	r28
    26c6:	df 91       	pop	r29
    26c8:	08 95       	ret

000026ca <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    26ca:	df 93       	push	r29
    26cc:	cf 93       	push	r28
    26ce:	cd b7       	in	r28, 0x3d	; 61
    26d0:	de b7       	in	r29, 0x3e	; 62
    26d2:	28 97       	sbiw	r28, 0x08	; 8
    26d4:	0f b6       	in	r0, 0x3f	; 63
    26d6:	f8 94       	cli
    26d8:	de bf       	out	0x3e, r29	; 62
    26da:	0f be       	out	0x3f, r0	; 63
    26dc:	cd bf       	out	0x3d, r28	; 61
    26de:	9c 83       	std	Y+4, r25	; 0x04
    26e0:	8b 83       	std	Y+3, r24	; 0x03
    26e2:	7e 83       	std	Y+6, r23	; 0x06
    26e4:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    26e6:	81 e2       	ldi	r24, 0x21	; 33
    26e8:	90 e0       	ldi	r25, 0x00	; 0
    26ea:	0e 94 e6 03 	call	0x7cc	; 0x7cc <pvPortMalloc>
    26ee:	9a 83       	std	Y+2, r25	; 0x02
    26f0:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    26f2:	89 81       	ldd	r24, Y+1	; 0x01
    26f4:	9a 81       	ldd	r25, Y+2	; 0x02
    26f6:	00 97       	sbiw	r24, 0x00	; 0
    26f8:	69 f1       	breq	.+90     	; 0x2754 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    26fa:	8d 81       	ldd	r24, Y+5	; 0x05
    26fc:	9e 81       	ldd	r25, Y+6	; 0x06
    26fe:	00 97       	sbiw	r24, 0x00	; 0
    2700:	39 f4       	brne	.+14     	; 0x2710 <prvAllocateTCBAndStack+0x46>
    2702:	8b 81       	ldd	r24, Y+3	; 0x03
    2704:	9c 81       	ldd	r25, Y+4	; 0x04
    2706:	0e 94 e6 03 	call	0x7cc	; 0x7cc <pvPortMalloc>
    270a:	98 87       	std	Y+8, r25	; 0x08
    270c:	8f 83       	std	Y+7, r24	; 0x07
    270e:	04 c0       	rjmp	.+8      	; 0x2718 <prvAllocateTCBAndStack+0x4e>
    2710:	8d 81       	ldd	r24, Y+5	; 0x05
    2712:	9e 81       	ldd	r25, Y+6	; 0x06
    2714:	98 87       	std	Y+8, r25	; 0x08
    2716:	8f 83       	std	Y+7, r24	; 0x07
    2718:	e9 81       	ldd	r30, Y+1	; 0x01
    271a:	fa 81       	ldd	r31, Y+2	; 0x02
    271c:	8f 81       	ldd	r24, Y+7	; 0x07
    271e:	98 85       	ldd	r25, Y+8	; 0x08
    2720:	90 8f       	std	Z+24, r25	; 0x18
    2722:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    2724:	e9 81       	ldd	r30, Y+1	; 0x01
    2726:	fa 81       	ldd	r31, Y+2	; 0x02
    2728:	87 89       	ldd	r24, Z+23	; 0x17
    272a:	90 8d       	ldd	r25, Z+24	; 0x18
    272c:	00 97       	sbiw	r24, 0x00	; 0
    272e:	39 f4       	brne	.+14     	; 0x273e <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2730:	89 81       	ldd	r24, Y+1	; 0x01
    2732:	9a 81       	ldd	r25, Y+2	; 0x02
    2734:	0e 94 2c 04 	call	0x858	; 0x858 <vPortFree>
			pxNewTCB = NULL;
    2738:	1a 82       	std	Y+2, r1	; 0x02
    273a:	19 82       	std	Y+1, r1	; 0x01
    273c:	0b c0       	rjmp	.+22     	; 0x2754 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    273e:	e9 81       	ldd	r30, Y+1	; 0x01
    2740:	fa 81       	ldd	r31, Y+2	; 0x02
    2742:	87 89       	ldd	r24, Z+23	; 0x17
    2744:	90 8d       	ldd	r25, Z+24	; 0x18
    2746:	2b 81       	ldd	r18, Y+3	; 0x03
    2748:	3c 81       	ldd	r19, Y+4	; 0x04
    274a:	65 ea       	ldi	r22, 0xA5	; 165
    274c:	70 e0       	ldi	r23, 0x00	; 0
    274e:	a9 01       	movw	r20, r18
    2750:	0e 94 d4 13 	call	0x27a8	; 0x27a8 <memset>
		}
	}

	return pxNewTCB;
    2754:	89 81       	ldd	r24, Y+1	; 0x01
    2756:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2758:	28 96       	adiw	r28, 0x08	; 8
    275a:	0f b6       	in	r0, 0x3f	; 63
    275c:	f8 94       	cli
    275e:	de bf       	out	0x3e, r29	; 62
    2760:	0f be       	out	0x3f, r0	; 63
    2762:	cd bf       	out	0x3d, r28	; 61
    2764:	cf 91       	pop	r28
    2766:	df 91       	pop	r29
    2768:	08 95       	ret

0000276a <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    276a:	df 93       	push	r29
    276c:	cf 93       	push	r28
    276e:	00 d0       	rcall	.+0      	; 0x2770 <prvDeleteTCB+0x6>
    2770:	cd b7       	in	r28, 0x3d	; 61
    2772:	de b7       	in	r29, 0x3e	; 62
    2774:	9a 83       	std	Y+2, r25	; 0x02
    2776:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    2778:	e9 81       	ldd	r30, Y+1	; 0x01
    277a:	fa 81       	ldd	r31, Y+2	; 0x02
    277c:	87 89       	ldd	r24, Z+23	; 0x17
    277e:	90 8d       	ldd	r25, Z+24	; 0x18
    2780:	0e 94 2c 04 	call	0x858	; 0x858 <vPortFree>
		vPortFree( pxTCB );
    2784:	89 81       	ldd	r24, Y+1	; 0x01
    2786:	9a 81       	ldd	r25, Y+2	; 0x02
    2788:	0e 94 2c 04 	call	0x858	; 0x858 <vPortFree>
	}
    278c:	0f 90       	pop	r0
    278e:	0f 90       	pop	r0
    2790:	cf 91       	pop	r28
    2792:	df 91       	pop	r29
    2794:	08 95       	ret

00002796 <memcpy>:
    2796:	fb 01       	movw	r30, r22
    2798:	dc 01       	movw	r26, r24
    279a:	02 c0       	rjmp	.+4      	; 0x27a0 <memcpy+0xa>
    279c:	01 90       	ld	r0, Z+
    279e:	0d 92       	st	X+, r0
    27a0:	41 50       	subi	r20, 0x01	; 1
    27a2:	50 40       	sbci	r21, 0x00	; 0
    27a4:	d8 f7       	brcc	.-10     	; 0x279c <memcpy+0x6>
    27a6:	08 95       	ret

000027a8 <memset>:
    27a8:	dc 01       	movw	r26, r24
    27aa:	01 c0       	rjmp	.+2      	; 0x27ae <memset+0x6>
    27ac:	6d 93       	st	X+, r22
    27ae:	41 50       	subi	r20, 0x01	; 1
    27b0:	50 40       	sbci	r21, 0x00	; 0
    27b2:	e0 f7       	brcc	.-8      	; 0x27ac <memset+0x4>
    27b4:	08 95       	ret

000027b6 <strncpy>:
    27b6:	fb 01       	movw	r30, r22
    27b8:	dc 01       	movw	r26, r24
    27ba:	41 50       	subi	r20, 0x01	; 1
    27bc:	50 40       	sbci	r21, 0x00	; 0
    27be:	48 f0       	brcs	.+18     	; 0x27d2 <strncpy+0x1c>
    27c0:	01 90       	ld	r0, Z+
    27c2:	0d 92       	st	X+, r0
    27c4:	00 20       	and	r0, r0
    27c6:	c9 f7       	brne	.-14     	; 0x27ba <strncpy+0x4>
    27c8:	01 c0       	rjmp	.+2      	; 0x27cc <strncpy+0x16>
    27ca:	1d 92       	st	X+, r1
    27cc:	41 50       	subi	r20, 0x01	; 1
    27ce:	50 40       	sbci	r21, 0x00	; 0
    27d0:	e0 f7       	brcc	.-8      	; 0x27ca <strncpy+0x14>
    27d2:	08 95       	ret

000027d4 <_exit>:
    27d4:	f8 94       	cli

000027d6 <__stop_program>:
    27d6:	ff cf       	rjmp	.-2      	; 0x27d6 <__stop_program>
